# Comparing `tmp/stopeight-0.3.14.tar.gz` & `tmp/stopeight-0.3.22.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/stopeight-0.3.14.tar", last modified: Sun May 10 09:25:04 2020, max compression
+gzip compressed data, was "stopeight-0.3.22.tar", last modified: Wed Apr 26 14:11:29 2023, max compression
```

## Comparing `stopeight-0.3.14.tar` & `stopeight-0.3.22.tar`

### file list

```diff
@@ -1,309 +1,325 @@
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.675025 stopeight-0.3.14/
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.651025 stopeight-0.3.14/.github/
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.655025 stopeight-0.3.14/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (116)     2621 2020-05-10 09:24:28.000000 stopeight-0.3.14/.github/workflows/conda-build.yml
--rw-r--r--   0 runner    (1001) docker     (116)      822 2020-05-10 09:24:28.000000 stopeight-0.3.14/.github/workflows/pypi-sdist.yml
--rw-r--r--   0 runner    (1001) docker     (116)       17 2020-05-10 09:24:28.000000 stopeight-0.3.14/.gitignore
--rw-r--r--   0 runner    (1001) docker     (116)      195 2020-05-10 09:24:28.000000 stopeight-0.3.14/.gitmodules
--rw-r--r--   0 runner    (1001) docker     (116)      352 2020-05-10 09:24:28.000000 stopeight-0.3.14/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (116)    15220 2020-05-10 09:24:28.000000 stopeight-0.3.14/LICENSE.txt
--rw-r--r--   0 runner    (1001) docker     (116)      934 2020-05-10 09:24:28.000000 stopeight-0.3.14/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (116)     1211 2020-05-10 09:25:04.675025 stopeight-0.3.14/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (116)      186 2020-05-10 09:24:28.000000 stopeight-0.3.14/README.md
--rw-r--r--   0 runner    (1001) docker     (116)     3953 2020-05-10 09:24:28.000000 stopeight-0.3.14/cmake.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.655025 stopeight-0.3.14/doc/
--rw-r--r--   0 runner    (1001) docker     (116)     5576 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/Makefile
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.655025 stopeight-0.3.14/doc/_extra/
--rw-r--r--   0 runner    (1001) docker     (116)        0 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_extra/.nojekyll
--rw-r--r--   0 runner    (1001) docker     (116)       24 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_extra/robots.txt
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.659025 stopeight-0.3.14/doc/_static/
--rw-r--r--   0 runner    (1001) docker     (116)    10172 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_static/cliff.svg
--rw-r--r--   0 runner    (1001) docker     (116)   235608 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_static/crab.png
--rw-r--r--   0 runner    (1001) docker     (116)    13213 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_static/crest.svg
--rw-r--r--   0 runner    (1001) docker     (116)    15246 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_static/crest_or_sinusoid.svg
--rw-r--r--   0 runner    (1001) docker     (116)    28117 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_static/extraction_sequence.svg
--rw-r--r--   0 runner    (1001) docker     (116)    26892 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_static/function_graph.svg
--rw-r--r--   0 runner    (1001) docker     (116)    12623 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_static/sinus.svg
--rw-r--r--   0 runner    (1001) docker     (116)    25550 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_static/text.svg
--rw-r--r--   0 runner    (1001) docker     (116)   115146 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_static/vector_construction.svg
--rw-r--r--   0 runner    (1001) docker     (116)    47143 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_static/vector_graph.svg
--rw-r--r--   0 runner    (1001) docker     (116)    47729 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_static/vector_graph2.svg
--rw-r--r--   0 runner    (1001) docker     (116)    49772 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_static/vector_graph3.svg
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.659025 stopeight-0.3.14/doc/_templates/
--rw-r--r--   0 runner    (1001) docker     (116)      195 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/_templates/layout.html
--rw-r--r--   0 runner    (1001) docker     (116)      549 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/analyzer.txt
--rw-r--r--   0 runner    (1001) docker     (116)      881 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/applications.txt
--rw-r--r--   0 runner    (1001) docker     (116)      744 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/build_latex.txt
--rw-r--r--   0 runner    (1001) docker     (116)     8365 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/conf.py
--rw-r--r--   0 runner    (1001) docker     (116)     1751 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/dev_analyzer.txt
--rw-r--r--   0 runner    (1001) docker     (116)     1463 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/dev_build.txt
--rw-r--r--   0 runner    (1001) docker     (116)     1297 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/dev_comparator.txt
--rw-r--r--   0 runner    (1001) docker     (116)      726 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/dev_doc.txt
--rw-r--r--   0 runner    (1001) docker     (116)      469 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/dev_stroke-analyzer.txt
--rw-r--r--   0 runner    (1001) docker     (116)      667 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/index.txt
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.659025 stopeight-0.3.14/doc/latex/
--rw-r--r--   0 runner    (1001) docker     (116)     7412 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/latex/Antis.tex
--rw-r--r--   0 runner    (1001) docker     (116)    15263 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/latex/Not_Used.tex
--rw-r--r--   0 runner    (1001) docker     (116)     3445 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/latex/Simulation.tex
--rw-r--r--   0 runner    (1001) docker     (116)     7208 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/latex/Spline_Axioms.tex
--rw-r--r--   0 runner    (1001) docker     (116)     3897 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/latex/Stopeight.bib
--rw-r--r--   0 runner    (1001) docker     (116)    21876 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/latex/Stopeight_Analyzer.tex
--rw-r--r--   0 runner    (1001) docker     (116)     7662 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/latex/Stopeight_Comparator.tex
--rw-r--r--   0 runner    (1001) docker     (116)     6396 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/latex/Stopeight_Grapher.tex
--rw-r--r--   0 runner    (1001) docker     (116)     5102 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/make.bat
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.659025 stopeight-0.3.14/doc/mathematica/
--rw-r--r--   0 runner    (1001) docker     (116)     6553 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/mathematica/Spline.m
--rw-r--r--   0 runner    (1001) docker     (116)    50815 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/mathematica/Spline_CharacteristicPolynomials.nb
--rw-r--r--   0 runner    (1001) docker     (116)    38485 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/mathematica/Spline_EVConstraint.nb
--rw-r--r--   0 runner    (1001) docker     (116)    48711 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/mathematica/Spline_Eigensystems.nb
--rw-r--r--   0 runner    (1001) docker     (116)    31243 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/mathematica/Spline_Generative.nb
--rw-r--r--   0 runner    (1001) docker     (116)    11159 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/mathematica/Spline_Pascal.nb
--rw-r--r--   0 runner    (1001) docker     (116)      713 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/mathematica/SubSpaces.m
--rw-r--r--   0 runner    (1001) docker     (116)      580 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/run_comparator.txt
--rw-r--r--   0 runner    (1001) docker     (116)      405 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/run_editor.txt
--rw-r--r--   0 runner    (1001) docker     (116)      351 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/run_tests.txt
--rw-r--r--   0 runner    (1001) docker     (116)      638 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/sample-data.txt
--rw-r--r--   0 runner    (1001) docker     (116)      716 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/stopeight.txt
--rw-r--r--   0 runner    (1001) docker     (116)      590 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/theory.txt
--rw-r--r--   0 runner    (1001) docker     (116)     2673 2020-05-10 09:24:28.000000 stopeight-0.3.14/doc/vector-graph.txt
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.659025 stopeight-0.3.14/pybind11/
--rw-r--r--   0 runner    (1001) docker     (116)     6507 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.651025 stopeight-0.3.14/pybind11/include/
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/pybind11/include/pybind11/
--rw-r--r--   0 runner    (1001) docker     (116)    20266 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/attr.h
--rw-r--r--   0 runner    (1001) docker     (116)     4823 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/buffer_info.h
--rw-r--r--   0 runner    (1001) docker     (116)    92528 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/cast.h
--rw-r--r--   0 runner    (1001) docker     (116)     7701 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/chrono.h
--rw-r--r--   0 runner    (1001) docker     (116)      120 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/common.h
--rw-r--r--   0 runner    (1001) docker     (116)     2001 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/complex.h
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/pybind11/include/pybind11/detail/
--rw-r--r--   0 runner    (1001) docker     (116)    25371 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/detail/class.h
--rw-r--r--   0 runner    (1001) docker     (116)    37853 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/detail/common.h
--rw-r--r--   0 runner    (1001) docker     (116)     3566 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/detail/descr.h
--rw-r--r--   0 runner    (1001) docker     (116)    16322 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/detail/init.h
--rw-r--r--   0 runner    (1001) docker     (116)    15964 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/detail/internals.h
--rw-r--r--   0 runner    (1001) docker     (116)     1450 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/detail/typeid.h
--rw-r--r--   0 runner    (1001) docker     (116)    29043 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/eigen.h
--rw-r--r--   0 runner    (1001) docker     (116)     7849 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/embed.h
--rw-r--r--   0 runner    (1001) docker     (116)     3865 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/eval.h
--rw-r--r--   0 runner    (1001) docker     (116)     3599 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/functional.h
--rw-r--r--   0 runner    (1001) docker     (116)     5655 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/iostream.h
--rw-r--r--   0 runner    (1001) docker     (116)    67735 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/numpy.h
--rw-r--r--   0 runner    (1001) docker     (116)     8749 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/operators.h
--rw-r--r--   0 runner    (1001) docker     (116)     2031 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/options.h
--rw-r--r--   0 runner    (1001) docker     (116)    98844 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/pybind11.h
--rw-r--r--   0 runner    (1001) docker     (116)    58474 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/pytypes.h
--rw-r--r--   0 runner    (1001) docker     (116)    14029 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/stl.h
--rw-r--r--   0 runner    (1001) docker     (116)    23239 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/include/pybind11/stl_bind.h
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/pybind11/tests/
--rw-r--r--   0 runner    (1001) docker     (116)     9502 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/tests/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/pybind11/tests/test_cmake_build/
--rw-r--r--   0 runner    (1001) docker     (116)     2042 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/tests/test_cmake_build/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/pybind11/tests/test_cmake_build/installed_embed/
--rw-r--r--   0 runner    (1001) docker     (116)      686 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/tests/test_cmake_build/installed_embed/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/pybind11/tests/test_cmake_build/installed_function/
--rw-r--r--   0 runner    (1001) docker     (116)      474 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/tests/test_cmake_build/installed_function/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/pybind11/tests/test_cmake_build/installed_target/
--rw-r--r--   0 runner    (1001) docker     (116)     1056 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/tests/test_cmake_build/installed_target/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/pybind11/tests/test_cmake_build/subdirectory_embed/
--rw-r--r--   0 runner    (1001) docker     (116)      852 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/pybind11/tests/test_cmake_build/subdirectory_function/
--rw-r--r--   0 runner    (1001) docker     (116)      373 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/tests/test_cmake_build/subdirectory_function/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/pybind11/tests/test_cmake_build/subdirectory_target/
--rw-r--r--   0 runner    (1001) docker     (116)      695 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/tests/test_cmake_build/subdirectory_target/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/pybind11/tests/test_embed/
--rw-r--r--   0 runner    (1001) docker     (116)     1527 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/tests/test_embed/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/pybind11/tools/
--rw-r--r--   0 runner    (1001) docker     (116)     2100 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/tools/FindCatch.cmake
--rw-r--r--   0 runner    (1001) docker     (116)     2995 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/tools/FindEigen3.cmake
--rw-r--r--   0 runner    (1001) docker     (116)     8383 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/tools/FindPythonLibsNew.cmake
--rw-r--r--   0 runner    (1001) docker     (116)    10098 2020-05-10 09:24:30.000000 stopeight-0.3.14/pybind11/tools/pybind11Tools.cmake
--rw-r--r--   0 runner    (1001) docker     (116)       78 2020-05-10 09:24:28.000000 stopeight-0.3.14/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (116)     2614 2020-05-10 09:24:28.000000 stopeight-0.3.14/python.py
--rw-r--r--   0 runner    (1001) docker     (116)      151 2020-05-10 09:24:28.000000 stopeight-0.3.14/requirements.txt
--rw-r--r--   0 runner    (1001) docker     (116)     3835 2020-05-10 09:24:28.000000 stopeight-0.3.14/setup-old.py
--rw-r--r--   0 runner    (1001) docker     (116)     1167 2020-05-10 09:25:04.679025 stopeight-0.3.14/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (116)     1107 2020-05-10 09:24:28.000000 stopeight-0.3.14/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.655025 stopeight-0.3.14/stopeight/
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.675025 stopeight-0.3.14/stopeight/comparator/
--rw-r--r--   0 runner    (1001) docker     (116)     6881 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/comparator/lineMatch.py
--rw-r--r--   0 runner    (1001) docker     (116)     1641 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/comparator/matrix.py
--rw-r--r--   0 runner    (1001) docker     (116)     1430 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/comparator/matrixTools.py
--rw-r--r--   0 runner    (1001) docker     (116)     1413 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/comparator/matrixTools_new.py
--rw-r--r--   0 runner    (1001) docker     (116)     2656 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/comparator/shapeMatch.py
--rw-r--r--   0 runner    (1001) docker     (116)     2032 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/comparator/shapeMatchSubSection.py
--rw-r--r--   0 runner    (1001) docker     (116)     1918 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/comparator/vectorTools.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.675025 stopeight-0.3.14/stopeight/logging/
--rw-r--r--   0 runner    (1001) docker     (116)     2179 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/logging/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.675025 stopeight-0.3.14/stopeight/multiprocessing/
--rw-r--r--   0 runner    (1001) docker     (116)     4459 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/multiprocessing/pooling.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.675025 stopeight-0.3.14/stopeight/test/
--rw-r--r--   0 runner    (1001) docker     (116)      359 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/test/test_analyzer.py
--rw-r--r--   0 runner    (1001) docker     (116)      631 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/test/test_comparator.py
--rw-r--r--   0 runner    (1001) docker     (116)      883 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/test/test_grapher.py
--rw-r--r--   0 runner    (1001) docker     (116)      702 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/test/test_legacy.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.675025 stopeight-0.3.14/stopeight/util/
--rw-r--r--   0 runner    (1001) docker     (116)     4809 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/SVG.py
--rw-r--r--   0 runner    (1001) docker     (116)      327 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/SVGViewer.py
--rw-r--r--   0 runner    (1001) docker     (116)     1244 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/TCT_printer.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.675025 stopeight-0.3.14/stopeight/util/editor/
--rw-r--r--   0 runner    (1001) docker     (116)      935 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/editor/callwindow.py
--rw-r--r--   0 runner    (1001) docker     (116)     9197 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/editor/command.py
--rw-r--r--   0 runner    (1001) docker     (116)      763 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/editor/data.py
--rw-r--r--   0 runner    (1001) docker     (116)     3725 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/editor/dispatch.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.675025 stopeight-0.3.14/stopeight/util/editor/modules/
--rw-r--r--   0 runner    (1001) docker     (116)      413 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/editor/modules/analyzer.py
--rw-r--r--   0 runner    (1001) docker     (116)     2645 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/editor/modules/file.py
--rw-r--r--   0 runner    (1001) docker     (116)     2008 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/editor/modules/file_wave.py
--rw-r--r--   0 runner    (1001) docker     (116)     5407 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/editor/modules/grapher.py
--rw-r--r--   0 runner    (1001) docker     (116)     2966 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/editor/modules/legacy.py
--rw-r--r--   0 runner    (1001) docker     (116)    13412 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/editor/scribble.py
--rw-r--r--   0 runner    (1001) docker     (116)     2442 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/editor/wave.py
--rw-r--r--   0 runner    (1001) docker     (116)     2365 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/parser.py
--rw-r--r--   0 runner    (1001) docker     (116)     3351 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/runnable.py
--rw-r--r--   0 runner    (1001) docker     (116)     1266 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/tableau_printer.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.675025 stopeight-0.3.14/stopeight/util/test/
--rw-r--r--   0 runner    (1001) docker     (116)     1405 2020-05-10 09:24:28.000000 stopeight-0.3.14/stopeight/util/test/test_util.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/stopeight-clibs/
--rw-r--r--   0 runner    (1001) docker     (116)      289 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (116)      393 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/Includes.cmake
--rw-r--r--   0 runner    (1001) docker     (116)      518 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/Versioning.cmake
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/stopeight-clibs/analyzer/
--rw-r--r--   0 runner    (1001) docker     (116)      573 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/analyzer/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (116)      106 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/analyzer/turns.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     6076 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/analyzer/turns.h
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/stopeight-clibs/analyzer-wrappers/
--rw-r--r--   0 runner    (1001) docker     (116)      369 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/analyzer-wrappers/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (116)      799 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/analyzer-wrappers/IFPyAnalyzer.cpp
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/better-example/
--rw-r--r--   0 runner    (1001) docker     (116)      591 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/better-example/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (116)      617 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/better-example/git.cc.in
--rw-r--r--   0 runner    (1001) docker     (116)      748 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/better-example/git.h
--rw-r--r--   0 runner    (1001) docker     (116)     8836 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/better-example/git_watcher.cmake
--rw-r--r--   0 runner    (1001) docker     (116)     8836 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/git_watcher.cmake
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.663025 stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/hello-world/
--rw-r--r--   0 runner    (1001) docker     (116)      529 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/hello-world/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (116)     8836 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/hello-world/git_watcher.cmake
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.667025 stopeight-0.3.14/stopeight-clibs/grapher/
--rw-r--r--   0 runner    (1001) docker     (116)      696 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/grapher/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (116)    17111 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/grapher/algo.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     3594 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/grapher/containers.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     1078 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/grapher/containers.h
--rw-r--r--   0 runner    (1001) docker     (116)     3638 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/grapher/grapher.cpp
--rw-r--r--   0 runner    (1001) docker     (116)      805 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/grapher/grapher_impl.h
--rw-r--r--   0 runner    (1001) docker     (116)     3138 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/grapher/iterators.h
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.667025 stopeight-0.3.14/stopeight-clibs/grapher/mac/
--rw-r--r--   0 runner    (1001) docker     (116)      446 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/grapher/mac/grapher.cpp
--rw-r--r--   0 runner    (1001) docker     (116)      109 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/grapher/main.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     1071 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/grapher/mean.cpp
--rw-r--r--   0 runner    (1001) docker     (116)      439 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/grapher/mean_impl.h
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.667025 stopeight-0.3.14/stopeight-clibs/grapher-wrappers/
--rw-r--r--   0 runner    (1001) docker     (116)      397 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/grapher-wrappers/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (116)     8432 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/grapher-wrappers/IFPyGrapher.cpp
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.651025 stopeight-0.3.14/stopeight-clibs/include/
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.667025 stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/
--rw-r--r--   0 runner    (1001) docker     (116)     2994 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/Matrix.h
--rw-r--r--   0 runner    (1001) docker     (116)     4672 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/algo.h
--rw-r--r--   0 runner    (1001) docker     (116)      960 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/analyzer.h
--rw-r--r--   0 runner    (1001) docker     (116)     4651 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/angle_functions.h
--rw-r--r--   0 runner    (1001) docker     (116)     1184 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/grapher.h
--rw-r--r--   0 runner    (1001) docker     (116)      737 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/mean.h
--rw-r--r--   0 runner    (1001) docker     (116)      603 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/preloaderif.h
--rw-r--r--   0 runner    (1001) docker     (116)     4923 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/shared_types.h
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.667025 stopeight-0.3.14/stopeight-clibs/legacy/
--rw-r--r--   0 runner    (1001) docker     (116)     1485 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.671025 stopeight-0.3.14/stopeight-clibs/legacy/include/
--rw-r--r--   0 runner    (1001) docker     (116)      664 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/analyzer.h
--rw-r--r--   0 runner    (1001) docker     (116)      732 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/areaanalyzer.h
--rw-r--r--   0 runner    (1001) docker     (116)      656 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/areacalculator.h
--rw-r--r--   0 runner    (1001) docker     (116)      640 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/areanormalizer.h
--rw-r--r--   0 runner    (1001) docker     (116)      535 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/calculator.h
--rw-r--r--   0 runner    (1001) docker     (116)      453 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/cliffs.h
--rw-r--r--   0 runner    (1001) docker     (116)      720 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/cliffsanalyzer.h
--rw-r--r--   0 runner    (1001) docker     (116)      487 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/cliffscalculator.h
--rw-r--r--   0 runner    (1001) docker     (116)      566 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/cliffsnormalizer.h
--rw-r--r--   0 runner    (1001) docker     (116)      580 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/corneranalyzer.h
--rw-r--r--   0 runner    (1001) docker     (116)      390 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/cornercalculator.h
--rw-r--r--   0 runner    (1001) docker     (116)      629 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/cornernormalizer.h
--rw-r--r--   0 runner    (1001) docker     (116)      577 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/corners.h
--rw-r--r--   0 runner    (1001) docker     (116)     1161 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/dpoint.h
--rw-r--r--   0 runner    (1001) docker     (116)     1366 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/editorbase.h
--rw-r--r--   0 runner    (1001) docker     (116)      570 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/editorcliffs.h
--rw-r--r--   0 runner    (1001) docker     (116)      810 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/editorinterface.h
--rw-r--r--   0 runner    (1001) docker     (116)      675 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/editorspirals.h
--rw-r--r--   0 runner    (1001) docker     (116)      616 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/error.h
--rw-r--r--   0 runner    (1001) docker     (116)      450 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/legacy_export.h
--rw-r--r--   0 runner    (1001) docker     (116)      848 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/legacy_global.h
--rw-r--r--   0 runner    (1001) docker     (116)     1371 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/listbase.h
--rw-r--r--   0 runner    (1001) docker     (116)      747 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/listcopyable.h
--rw-r--r--   0 runner    (1001) docker     (116)     1060 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/listrotator.h
--rw-r--r--   0 runner    (1001) docker     (116)      621 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/listswitchable.h
--rw-r--r--   0 runner    (1001) docker     (116)     1081 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/myreal.h
--rw-r--r--   0 runner    (1001) docker     (116)     1420 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/render.h
--rw-r--r--   0 runner    (1001) docker     (116)      655 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/spirals.h
--rw-r--r--   0 runner    (1001) docker     (116)      474 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/spiralsanalyzer.h
--rw-r--r--   0 runner    (1001) docker     (116)      396 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/spiralscalculator.h
--rw-r--r--   0 runner    (1001) docker     (116)      522 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/straightsanalyzer.h
--rw-r--r--   0 runner    (1001) docker     (116)      616 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/straightscalculator.h
--rw-r--r--   0 runner    (1001) docker     (116)      474 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/straightsnormalizer.h
--rw-r--r--   0 runner    (1001) docker     (116)      608 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/turnanalyzer.h
--rw-r--r--   0 runner    (1001) docker     (116)      655 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/turncalculator.h
--rw-r--r--   0 runner    (1001) docker     (116)      664 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/turnnormalizer.h
--rw-r--r--   0 runner    (1001) docker     (116)      561 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/include/turns.h
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.675025 stopeight-0.3.14/stopeight-clibs/legacy/src/
--rw-r--r--   0 runner    (1001) docker     (116)     2312 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/analyzer.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     6744 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/areaanalyzer.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     3307 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/areacalculator.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     3108 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/areanormalizer.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     2120 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/calculator.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     1287 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/cliffs.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     8475 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/cliffsanalyzer.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     2679 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/cliffscalculator.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     1500 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/cliffsnormalizer.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     1681 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/corneranalyzer.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     1224 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/cornercalculator.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     5271 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/cornernormalizer.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     1254 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/corners.cpp
--rw-r--r--   0 runner    (1001) docker     (116)      963 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/dpoint.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     4236 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/editorbase.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     6660 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/editorcliffs.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     1674 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/editorspirals.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     4697 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/listbase.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     3977 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/listcopyable.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     5839 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/listrotator.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     4584 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/listswitchable.cpp
--rw-r--r--   0 runner    (1001) docker     (116)      183 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/myreal.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     6866 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/render.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     4377 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/spirals.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     1088 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/spiralsanalyzer.cpp
--rw-r--r--   0 runner    (1001) docker     (116)      532 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/spiralscalculator.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     1413 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/straightsanalyzer.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     1613 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/straightscalculator.cpp
--rw-r--r--   0 runner    (1001) docker     (116)      763 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/straightsnormalizer.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     7469 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/turnanalyzer.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     2321 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/turncalculator.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     2369 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/turnnormalizer.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     1244 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy/src/turns.cpp
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.667025 stopeight-0.3.14/stopeight-clibs/legacy-wrappers/
--rw-r--r--   0 runner    (1001) docker     (116)     1339 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy-wrappers/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (116)     1379 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy-wrappers/IFPyFinders.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     1483 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy-wrappers/IFPyGetters.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     1402 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy-wrappers/IFPyShared.cpp
--rw-r--r--   0 runner    (1001) docker     (116)      728 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy-wrappers/IFPyShared.h
--rw-r--r--   0 runner    (1001) docker     (116)     4816 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy-wrappers/interfacepython.cpp
--rw-r--r--   0 runner    (1001) docker     (116)     2548 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/legacy-wrappers/interfacepython.h
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.675025 stopeight-0.3.14/stopeight-clibs/matrix/
--rw-r--r--   0 runner    (1001) docker     (116)      492 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/matrix/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (116)    12677 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/matrix/Matrix.cpp
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.675025 stopeight-0.3.14/stopeight-clibs/matrix-wrappers/
--rw-r--r--   0 runner    (1001) docker     (116)      364 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/matrix-wrappers/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (116)     4710 2020-05-10 09:24:31.000000 stopeight-0.3.14/stopeight-clibs/matrix-wrappers/IFPyMatrix.cpp
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2020-05-10 09:25:04.675025 stopeight-0.3.14/stopeight.egg-info/
--rw-r--r--   0 runner    (1001) docker     (116)     1211 2020-05-10 09:25:02.000000 stopeight-0.3.14/stopeight.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (116)     9693 2020-05-10 09:25:04.000000 stopeight-0.3.14/stopeight.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (116)        1 2020-05-10 09:25:02.000000 stopeight-0.3.14/stopeight.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (116)       83 2020-05-10 09:25:02.000000 stopeight-0.3.14/stopeight.egg-info/entry_points.txt
--rw-r--r--   0 runner    (1001) docker     (116)        1 2020-05-10 09:25:02.000000 stopeight-0.3.14/stopeight.egg-info/not-zip-safe
--rw-r--r--   0 runner    (1001) docker     (116)       23 2020-05-10 09:25:02.000000 stopeight-0.3.14/stopeight.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (116)       10 2020-05-10 09:25:02.000000 stopeight-0.3.14/stopeight.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.176959 stopeight-0.3.22/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.092959 stopeight-0.3.22/.github/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.100959 stopeight-0.3.22/.github/workflows/
+-rw-r--r--   0 runner    (1001) docker     (123)     3100 2023-04-26 14:10:32.000000 stopeight-0.3.22/.github/workflows/conda-build.yml
+-rw-r--r--   0 runner    (1001) docker     (123)      843 2023-04-26 14:10:32.000000 stopeight-0.3.22/.github/workflows/pypi-sdist.yml
+-rw-r--r--   0 runner    (1001) docker     (123)       17 2023-04-26 14:10:32.000000 stopeight-0.3.22/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (123)      109 2023-04-26 14:10:32.000000 stopeight-0.3.22/.gitmodules
+-rw-r--r--   0 runner    (1001) docker     (123)      553 2023-04-26 14:10:32.000000 stopeight-0.3.22/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    15220 2023-04-26 14:10:32.000000 stopeight-0.3.22/LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      920 2023-04-26 14:10:32.000000 stopeight-0.3.22/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     1208 2023-04-26 14:11:29.176959 stopeight-0.3.22/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)      186 2023-04-26 14:10:32.000000 stopeight-0.3.22/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)     5359 2023-04-26 14:10:32.000000 stopeight-0.3.22/cmake.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.104959 stopeight-0.3.22/doc/
+-rw-r--r--   0 runner    (1001) docker     (123)     5576 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/Makefile
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.108959 stopeight-0.3.22/doc/_extra/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_extra/.nojekyll
+-rw-r--r--   0 runner    (1001) docker     (123)       24 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_extra/robots.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.112959 stopeight-0.3.22/doc/_static/
+-rw-r--r--   0 runner    (1001) docker     (123)    10172 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_static/cliff.svg
+-rw-r--r--   0 runner    (1001) docker     (123)   235608 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_static/crab.png
+-rw-r--r--   0 runner    (1001) docker     (123)    13213 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_static/crest.svg
+-rw-r--r--   0 runner    (1001) docker     (123)    15246 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_static/crest_or_sinusoid.svg
+-rw-r--r--   0 runner    (1001) docker     (123)    28117 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_static/extraction_sequence.svg
+-rw-r--r--   0 runner    (1001) docker     (123)    26892 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_static/function_graph.svg
+-rw-r--r--   0 runner    (1001) docker     (123)    12623 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_static/sinus.svg
+-rw-r--r--   0 runner    (1001) docker     (123)    25550 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_static/text.svg
+-rw-r--r--   0 runner    (1001) docker     (123)   115146 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_static/vector_construction.svg
+-rw-r--r--   0 runner    (1001) docker     (123)    47143 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_static/vector_graph.svg
+-rw-r--r--   0 runner    (1001) docker     (123)    47729 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_static/vector_graph2.svg
+-rw-r--r--   0 runner    (1001) docker     (123)    49772 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_static/vector_graph3.svg
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.112959 stopeight-0.3.22/doc/_templates/
+-rw-r--r--   0 runner    (1001) docker     (123)      195 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/_templates/layout.html
+-rw-r--r--   0 runner    (1001) docker     (123)      549 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/analyzer.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      881 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/applications.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      667 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/build_latex.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     8365 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/conf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1751 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/dev_analyzer.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1162 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/dev_build.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1297 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/dev_comparator.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      777 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/dev_doc.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      469 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/dev_stroke-analyzer.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      667 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/index.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.116959 stopeight-0.3.22/doc/latex/
+-rw-r--r--   0 runner    (1001) docker     (123)     8945 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/latex/Antis.tex
+-rw-r--r--   0 runner    (1001) docker     (123)    29341 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/latex/Not_Used.tex
+-rw-r--r--   0 runner    (1001) docker     (123)     6640 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/latex/Simulation.tex
+-rw-r--r--   0 runner    (1001) docker     (123)     8627 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/latex/Spline_Axioms.tex
+-rw-r--r--   0 runner    (1001) docker     (123)     5489 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/latex/Stopeight.bib
+-rw-r--r--   0 runner    (1001) docker     (123)    24538 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/latex/Stopeight_Analyzer.tex
+-rw-r--r--   0 runner    (1001) docker     (123)    34304 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/latex/Stopeight_Comparator.tex
+-rw-r--r--   0 runner    (1001) docker     (123)    11878 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/latex/Stopeight_Grapher.tex
+-rw-r--r--   0 runner    (1001) docker     (123)     5102 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/make.bat
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.120959 stopeight-0.3.22/doc/mathematica/
+-rw-r--r--   0 runner    (1001) docker     (123)     4429 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/mathematica/Representation_Circles.m
+-rw-r--r--   0 runner    (1001) docker     (123)     2909 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/mathematica/Representation_Parallelogram.m
+-rw-r--r--   0 runner    (1001) docker     (123)     8393 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/mathematica/Spline.m
+-rw-r--r--   0 runner    (1001) docker     (123)    50428 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/mathematica/Spline_CharacteristicPolynomials.nb
+-rw-r--r--   0 runner    (1001) docker     (123)    39988 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/mathematica/Spline_EVConstraint.nb
+-rw-r--r--   0 runner    (1001) docker     (123)    50140 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/mathematica/Spline_Eigensystems.nb
+-rw-r--r--   0 runner    (1001) docker     (123)    33175 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/mathematica/Spline_Generative.nb
+-rw-r--r--   0 runner    (1001) docker     (123)    10607 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/mathematica/Spline_Pascal.nb
+-rw-r--r--   0 runner    (1001) docker     (123)    27081 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/mathematica/Spline_Representation.nb
+-rw-r--r--   0 runner    (1001) docker     (123)      846 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/mathematica/SubSpaces.m
+-rw-r--r--   0 runner    (1001) docker     (123)      580 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/run_comparator.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      405 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/run_editor.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      351 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/run_tests.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      642 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/sample-data.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/stopeight.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      590 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/theory.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2673 2023-04-26 14:10:32.000000 stopeight-0.3.22/doc/vector-graph.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      267 2023-04-26 14:10:32.000000 stopeight-0.3.22/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)      181 2023-04-26 14:10:32.000000 stopeight-0.3.22/requirements.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      685 2023-04-26 14:10:32.000000 stopeight-0.3.22/setup-dev.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1311 2023-04-26 14:11:29.176959 stopeight-0.3.22/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     3727 2023-04-26 14:10:32.000000 stopeight-0.3.22/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.096959 stopeight-0.3.22/stopeight/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.168959 stopeight-0.3.22/stopeight/comparator/
+-rw-r--r--   0 runner    (1001) docker     (123)     6841 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/comparator/lineMatch.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1641 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/comparator/matrix.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1390 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/comparator/matrixTools.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1373 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/comparator/matrixTools_new.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2616 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/comparator/shapeMatch.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1992 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/comparator/shapeMatchSubSection.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1918 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/comparator/vectorTools.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.168959 stopeight-0.3.22/stopeight/logging/
+-rw-r--r--   0 runner    (1001) docker     (123)     2179 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/logging/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.168959 stopeight-0.3.22/stopeight/multiprocessing/
+-rw-r--r--   0 runner    (1001) docker     (123)     4459 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/multiprocessing/pooling.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.168959 stopeight-0.3.22/stopeight/test/
+-rw-r--r--   0 runner    (1001) docker     (123)      397 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/test/test_analyzer.py
+-rw-r--r--   0 runner    (1001) docker     (123)      666 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/test/test_comparator.py
+-rw-r--r--   0 runner    (1001) docker     (123)      883 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/test/test_grapher.py
+-rw-r--r--   0 runner    (1001) docker     (123)      781 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/test/test_legacy.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.172959 stopeight-0.3.22/stopeight/util/
+-rw-r--r--   0 runner    (1001) docker     (123)     4809 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/SVG.py
+-rw-r--r--   0 runner    (1001) docker     (123)      327 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/SVGViewer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1244 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/TCT_printer.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.172959 stopeight-0.3.22/stopeight/util/editor/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/editor/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      946 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/editor/callwindow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9208 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/editor/command.py
+-rw-r--r--   0 runner    (1001) docker     (123)      763 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/editor/data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3471 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/editor/dispatch.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.176959 stopeight-0.3.22/stopeight/util/editor/modules/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/editor/modules/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      413 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/editor/modules/analyzer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2663 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/editor/modules/file.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2055 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/editor/modules/file_wave.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5407 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/editor/modules/grapher.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3316 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/editor/modules/legacy.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1127 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/editor/runnable.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13296 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/editor/scribble.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2460 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/editor/wave.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2365 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/parser.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1945 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/singleton.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1266 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/tableau_printer.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.176959 stopeight-0.3.22/stopeight/util/test/
+-rw-r--r--   0 runner    (1001) docker     (123)     1455 2023-04-26 14:10:32.000000 stopeight-0.3.22/stopeight/util/test/test_util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.120959 stopeight-0.3.22/stopeight-clibs/
+-rw-r--r--   0 runner    (1001) docker     (123)      240 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      393 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/Includes.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      321 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/Package.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/Versioning.cmake
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.124959 stopeight-0.3.22/stopeight-clibs/analyzer/
+-rw-r--r--   0 runner    (1001) docker     (123)      745 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/analyzer/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.124959 stopeight-0.3.22/stopeight-clibs/analyzer/python/
+-rw-r--r--   0 runner    (1001) docker     (123)      486 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/analyzer/python/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      799 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/analyzer/python/IFPyAnalyzer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      106 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/analyzer/turns.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6076 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/analyzer/turns.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.124959 stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.124959 stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/better-example/
+-rw-r--r--   0 runner    (1001) docker     (123)      591 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/better-example/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      617 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/better-example/git.cc.in
+-rw-r--r--   0 runner    (1001) docker     (123)      748 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/better-example/git.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8836 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/better-example/git_watcher.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     8836 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/git_watcher.cmake
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.124959 stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/hello-world/
+-rw-r--r--   0 runner    (1001) docker     (123)      529 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/hello-world/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     8836 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/hello-world/git_watcher.cmake
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.128959 stopeight-0.3.22/stopeight-clibs/grapher/
+-rw-r--r--   0 runner    (1001) docker     (123)      903 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/grapher/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    12542 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/grapher/algo.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3594 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/grapher/containers.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1078 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/grapher/containers.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3640 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/grapher/grapher.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      805 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/grapher/grapher_impl.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3138 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/grapher/iterators.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.128959 stopeight-0.3.22/stopeight-clibs/grapher/mac/
+-rw-r--r--   0 runner    (1001) docker     (123)      446 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/grapher/mac/grapher.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      109 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/grapher/main.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1073 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/grapher/mean.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      439 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/grapher/mean_impl.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.128959 stopeight-0.3.22/stopeight-clibs/grapher/python/
+-rw-r--r--   0 runner    (1001) docker     (123)      616 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/grapher/python/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3874 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/grapher/python/IFPyGrapher.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.096959 stopeight-0.3.22/stopeight-clibs/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.132959 stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/
+-rw-r--r--   0 runner    (1001) docker     (123)     2994 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/Matrix.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3060 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/algo.h
+-rw-r--r--   0 runner    (1001) docker     (123)      960 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/analyzer.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4651 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/angle_functions.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1184 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/grapher.h
+-rw-r--r--   0 runner    (1001) docker     (123)      737 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/mean.h
+-rw-r--r--   0 runner    (1001) docker     (123)      603 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/preloaderif.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4923 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/shared_types.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.132959 stopeight-0.3.22/stopeight-clibs/legacy/
+-rw-r--r--   0 runner    (1001) docker     (123)     1656 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.140959 stopeight-0.3.22/stopeight-clibs/legacy/include/
+-rw-r--r--   0 runner    (1001) docker     (123)      949 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/analyzer.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1165 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/areaanalyzer.h
+-rw-r--r--   0 runner    (1001) docker     (123)      956 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/areacalculator.h
+-rw-r--r--   0 runner    (1001) docker     (123)      965 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/areanormalizer.h
+-rw-r--r--   0 runner    (1001) docker     (123)      365 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/calculator.h
+-rw-r--r--   0 runner    (1001) docker     (123)      562 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/cliffs.h
+-rw-r--r--   0 runner    (1001) docker     (123)      931 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/cliffsanalyzer.h
+-rw-r--r--   0 runner    (1001) docker     (123)      493 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/cliffscalculator.h
+-rw-r--r--   0 runner    (1001) docker     (123)      698 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/cliffsnormalizer.h
+-rw-r--r--   0 runner    (1001) docker     (123)      692 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/corneranalyzer.h
+-rw-r--r--   0 runner    (1001) docker     (123)      357 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/cornercalculator.h
+-rw-r--r--   0 runner    (1001) docker     (123)      929 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/cornernormalizer.h
+-rw-r--r--   0 runner    (1001) docker     (123)      770 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/corners.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1161 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/dpoint.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1353 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/editorbase.h
+-rw-r--r--   0 runner    (1001) docker     (123)      630 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/editorcliffs.h
+-rw-r--r--   0 runner    (1001) docker     (123)      849 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/editorinterface.h
+-rw-r--r--   0 runner    (1001) docker     (123)      707 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/editorspirals.h
+-rw-r--r--   0 runner    (1001) docker     (123)      616 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/error.h
+-rw-r--r--   0 runner    (1001) docker     (123)      450 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/legacy_export.h
+-rw-r--r--   0 runner    (1001) docker     (123)      848 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/legacy_global.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1558 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/listbase.h
+-rw-r--r--   0 runner    (1001) docker     (123)      612 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/listcopyable.h
+-rw-r--r--   0 runner    (1001) docker     (123)      971 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/listrotator.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2006 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/listswitchable.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1081 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/myreal.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1420 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/render.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1004 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/spirals.h
+-rw-r--r--   0 runner    (1001) docker     (123)      527 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/spiralsanalyzer.h
+-rw-r--r--   0 runner    (1001) docker     (123)      361 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/spiralscalculator.h
+-rw-r--r--   0 runner    (1001) docker     (123)      439 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/straightsanalyzer.h
+-rw-r--r--   0 runner    (1001) docker     (123)      447 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/straightscalculator.h
+-rw-r--r--   0 runner    (1001) docker     (123)      385 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/straightsnormalizer.h
+-rw-r--r--   0 runner    (1001) docker     (123)      610 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/turnanalyzer.h
+-rw-r--r--   0 runner    (1001) docker     (123)      955 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/turncalculator.h
+-rw-r--r--   0 runner    (1001) docker     (123)      364 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/turnnormalizer.h
+-rw-r--r--   0 runner    (1001) docker     (123)      482 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/include/turns.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.140959 stopeight-0.3.22/stopeight-clibs/legacy/python/
+-rw-r--r--   0 runner    (1001) docker     (123)     1782 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/python/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1290 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/python/IFPyFinders.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1799 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/python/IFPyGetters.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3116 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/python/IFPyShared.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      813 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/python/IFPyShared.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4773 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/python/interfacepython.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2556 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/python/interfacepython.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.148959 stopeight-0.3.22/stopeight-clibs/legacy/src/
+-rw-r--r--   0 runner    (1001) docker     (123)     1756 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/analyzer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6769 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/areaanalyzer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3239 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/areacalculator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2855 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/areanormalizer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      134 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/calculator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1296 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/cliffs.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     7452 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/cliffsanalyzer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2332 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/cliffscalculator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      906 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/cliffsnormalizer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1252 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/corneranalyzer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      139 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/cornercalculator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4699 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/cornernormalizer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      895 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/corners.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      963 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/dpoint.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4351 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/editorbase.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6470 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/editorcliffs.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1402 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/editorspirals.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4224 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/listbase.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1489 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/listcopyable.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4235 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/listrotator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3786 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/listswitchable.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      183 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/myreal.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6866 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/render.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4086 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/spirals.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      873 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/spiralsanalyzer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      141 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/spiralscalculator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      826 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/straightsanalyzer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      618 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/straightscalculator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      141 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/straightsnormalizer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6814 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/turnanalyzer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3174 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/turncalculator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      485 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/turnnormalizer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      835 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/legacy/src/turns.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.148959 stopeight-0.3.22/stopeight-clibs/matrix/
+-rw-r--r--   0 runner    (1001) docker     (123)      699 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/matrix/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    12842 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/matrix/Matrix.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.148959 stopeight-0.3.22/stopeight-clibs/matrix/python/
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/matrix/python/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4710 2023-04-26 14:10:33.000000 stopeight-0.3.22/stopeight-clibs/matrix/python/IFPyMatrix.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.148959 stopeight-0.3.22/stopeight-clibs/pybind11/
+-rw-r--r--   0 runner    (1001) docker     (123)    11983 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.096959 stopeight-0.3.22/stopeight-clibs/pybind11/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.152959 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/
+-rw-r--r--   0 runner    (1001) docker     (123)    23959 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/attr.h
+-rw-r--r--   0 runner    (1001) docker     (123)     7069 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/buffer_info.h
+-rw-r--r--   0 runner    (1001) docker     (123)    65942 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/cast.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8458 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/chrono.h
+-rw-r--r--   0 runner    (1001) docker     (123)      120 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/common.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2096 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/complex.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.156959 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/detail/
+-rw-r--r--   0 runner    (1001) docker     (123)    28518 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/detail/class.h
+-rw-r--r--   0 runner    (1001) docker     (123)    53288 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/detail/common.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5962 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/detail/descr.h
+-rw-r--r--   0 runner    (1001) docker     (123)    17859 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/detail/init.h
+-rw-r--r--   0 runner    (1001) docker     (123)    28076 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/detail/internals.h
+-rw-r--r--   0 runner    (1001) docker     (123)    42720 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/detail/type_caster_base.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1625 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/detail/typeid.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.156959 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/eigen/
+-rw-r--r--   0 runner    (1001) docker     (123)    31450 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/eigen/matrix.h
+-rw-r--r--   0 runner    (1001) docker     (123)    18140 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/eigen/tensor.h
+-rw-r--r--   0 runner    (1001) docker     (123)      316 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/eigen.h
+-rw-r--r--   0 runner    (1001) docker     (123)    13459 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/embed.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4731 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/eval.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5002 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/functional.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8262 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/gil.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8862 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/iostream.h
+-rw-r--r--   0 runner    (1001) docker     (123)    79416 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/numpy.h
+-rw-r--r--   0 runner    (1001) docker     (123)     9103 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/operators.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2734 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/options.h
+-rw-r--r--   0 runner    (1001) docker     (123)   126420 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/pybind11.h
+-rw-r--r--   0 runner    (1001) docker     (123)    94641 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/pytypes.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.156959 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/stl/
+-rw-r--r--   0 runner    (1001) docker     (123)     4185 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/stl/filesystem.h
+-rw-r--r--   0 runner    (1001) docker     (123)    15399 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/stl.h
+-rw-r--r--   0 runner    (1001) docker     (123)    29824 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/stl_bind.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.156959 stopeight-0.3.22/stopeight-clibs/pybind11/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)    21709 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tests/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.156959 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/
+-rw-r--r--   0 runner    (1001) docker     (123)     2639 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.156959 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/installed_embed/
+-rw-r--r--   0 runner    (1001) docker     (123)     1171 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/installed_embed/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.160959 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/installed_function/
+-rw-r--r--   0 runner    (1001) docker     (123)     1293 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/installed_function/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.160959 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/installed_target/
+-rw-r--r--   0 runner    (1001) docker     (123)     1685 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/installed_target/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.160959 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/subdirectory_embed/
+-rw-r--r--   0 runner    (1001) docker     (123)     1353 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.160959 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/subdirectory_function/
+-rw-r--r--   0 runner    (1001) docker     (123)     1163 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/subdirectory_function/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.160959 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/subdirectory_target/
+-rw-r--r--   0 runner    (1001) docker     (123)     1368 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/subdirectory_target/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.160959 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_embed/
+-rw-r--r--   0 runner    (1001) docker     (123)     1798 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_embed/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.164959 stopeight-0.3.22/stopeight-clibs/pybind11/tools/
+-rw-r--r--   0 runner    (1001) docker     (123)     2449 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tools/FindCatch.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     3105 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tools/FindEigen3.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)    11190 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tools/FindPythonLibsNew.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      817 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tools/JoinPaths.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)    14033 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tools/pybind11Common.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     8960 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tools/pybind11NewTools.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     8361 2023-04-26 14:10:35.000000 stopeight-0.3.22/stopeight-clibs/pybind11/tools/pybind11Tools.cmake
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-26 14:11:29.164959 stopeight-0.3.22/stopeight.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     1208 2023-04-26 14:11:29.000000 stopeight-0.3.22/stopeight.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    10977 2023-04-26 14:11:29.000000 stopeight-0.3.22/stopeight.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-26 14:11:29.000000 stopeight-0.3.22/stopeight.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       69 2023-04-26 14:11:29.000000 stopeight-0.3.22/stopeight.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-26 14:11:28.000000 stopeight-0.3.22/stopeight.egg-info/not-zip-safe
+-rw-r--r--   0 runner    (1001) docker     (123)       25 2023-04-26 14:11:29.000000 stopeight-0.3.22/stopeight.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       10 2023-04-26 14:11:29.000000 stopeight-0.3.22/stopeight.egg-info/top_level.txt
```

### Comparing `stopeight-0.3.14/LICENSE.txt` & `stopeight-0.3.22/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/MANIFEST.in` & `stopeight-0.3.22/MANIFEST.in`

 * *Files 21% similar despite different names*

```diff
@@ -1,24 +1,22 @@
 #sdist package descriptor
 include README.md LICENSE.txt
-#python.py
-include python.py
-#cmake.py
+include cmake.py
 global-include CMakeLists.txt *.cmake
-recursive-include pybind11/include *.h
+recursive-include stopeight-clibs/pybind11/include *.h
 include stopeight-clibs/cmake-git-version-tracking/git_watcher.cmake
 include stopeight-clibs/cmake-git-version-tracking/better-example/git.cc.in
 include stopeight-clibs/cmake-git-version-tracking/better-example/git.h
 #shared
 recursive-include stopeight-clibs/include *.h *.cpp
 #matrix
 recursive-include stopeight-clibs/matrix *.h *.cpp
-recursive-include stopeight-clibs/matrix-wrappers *.h *.cpp
+recursive-include stopeight-clibs/matrix/python *.h *.cpp
 #grapher
 recursive-include stopeight-clibs/grapher *.h *.cpp
-recursive-include stopeight-clibs/grapher-wrappers *.h *.cpp
+recursive-include stopeight-clibs/grapher/python *.h *.cpp
 #analyzer
 recursive-include stopeight-clibs/analyzer *.h *.cpp
-recursive-include stopeight-clibs/analyzer-wrappers *.h *.cpp
+recursive-include stopeight-clibs/analyzer/python *.h *.cpp
 #legacy
 recursive-include stopeight-clibs/legacy *.h *.cpp
-recursive-include stopeight-clibs/legacy-wrappers *.h *.cpp
+recursive-include stopeight-clibs/legacy/python *.h *.cpp
```

### Comparing `stopeight-0.3.14/PKG-INFO` & `stopeight-0.3.22/PKG-INFO`

 * *Files 10% similar despite different names*

```diff
@@ -1,24 +1,25 @@
-Metadata-Version: 1.2
+Metadata-Version: 2.1
 Name: stopeight
-Version: 0.3.14
+Version: 0.3.22
 Summary: stopeight: Comparing sequences of points in 2 dimensions
 Home-page: https://github.com/specpose/stopeight
 Author: Fassio Blatter
 Author-email: fassio@specpose.com
 License: GNU General Public License, version 2
 Project-URL: Documentation, https://specpose.github.io/stopeight
-Description: stopeight: Comparing sequences of points in 2 dimensions by visually overlapping them using matrix transformations (translation, scaling and rotation) and getting a boolean result.
 Keywords: signal-analysis time-series pen-stroke
-Platform: UNKNOWN
 Classifier: Development Status :: 3 - Alpha
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Science/Research
 Classifier: Topic :: Scientific/Engineering
 Classifier: Topic :: Scientific/Engineering :: Visualization
 Classifier: Topic :: Scientific/Engineering :: Information Analysis
 Classifier: License :: OSI Approved :: GNU General Public License v2 (GPLv2)
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3 :: Only
-Classifier: Programming Language :: Python :: 3.8
-Requires-Python: >=3.5
+Classifier: Programming Language :: Python :: 3.10
+Requires-Python: >=3.7
+License-File: LICENSE.txt
+
+stopeight: Comparing sequences of points in 2 dimensions by visually overlapping them using matrix transformations (translation, scaling and rotation) and getting a boolean result.
```

### Comparing `stopeight-0.3.14/doc/Makefile` & `stopeight-0.3.22/doc/Makefile`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/_static/cliff.svg` & `stopeight-0.3.22/doc/_static/cliff.svg`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/_static/crab.png` & `stopeight-0.3.22/doc/_static/crab.png`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/_static/crest.svg` & `stopeight-0.3.22/doc/_static/crest.svg`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/_static/crest_or_sinusoid.svg` & `stopeight-0.3.22/doc/_static/crest_or_sinusoid.svg`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/_static/extraction_sequence.svg` & `stopeight-0.3.22/doc/_static/extraction_sequence.svg`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/_static/function_graph.svg` & `stopeight-0.3.22/doc/_static/function_graph.svg`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/_static/sinus.svg` & `stopeight-0.3.22/doc/_static/sinus.svg`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/_static/text.svg` & `stopeight-0.3.22/doc/_static/text.svg`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/_static/vector_construction.svg` & `stopeight-0.3.22/doc/_static/vector_construction.svg`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/_static/vector_graph.svg` & `stopeight-0.3.22/doc/_static/vector_graph.svg`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/_static/vector_graph2.svg` & `stopeight-0.3.22/doc/_static/vector_graph2.svg`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/_static/vector_graph3.svg` & `stopeight-0.3.22/doc/_static/vector_graph3.svg`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/analyzer.txt` & `stopeight-0.3.22/doc/analyzer.txt`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/applications.txt` & `stopeight-0.3.22/doc/applications.txt`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/build_latex.txt` & `stopeight-0.3.22/doc/build_latex.txt`

 * *Files 18% similar despite different names*

```diff
@@ -5,25 +5,21 @@
 
 The directory for mathematical definitions (.tex) and bibliography (.bib) is::
 
     $ cd /path/to/where/stopeight/doc/latex
 
 Install from the universe repository (same as :doc:`dev_doc`)::
 
-    $ sudo apt-get install texlive texlive-latex-extra
-
-Install from the universe repository::
-
-    $ sudo apt-get install texlive-bibtex-extra
+    $ sudo apt-get install texlive
 
 First run pdflatex to create the bcf file. If there is an aux file already, delete it::
 
     $ rm ./filename.aux
     $ pdflatex ./filename.tex
 
 Then run bibtex on the bcf file (Don't add the file extension)::
 
-    $ bibtex ./filename
+    $ bibtex ./filename.aux
 
-Create the PDF::
+Create the PDF (You may have to run twice)::
 
     $ pdflatex ./filename.tex
```

### Comparing `stopeight-0.3.14/doc/conf.py` & `stopeight-0.3.22/doc/conf.py`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/dev_analyzer.txt` & `stopeight-0.3.22/doc/dev_analyzer.txt`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/dev_build.txt` & `stopeight-0.3.22/doc/dev_build.txt`

 * *Files 22% similar despite different names*

```diff
@@ -1,54 +1,43 @@
 Stopeight
 =========
 
-Instructions have been tested on Ubuntu 20.04 Focal Fossa.
+Instructions have been tested on Ubuntu 22.04 Focal Fossa.
 
 Installation
 ------------
 
 Minimal Requirements (main repository)::
 
-    $ sudo apt-get install git build-essential python3-dev cmake
+    $ sudo apt-get install git build-essential python3-dev python3-venv cmake
 
 To run the editor, legacy tests and install to a separate environment (universe repository)::
 
-    $ sudo apt-get install qtbase5-dev python3-venv
+    $ sudo apt-get install qtbase5-dev
+
+Create a virtual environment::
+
+    $ python3 -m venv ~/stopeight-test
+    $ source ~/stopeight-test/bin/activate
 
 The stopeight repository contains stopeight-clibs (Github)::
 
     $ git clone --recurse-submodules https://github.com/specpose/stopeight.git
     $ cd /path/to/where/stopeight
+    $ git submodule update --init --recursive
 
-Build and install stopeight-clibs. (Alternative: Uncomment stopeight-clibs in CMakeLists.txt)::
-    $ cd stopeight-clibs
-    $ mkdir build
-    $ cd build
-    $ cmake ../
-    $ make
-    $ sudo make install
-    $ sudo ldconfig
-    $ cd ../../
-
-Build and install stopeight (easy_install)::
-
-    $ python -m venv ~/stopeight-test
-    $ source ~/stopeight-test/bin/activate
-    
-Run this before setup. easy_install may provide broken packages::
-
-    $ python -m pip install setuptools PyQt5
+Uncomment additional modules in (stopeight/stopeight/util/editor/dispatch.py).
     
-And finally. This is using easy_install, not pip::
+And finally::
 
-    $ python setup.py develop
+    $ python setup-dev.py install
 
 Try the editor for a start. PyQt5 may segfault when running from inside a snap or an IDE-bound shell::
 
-    $ ~/stopeight-test/bin/python -m stopeight.util.editor.dispatch
+    $ python -m stopeight.util.editor.dispatch
 
-Uninstall::
+Uninstall from another shell::
 
-    $ ~/stopeight-test/bin/python setup-easydev.py develop --uninstall
+    $ ~/stopeight-test/bin/pip uninstall stopeight
     $ rm -R ~/stopeight-test
     $ rm -Rf /path/to/where/stopeight
     $ rm -R ~/.stopeight
```

### Comparing `stopeight-0.3.14/doc/dev_comparator.txt` & `stopeight-0.3.22/doc/dev_comparator.txt`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/dev_doc.txt` & `stopeight-0.3.22/doc/dev_doc.txt`

 * *Files 11% similar despite different names*

```diff
@@ -1,17 +1,19 @@
 GitHub & Sphinx
 ===============
 
+Please follow instructions under :doc:`dev_build` first.
+
 Get python sphinx / dvisvgm on ubuntu (main repository)::
 
-    $ sudo apt-get install make python3-sphinx python3-alabaster
+    $ sudo apt-get install make python3-sphinx texlive
     
-Theory part of the docs needs latex (universe repository)::
+Theory part of the docs needs some latex fonts (universe repository)::
 
-    $ sudo apt-get install texlive texlive-latex-extra
+    $ sudo apt-get install texlive-latex-extra
 
 In order to rebuild the docs, do::
 
     $ cd doc/
     $ rm -R ./_build
     $ make html
     $ cd ../
```

### Comparing `stopeight-0.3.14/doc/index.txt` & `stopeight-0.3.22/doc/index.txt`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/latex/Antis.tex` & `stopeight-0.3.22/doc/latex/Antis.tex`

 * *Files 16% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 \documentclass{report}
 \usepackage{amsfonts}
 \usepackage{amsmath}
 \usepackage{amssymb}
-\usepackage{hyperref}
 
 \iffalse
 \usepackage{biblatex}
 \addbibresource{Stopeight.bib}
 \fi
 \usepackage{natbib}
 
@@ -15,26 +14,34 @@
 
 \begin{document}
 \title{Antis}
 \author{Fassio Blatter}
 \maketitle
 
 \chapter{Introduction}
-Geometric overlay comparison works for unseparated signals, but it is only of limited use, because it is inaccurate. The goal of separation is to find impulses or notes as they may be referred to in a musical context. It is important to note that the individual pulses have a causal relationship that connects them. Most oscillations are subject to amplitude and/or frequency-modulation, but they are usually repetitive, so they can be removed by statistical means. Truly random/stochastic signals on the other hand can not be filtered.\\\\
-In signal analysis, there is the notion of source separation vs. spectral separation of pulses. The method of separation referred to in this text is meant to work $blind$ in a scenario where no prior knowledge of the likelyhood of occurence of waveforms is made. If prior statistical data, event metadata or multiple channels (stereo, etc.) are available, some of the requirements mentioned may be relaxed.
+\section{Specific}
+Notation: Below I refer to representation as training data for machine-learning, not the representations from ~\cite[Spline\_Axioms.tex]{Axioms}.\\\\
+Sound source separation is a $preliminary$ for $rare sound detection$. It can be argued, that rare sound detection can be performed without separation. but in most cases it also depends on it.\\\\
+I have made a few Mathematica scripts (tbd.) based on the theory that the full $time domain$, or if assumptions are made on the waveform, even the $sequence$ of events can be $discarded$ in the machine-learning representations for accoustic scene classification.\\
+For short frames or time bins, a $statistical representation$ should be enough to correctly identify the scene.\\
+I have also adjusted the representations, so that $energy$ scalograms are applied $pulse$-length or $waveform$-length wise. This can enhance the representation for machine learning.\\
+Furthermore I have used derivatives of the time signal and applied similar signal processing methods to them. For visualisation I have added them to the original scalogram. The use of $derivatives$ is very much $distorted$ if the sound is not separated.
+\section{Context}
+Geometric overlay comparison as in Stopeight Comparator works for unseparated signals, but it is only of limited use, because it is inaccurate. The goal of separation is to clean up the signal, so that impulses or notes as they may be referred to in a musical context can be found. It is important to note that the individual pulses have a causal relationship that connects them. Most oscillations are subject to amplitude and/or frequency-modulation, but they are usually repetitive, so they can be removed by statistical means. Truly random/stochastic signals on the other hand can not be filtered.\\\\
+In signal analysis, there is the notion of source separation vs. spectral separation of pulses. The method of testing a signal for spectral separation referred to in this text is meant to work $blind$ in a scenario where no prior knowledge of the likelyhood of occurence of waveforms is made.
 
 \subsection{Pulse}
 A symmetric pulse has two half pulses with the same wavelength/amplitude correlation.
 
 \subsection{Impulses}
 Impulses are consecutive half-pulses of variable wavelengths which originate from the same source and are separated from other overlaping impulses.
 
 \chapter{Source Separation}
 Stopeight Comparator may provide a means of either finding exact frames (of length pulse or impulse?) in the original signal $s(t)$ (See Grapher), or in the signal as in parametric curve differences.\\\\
-Also Vector Graph manipulations such as finding/counting intersections and setting oriented section type occurence limitations (ex. Spiral $\Rightarrow$ scale) could yield interesting results.
+Also Vector Graph manipulations ~\cite{Analyzer} such as finding/counting intersections and setting oriented $ori$ section type occurence limitations (ex. Spiral $\Rightarrow$ scale) could yield interesting results.
 
 \subsection{Signs}
 The difference of the signs over an interval.
 \begin{align}
 dsi(a,b) = card(\mu_{+}\subseteq [a,b])-card(\mu_{-} \subseteq [a,b])\\
 ori(a,b) = \frac{dsi(a,b)}{\lvert dsi(a,b) \rvert}
 \end{align}
@@ -50,46 +57,51 @@
 
 \chapter{Spectral Separation}
 \section{Indicator}
 Every zero crossing $t_{m}$ of the 2nd derivative
 \begin{equation}
 \{t_{m}\}_{m \in \mathbb{Z} , f''(t_{m})=0}
 \end{equation}
+Note: I have mentioned the derivatives of the time signal as well in the introduction, effectively giving different bounds f''' for the signal f' and the bounds of the bounds f'''' for f''.\\\\
 For all the Intervals $t_{m}-t_{m-1}=T$ of a signal $f: \mathbb{R} \rightarrow \mathbb{R}$
 \begin{equation}
 \eta(T)=\{t \in \mathbb{R}; t_{m} - t_{m-1}=T \vert f''(t_{m})=0, f''(t_{m-1})=0, t \le t_{m}, t \ge t_{m-1} \}
 \end{equation}
 Note: $\eta$ is a Lebesgue.\\\\
 For all the positive and negative function values $f(t)$ respectively
 \begin{align}
 \eta_{+}(T)=\{{\eta \vert f(t) \ge 0}\}\\
 \eta_{-}(T)=\{{\eta \vert f(t) \le 0}\}
 \end{align}
-Parseval's theorem
+In Parseval's theorem
 \begin{equation}
-\int\limits_{-\infty}^{\infty} \vert f(t) \vert ^2 \mathrm{d} t = 1/2\pi * \int\limits_{-\infty}^{\infty} \vert \hat{f}(1/T) \vert ^2  \mathrm{d} T
+\underbrace{\int\limits_{-\infty}^{\infty} \vert f(t) \vert ^2 \mathrm{d} t}_{\text{Signal Energy}} = 1/2\pi * \int\limits_{-\infty}^{\infty} \vert \hat{f}(1/T) \vert ^2  \mathrm{d} T
 \end{equation}
-Can be interpreted for signed function values as
+The signal energy can be split into positive and negative parts
+\begin{align}
+\sqrt{\underbrace{\int \int f(t)*\mathrm{e}^{\pi/2} \mathrm{d} t \mathrm{d} \eta_{+}}_{z_{1}}*\underbrace{\int \int f(t) *\mathrm{e}^{-\pi/2}\mathrm{d} t \mathrm{d} \eta_{-} }_{z_{2}} } ^2 = - \int\limits_{-\infty}^{\infty} \vert f(t) \vert ^2 \mathrm{d} t 
+\end{align}
+Note: Because the complex angle is the same within each integral, the complex radius is preserved. The Euclidean norm $(\mathbb{C},\norm{\cdot}_2)$ equals the taxicab norm $(\mathbb{C},\norm{\cdot}_1)$ in this special case.\\\\
+Because periods $T$ in a signal are not continuous, Dirac notation has to be used
 \begin{equation}
-\int\limits_{-\infty}^{\infty} (\underbrace{\int\limits_{-\infty}^{\infty} \delta (U - T) \mathrm{d} U}_{1} * (\int\int f(t) \mathrm{d} t \underbrace{\mathrm{d} \eta}_{\text{depends on T}}) )\mathrm{d} T = 1/2\pi * \int\limits_{-\infty}^{\infty} \hat{f}(1/T) \mathrm{d} T
+\int\limits_{-\infty}^{\infty} (\underbrace{\int\limits_{-\infty}^{\infty} \delta (U - T) \mathrm{d} U}_{1} * \sqrt{ \underbrace{z_{1}*z_{2}}_{\text{$\eta$ depends on T}} }^2 )\mathrm{d} T = -1/2\pi * \int\limits_{-\infty}^{\infty} \vert\hat{f}(1/T)\vert ^2 \mathrm{d} T
 \end{equation}
 Note: Major $U$ is a unique period, not a point in time. $U$ is not continuous, $\delta$ is the discrete Dirac Delta.\\\\
-The convolution of the signal with a periodicity T is equal the distributed energy of two semi-pulse functions of the same periodicity. The negative part $\eta_{-}$ is interpreted as a purely imaginary complex number $z_{2}$.
-\begin{equation}
-\int\limits_{-\infty}^{\infty}(\int\limits_{-\infty}^{\infty} \delta (U - T) \mathrm{d} U * (\underbrace{\int \int f(t) \mathrm{d} t \mathrm{d} \eta_{+}}_{z_{1}} * \underbrace{\mathrm{i} \int \int f(t) \mathrm{d} t \mathrm{d} \eta_{-}}_{z_{2}}))  \mathrm{d} T = 1/2\pi * \int\limits_{-\infty}^{\infty} ( \int\limits_{-\infty}^{\infty}  f(t) * (cos(t/T)+\mathrm{i} sin(t/T)) \mathrm{d} t ) \mathrm{d} T
-\end{equation}
-Note: If the angle $\phi$ between two complex numbers $z_{1},z_{2}$ is $\pm\frac{pi}{2}$, their complex multiple $z_{1}*z_{2}$ is equal the real $\lvert z_{1}\rvert*\lvert z_{2}\rvert$. If $x_{1}=y_{2}$, this simplifies to $\lvert x_{1} \rvert ^2$, which is what we have noted above (Parseval Theorem) for the real function $f(t)$ .\\\\
+The convolution of the signal with a periodicity T is equal the distributed energy of two semi-pulse functions of the same periodicity. Thus giving
+\begin{align*}
+\int\limits_{-\infty}^{\infty}(\int\limits_{-\infty}^{\infty} \delta (U - T) \mathrm{d} U * \int \int f(t) \mathrm{d} t \mathrm{d} \eta_{+}*\int \int f(t) \mathrm{d} t \mathrm{d} \eta_{-} ) \mathrm{d} T \\= 1/2\pi * \int\limits_{-\infty}^{\infty} \vert \int\limits_{-\infty}^{\infty}  f(t) * (cos(-t/T)+\mathrm{i} sin(-t/T)) \mathrm{d} t \vert^2 \mathrm{d} T
+\end{align*}
 This equation holds for every signal with frequency components separated in the time domain and symmetric in $mod(n/2)=0$ equal length parts. If this is not the case, we have either:\\
 1. Longer wavelength pulses overlapping the frequency component, which results in a amplitude modulation of the combined signal.\\
 2. Shorter wavelength pulses intersecting the segments of the frequency component, which results in frequency modulation of the combined signal.\\
 3. Non-symmetric waveforms and/or different length half-pulses, which can not be removed with this procedure. See Source Separation for further discussion of such signals.\\\\
 (A longer wavelength, undetected harmonic can be excluded in this scenario since source separated harmonics are symmetric pulses of integer multiples of the wavelength and we imply that the shortest $symmetric$ pulse is found beforehand in the removal procedure below, i.e. the higher harmonics are $not symmetric$ because of criteria 1)\\\\
 Conclusion: This method provides an indication for the spectral separation of the signal. For blind removal of individual pulses, the $waveform$ of the pulse needs to be known. Longer wavelength pulses have the highest likelyhood to contain pulses which violate the above criteria, so their $amplitude$ can not be determined. We have to start removal with the shortest isolated pulses which can be found in the sample.\\\\
-The main drawback of Fourier Transformation is that frames (integration bounds) and frequency window (measure) have to be adjusted. There are methods for finding bases in order to remove functions from the combined signal. Fourier Transformation does fulfil the task of spectral separation, but arbitrary precision in the time and frequency domain can not be found.
+The main drawback of Fourier Transformation is that frames (integration bounds) and frequency window (measure) have to be adjusted. There are methods for finding bases in order to remove functions from the combined signal. Fourier Transformation does fulfill the task of spectral separation, but arbitrary precision in the time and frequency domain can not be found.
 
 \iffalse
 \printbibliography
 \fi
 \bibliography{Stopeight}{}
 \bibliographystyle{plain}
 
-\end{document}
+\end{document}
```

### Comparing `stopeight-0.3.14/doc/latex/Stopeight.bib` & `stopeight-0.3.22/doc/latex/Stopeight.bib`

 * *Files 25% similar despite different names*

```diff
@@ -50,15 +50,15 @@
 @book{Widon,
                author="Harold Widon",
                maintitle="Measure and Integration",
                title="Measure and Integration",
                year="2016",
                ISBN="978-0-486-81028-7",
                publisher="Dover Publications Inc.",}
-@article{Stopeight,
+@article{Analyzer,
               author="Fassio Blatter",
               journal="Github",
               year="2018",
               title="Stopeight Analyzer",
               doi="43306707",
               url={https://zenodo.org/badge/latestdoi/43306707},}
 @article{Grapher,
@@ -71,21 +71,59 @@
 @article{Comparator,
               author="Fassio Blatter",
               journal="Github",
               year="2018",
               title="Stopeight Comparator",
               doi="43306707",
               url={https://zenodo.org/badge/latestdoi/43306707},}
+@article{Antis,
+              author="Fassio Blatter",
+              journal="Github",
+              year="2018",
+              title="Antis",
+              doi="43306707",
+              url={https://zenodo.org/badge/latestdoi/43306707},}
+@article{Woodpecker,
+              author="Fassio Blatter",
+              journal="Github",
+              year="2018",
+              title="Woodpecker",
+              doi="43306707",
+              url={https://zenodo.org/badge/latestdoi/43306707},}
+@article{Axioms,
+              author="Fassio Blatter",
+              journal="Github",
+              year="2018",
+              title="Spline Axioms",
+              doi="43306707",
+              url={https://zenodo.org/badge/latestdoi/43306707},}
+@article{Fensterfunktion,
+              journal="Wikipedia",
+              url={https://de.wikipedia.org/Fensterfunktion},}
 @book{Mallat,
               author="Stephane Mallat",
               maintitle="A Wavelet Tour of Signal Processing The Sparse Way",
               title="A Wavelet Tour of Signal Processing The Sparse Way",
               year="2009",
               ISBN="978-0-12-374370-1",
               publisher="Elsevier Inc.",}
 @book{Formelsammlung,
               author="DMK",
               maintitle="Formeln, Tabellen, Begriffe: Mathematik-Physik-Chemie",
               title="Formeln, Tabellen, Begriffe: Mathematik-Physik-Chemie",
               year="2009",
               ISBN="978-3 280-04059-1",
-              publisher="Orell Fuessli Verlag AG, Zuerich",}
+              publisher="Orell Fuessli Verlag AG, Zuerich",}
+@book{Wavelets,
+              author="Werner Baeni",
+              maintitle="Wavelets, Eine Einfuehrung fuer Ingenieure, 2. Auflage",
+              title="Wavelets, Eine Einfuehrung fuer Ingenieure, 2. Auflage",
+              year="2005",
+              ISBN="3-486-57706-9",
+              publisher="Oldenbourg Wissenschaftsverlag GmbH, Muenchen",}
+@book{LineareAlgebra,
+              author="Christian Blatter",
+              maintitle="Lineare Algebra fuer Ingenieure, Chemiker und Naturwissenschaftler",
+              title="Lineare Algebra fuer Ingenieure, Chemiker und Naturwissenschaftler",
+              year="1999",
+              ISBN="3-7281-2660-8",
+              publisher="vdf Hochschulverlag AG and der ETH Zuerich",}
```

### Comparing `stopeight-0.3.14/doc/latex/Stopeight_Analyzer.tex` & `stopeight-0.3.22/doc/latex/Stopeight_Analyzer.tex`

 * *Files 6% similar despite different names*

```diff
@@ -1,35 +1,33 @@
 \documentclass{report}
 \usepackage{amsfonts}
 \usepackage{amsmath}
 \usepackage{amssymb}
-\usepackage{hyperref}
 
 \iffalse
 \usepackage{biblatex}
 \addbibresource{Stopeight.bib}
 \fi
 \usepackage{natbib}
 
 \renewcommand{\baselinestretch}{1.25}
-\newcommand\norm[1]{\left\lVert#1\right\rVert}
 
 \begin{document}
 \title{Stopeight Analyzer}
 \author{Fassio Blatter}
 \maketitle
 
 \chapter{Introduction}
 The main algorithm in this text is the Analyzer. It has been developed during the years 2009 to 2016 by Specific Purpose Software GmbH. It is now open sourced, but mostly exists in the form of code fragments.\\
 This file is in the Stopeight repository on Github. Please edit here:\\
-\href{https://github.com/specpose/stopeight/tree/master/doc/latex/Stopeight\_Analyzer.tex}{https://github.com/specpose/stopeight/tree/master/doc/latex/Stopeight\_Analyzer.tex}\\
-The DOI can be found here ~\cite{Stopeight}.\\
+https://github.com/specpose/stopeight/tree/master/doc/latex/Stopeight\_Analyzer.tex\\
+The DOI can be found here ~\cite{Analyzer}.\\
 A brief overview can be found here:\\
-\href{https://specpose.github.io/stopeight/dev_analyzer.html}{https://specpose.github.io/stopeight/dev\_analyzer.html}\\\\
-Notation: Please keep in mind that a single (') denotes an image or transformation of a variable or function. Derivatives are always denoted as $(\frac{\mathrm{d}}{\mathrm{d}t})$.\\\\
+https://specpose.github.io/stopeight/dev\_analyzer.html\\\\
+Notation: Please keep in mind that a single (') denotes an image or transformation of a variable or function. Derivatives are always denoted as $(\frac{\mathrm{d}}{\mathrm{d}t})$ in this paper.\\\\
 The purpose of the Analyzer is to find intervals in a Vector Graph and produce an approximation. The input Vector Graph can be obtained from the Grapher. \cite{Grapher}[1.1]\\\\
 The sequence of Arcs $A \subset \mathbb{R}^2$ are an approximation of a Vector Graph $X \subset \mathbb{R}^2$:
 \begin{align}
 f \circ g: X \rightarrow A
 \end{align}
 \begin{equation*}
 1 < card(X) < \infty
@@ -46,47 +44,47 @@
 \begin{align}
 Y: \text{0-submanifold} \Rightarrow (dim(X)=0)<(codim(Y)=1) \Rightarrow X \text{ disjoint } A
 \end{align}
 but $W$ is not. See \eqref{eq:1}.
 \begin{align}
 Y: \text{0-submanifold} \Rightarrow (dim(W)=1)=(codim(Y)=1) \Rightarrow W \text{ joint } A
 \end{align}
-The approximation aims to find the maximal smooth atlas. Each chart $U_{m}$ has a start of Turn $T \ni S = \min \limits _{U_{m}}$, a Corner $C \in U_{m}$ and an end of Turn $T \ni E = \max \limits _{U_{m}}$. This format has the benefit of reducing the amount of data for $Comparison$ (see Stopeight Comparator), while preserving the $Representation$ using quadratic bezier splines.\\\\
+The approximation aims to find the maximal smooth atlas. Each chart $U_{m}$ has a start of Turn $T \ni S = \min \limits _{U_{m}}$, a Corner $C \in U_{m}$ and an end of Turn $T \ni E = \max \limits _{U_{m}}$. This format has the benefit of reducing the amount of data for $Comparison$ ~\cite[Stopeight\_Comparator.tex]{Comparator}, while preserving the $Representation$ using quadratic Bezier splines.\\\\
 
 \chapter{Representation}
-
-The affine transformations $q$ are functions that map to control points $Q \subset \mathbb{R}^2$:
+Notation: Representation refers to a representation leading from a generative polynomial spline to a target 2D affine space, not a representation for a neural network input vector, or weights obtained by training a neural network.\\\\
+The functions $q$ yield on-curve $q \in A$ and off-curve $q \in Q$ control points $q \in \mathbb{R}^2$:
 \begin{align}
-q: S \times C \times E \rightarrow Q\\
+q: S \times C \times E \rightarrow Q \cup A\\
 Q \cap X = 0; Q \cap Y = 0
 \end{align}
-The combination $Y \cup Q$ has parts from the original $X$'s, and constructed $Q$'s that are not in $A$ $\footnote{insertion: $C \notin X$, otherwise: $C \in X \cap A$}$:
+Apart from $S,C,E$, none of the control points are in the Vector Graph $X$.$\footnote{insertion: $C \notin X$, otherwise: $C \in X \cap A$}$:
 \begin{align*}
-S,C,E \in X; Q \setminus A=\{q_{1}(S,C,E),q_{3}(S,C,E),q_{4}(S,C,E),q_{6}(S,C,E)\}
+S,C,E \in X; q_{1}(S,C,E),q_{3}(S,C,E),q_{4}(S,C,E),q_{6}(S,C,E) \in Q;q_{2}(S,C,E),q_{5}(S,C,E) \in A
 \end{align*}
-and is composed of four quadratic bezier splines $\gamma_{H}(t)$:
+The quartic representations are constrained to express four quadratic bezier splines $\gamma_{H}(t)$:
 \begin{align}
 \gamma_{H}: \mathbb{R} \rightarrow \mathbb{R}^2; t \mapsto (x,y)
 \end{align}
-with control point sets $\{H_{1},...,H_{4}\}$ per chart of $Y \cup Q$. The Arc segment defining function $\xi$ forms the planar coordinates $(x',y')$ of Arc $U_{m}$:
+with control point sets $\{H_{1},...,H_{4}\}$. The Arc segment defining function $\xi$ forms the planar coordinates $(x',y')$ of Arc $U_{m}$:
 \begin{equation}
 \xi: \mathbb{R} \rightarrow A; t \mapsto (x,y)
 \end{equation}
 \begin{align*}
 \xi(t) =
 \begin{cases}
-\gamma_{H_{1}}(t); H_{1}=\{S,q_{1}(S,C_{3},E),q_{2}(S,C_{3},E)\} & t \in [0,\frac{1}{4}]\\
-\gamma_{H_{2}}(t); H_{2}=\{q_{2}(S,C_{3},E),q_{3}(S,C_{3},E),C_{3}\} & t \in [\frac{1}{4},\frac{1}{2}]\\
-\gamma_{H_{3}}(t); H_{3}=\{C_{3},q_{4}(S,C_{3},E),q_{5}(S,C_{3},E)\} & t \in [\frac{1}{2},\frac{3}{4}]\\
-\gamma_{H_{3}}(t); H_{4}=\{q_{5}(S,C_{3},E),q_{6}(S,C_{3},E),E\} & t \in [\frac{3}{4},1]
+\gamma_{H_{1}}(t); H_{1}=\{S,q_{1}(S,C_{4},E),q_{2}(S,C_{4},E)\} & t \in [0,\frac{1}{4}]\\
+\gamma_{H_{2}}(t); H_{2}=\{q_{2}(S,C_{4},E),q_{3}(S,C_{4},E),C_{3}\} & t \in [\frac{1}{4},\frac{1}{2}]\\
+\gamma_{H_{3}}(t); H_{3}=\{C_{4},q_{4}(S,C_{4},E),q_{5}(S,C_{4},E)\} & t \in [\frac{1}{2},\frac{3}{4}]\\
+\gamma_{H_{4}}(t); H_{4}=\{q_{5}(S,C_{4},E),q_{6}(S,C_{4},E),E\} & t \in [\frac{3}{4},1]
 \end{cases}
 \end{align*}
-(Do we need a quartic for correct scaling of $t$?)\\
+Notation: Here, $H$ are sets of points, whereas in ~\cite[Spline\_Axioms.tex]{Axioms} they are 3 by 3 matrices.\\
 Note: The continuous function $\xi$ makes the topological space $A$ path-connected. Therefore it is a $path$ from $U_{m}$ to $U_{m+1}$ and intersects at least once at the unilateral limit $S \cap E$. ~\cite[6.1.3.]{Mortad}\\\\
-In order to compare the length from $[a,b] \subseteq A$ with $[a.b] \subseteq X$, we have to connect all $P_{n}, P_{n+1} \in X$ with one linear bezier spline each, because $X$ is discrete:
+In order to compare the length from $[a,b] \subseteq A$ with $[a,b] \subseteq X$, we have to connect all $P_{n}, P_{n+1} \in X$ with one linear bezier spline each, because $X$ is discrete:
 \begin{align}
 \iota: \mathbb{R} \rightarrow W; t \mapsto (x,y)\\
 \iota_{X}(t) = \{ \gamma_{H}(t)\lvert H=\{P_{n},P_{n}+\frac{(P_{n+1}-P_{n})}{2},P_{n+1}; P_{n}, P_{n+1} \in X\}\}
 \end{align}
 Note: For both $W$ and $A$, the length of the curve is now independent of the choice of parameter on the curve. ~\cite[1.1]{Taimanov}\\\\
 The arc-length metric $d(a,b)$ turns both manifolds $A$ and $W$ into metric spaces $(A,d)$ and $(W,d)$. ~\cite[1.1.3]{Klingenberg}
 \begin{equation}
@@ -96,282 +94,308 @@
 \begin{equation}
 link: W \rightarrow A, (x,y) \mapsto (x',y'); link^{-1}: A \rightarrow W, (x',y') \mapsto (x,y)
 \end{equation}
 
 \chapter{Computation}
 
 \section{Non-Oriented Segments}
-Auxiliary functions are functions of the form $A,B \times A,B \rightarrow \mathbb{R}$ that can be applied to any segment $[a,b] \subseteq (B,d),(A,d)$ without any constraints.\\\\
-The curve functions $ \gamma (t)$ can be interprated as $\gamma(x(t),y(t))$. The derivative in the following is meant to be the total derivative. (chain rule)
+Auxiliary functions are functions of the form $A \times A \rightarrow \mathbb{R}$ that can be applied to any segment $[a,b] \subseteq (A,d)$ without any constraints.\\\\
+The curve functions $ \gamma (t)$ of any degree can be interpreted as $\gamma(x(t),y(t))$. The derivative in the following is meant to be the partial derivatives scaled by the parametrisation. (chain rule)
 \begin{align}
-\frac{\mathrm{d}}{\mathrm{d} t} \gamma (t) = \frac{\mathrm{d}}{\mathrm{d} t} \gamma (x(t),y(t)) = \gamma(t)* (\frac{\partial}{\partial x}  \frac{\mathrm{d} x}{\mathrm{d}t} + \frac{\partial}{\partial y} \frac{\mathrm{d} y}{\mathrm{d}t})
-\end{align}\\
-The second order total derivative. (product rule)
+\frac{\mathrm{d}}{\mathrm{d} t} \gamma (t) = \frac{\mathrm{d}}{\mathrm{d} t} \gamma (x(t),y(t)) = \gamma(t)* (\frac{\partial}{\partial x}  \frac{\mathrm{d} x}{\mathrm{d}t},\frac{\partial}{\partial y} \frac{\mathrm{d} y}{\mathrm{d}t})
+\end{align}
+Notation: The product $\gamma*(x,y)$ is a vector $\begin{pmatrix}\gamma x \\ \gamma y\end{pmatrix}$.\\\\
+The second order scaled partial derivative.
 \begin{align}
-\frac{\mathrm{d}^2}{\mathrm{d}t^2}\gamma(t)= \gamma(t)* (\frac{\partial^2}{\partial x^2}\frac{\mathrm{d}x}{\mathrm{d}t} + \frac{\partial}{\partial x}\frac{\mathrm{d}^2x}{\mathrm{d}t^2} + \frac{\partial^2}{\partial y^2}\frac{\mathrm{d}y}{\mathrm{d}t} + \frac{\partial}{\partial y}\frac{\mathrm{d}^2y}{\mathrm{d}t^2})
+\frac{\mathrm{d}^2}{\mathrm{d}t^2}\gamma(t)= \gamma(t)* (\frac{\partial^2}{\partial x^2}\frac{\mathrm{d}^2x}{\mathrm{d}t^2}, \frac{\partial^2}{\partial y^2}\frac{\mathrm{d}^2y}{\mathrm{d}t^2})
 \end{align}
 The direction of analysis $dir_{Y}$ is preserved in the sign for both straightness and curvature.
 \begin{align}
-dir = \frac{(b-a)}{\lvert b-a \rvert}
+dir = \frac{b-a}{\lvert b-a \rvert}
 \end{align}
 The horizontal diameter is based on the metric of $\iota_{T}$.
 \begin{equation}
 diameter_{horiz,T}(a,b)= dir \lvert \iota_{T}(b) - \iota_{T}(a) \rvert
 \end{equation}
-When the direction of analysis $dir_{Y}$ is reversed, the curve areas lie on the other side, therefore the direction flips the sign of the curve segments.
+When the direction of integration $dir_{X}$ is reversed, the curve areas lie on the other side, therefore the direction flips the sign of the curve segments.
 \begin{align}
-\mu_{+}(\xi(t) -\iota_{T}(t))=\{[a,b] \subseteq A,B; \gamma(t)=\xi(t) -\iota_{T}(t) \vert \gamma(t)>0\}
+\mu_{+}(\xi(t) -\iota_{T}(t))=\{[a,b] \subseteq A; \gamma(t)=\xi(t) -\iota_{T}(t) \vert \gamma(t)>0\}
 \end{align}
 Note: $\mu$ is a Lebesgue.
 
 \subsection{Affine Transformation}
-An affine transformation $M$ of a parametrised curve $\gamma_{H}$ with control points $\{h_{1},h_{2},h_{3}\} = H$ and parameter $t$:
+An affine transformation $M$ of the parametrised quadratic curve $\gamma_{H}$ with control points $\{S,C_{2},E\} = H^{3x3}$ and parameter $t$:
 \begin{equation}
 transform(\gamma):
 \begin{pmatrix}
-1 & t & t^2
+1 \\
+t \\
+t^2
 \end{pmatrix}
 \underbrace{\begin{bmatrix}
-1 & 0 & 0\\
--1 & 1 & 0\\
-0 & -1 &1
-\end{bmatrix}}_{Coefficients}
-M
-\begin{pmatrix}
-h_{1} \\
-h_{2} \\
-h_{3}
-\end{pmatrix}
+1 & -1 & 0\\
+0 & 1 & -1\\
+0 & 0 &1
+\end{bmatrix}}_{Jordanian}
+\underbrace{\begin{pmatrix}
+x(MS) & x(MC_{1}) & x(ME) \\
+y(MS) & y(MC_{1}) & y(ME) \\
+0 & 0 & 0
+\end{pmatrix}}_{\text{Transformed Control Points}}
 =
 \begin{pmatrix}
-h_{1}' & h_{2}' & h_{3}'
+x \\
+y \\
+0
 \end{pmatrix}
 \end{equation}
-The composite $transform(\xi)$ is based on parameter $t$ and $\{H_{1}, ... ,H_{4}\}$. ~\cite[Spline\_Axioms.tex]{Stopeight}
+The composite $transform(\xi)$ of the quartic curve $\xi$ is based on parameter $t$ and $H^{5x5}$. ~\cite[Spline\_Axioms.tex]{Analyzer}
 
 \subsection{Legal Segment}
-A legal segment is an affine transformation of the arc curve function $transform(\xi) = \xi'$, so that all $\xi'_{y}(t)$ for $\xi'_{x}(t)$ are continuous:
+A legal segment is an affine transformation of the arc curve function $transform(\xi) = \xi'$, so that all $y(\xi'(t))$ for $x(\xi'(t))$ are continuous:
 \begin{align}
-a<t<b\rightarrow \xi'_{x}(a)<\xi'_{x}(t)<\xi'_{x}(b) \Leftrightarrow \iota'_{x}(a)<\iota'_{x}(t)<\iota'_{x}(b)
+a<t<b\rightarrow x(\xi'(a))<x(\xi'(t))<x(\xi'(b)) \Leftrightarrow x(\iota'(a))<x(\iota'(t))<x(\iota'(b))
 \end{align}
 When:
 \begin{align}
-\xi'_{x}(a),\xi'_{y}(a), \xi'_{y}(b) = 0 \Leftrightarrow \iota'_{x}(a),\iota'_{y}(a), \iota'_{y}(b) = 0
+x(\xi'(a)),y(\xi'(a)), y(\xi'(b)) = 0 \Leftrightarrow x(\iota'(a)),y(\iota'(a)), y(\iota'(b)) = 0
 \end{align}
-The orientation $ori(a,b)$ of any point $a < t < b$ is the $sign(\xi'_{y}(t))$ or $sign(\iota'_{y}(t))$ after the aforementioned affine transformation.
+The orientation $ori(a,b)$ of any point $a < t < b$ is the $sign(y(\xi'(t)))$ or $sign(y(\iota'(t)))$ after the aforementioned affine transformation.\\
+Notation: The orientation $ori$ of a point, relative to the x-axis is not the notion of an oriented manifold, which depends on the analytic direction $dir_{Y}$.
 
 \subsection{Straightness}
 A straight line segment is determined by means of straightness.\\
 The metric allows us to take the ratio of the difference of the jitter to the straight with $P_{n},P_{n+1} \in X$. \\
 \begin{align}
-straightness_{Rel}(a,b)=\frac{\int \limits _{a}^{b} \lvert \iota_{X}'(t) \rvert \mathrm{d}t}{diameter_{horiz,T}(a,b)}
+straightness_{Rel}(a,b)=\frac{\int \limits _{a}^{b} \lvert \iota_{X}(t)\frac{\mathrm{d}}{\mathrm{d}t}\rvert \mathrm{d}t}{diameter_{horiz,T}(a,b)}
 \end{align}
 A threshold can be chosen, which makes the segment straight or bent in A.\\
 It is closely related to the curvature.
 \subsubsection{Algorithm Version}
-It is using Heron's formula for the area of a triangle in $P_{n}, P_{n+1},P_{n+2} \in [a,b] \subseteq X$.
+It is using Heron's formula ~\cite{Formelsammlung} for the area of a triangle in $P_{n}, P_{n+1},P_{n+2} \in [a,b] \subseteq X$.
 \begin{align*}
 \mathcal{A}=\lvert P_{i+1}-P_{i} \rvert\\
 \mathcal{B}=\lvert P_{i+2} - P_{i+1} \rvert\\
 \mathcal{C}=\lvert P_{i+2} - P_{i} \rvert\\
 \mathcal{L}=\frac{\mathcal{A}+\mathcal{B}+\mathcal{C}}{2}\\
-\mathcal{Q}=\sqrt{\mathcal{L}(\mathcal{L}-\mathcal{A})(\mathcal{L}-\mathcal{B})(\mathcal{L}-\mathcal{C})}
+\mathcal{Q}_{\Delta}=\sqrt{\mathcal{L}(\mathcal{L}-\mathcal{A})(\mathcal{L}-\mathcal{B})(\mathcal{L}-\mathcal{C})}
 \end{align*}
 to calculate the ratio of the areas in $A$ and lines in $W$.
 \begin{align}
-straightness_{Algo}(a,b)=dir \sum_{i=0}^{n+2}\frac{\mathcal{Q}}{\mathcal{A}+\mathcal{B}}
+straightness_{Algo}(a,c)=dir \sum_{i=0}^{n+2}\frac{\mathcal{Q}_{\Delta}}{\mathcal{A}+\mathcal{B}}
 \end{align}
 
 \subsection{Curvature}
 Curvature is determined by the ratio of Area to Diameter.
 \begin{align}
 curvature_{Rel}(a,b) = \frac{\int \limits _{a}^{b} \lvert \xi'(t) \rvert \mathrm{d}t}{diameter_{horiz,T}(a,b)}
 \end{align}
 \subsubsection{Algorithm Version}
-The sum of the pieces in the legal segment [a,b] with $P_{n}, P_{n+1} \in [a,b] \subseteq X$.
+It is using a Nautilus formula with center at the start $a$ for the area of two external segments, and one inlay triangle.\\
+The sum of the pieces in the legal segments $[0,m]$ in $[a,b',b,\ldots,c',c]$ with $P_{n}, P_{n+1} \in [a,c] \subset X$.
 \begin{align}
-curvature_{Algo}(a,b)= dir \frac{\sum \limits _{i=0}^{n}y(P_{i})*(x(P_{i+1})-x(P_{i}))}{x(P_{n+1})-x(P_{0})}
+curvature_{Algo}(a,b)=dir(\mathcal{Q}_{\Theta}(a,b')+\mathcal{Q}_{\Delta}(P(a),P(b'),P(b))/\mathcal{C}+\mathcal{Q}_{\Theta}(b',b)+\ldots+\mathcal{Q}_{\Theta}(c',c))\\
+\mathcal{Q}_{\Theta}= \frac{\sum \limits _{i=0}^{n}y(P_{i})*(x(P_{i+1})-x(P_{i}))}{x(P_{n+1})-x(P_{0})}
 \end{align}
 
 \subsection{Corner}
-A curvature is composed of an infinite amount of local maxima. Therefore the Corner $C$ in a section $[a,b] \subseteq W$ is.
-\begin{equation}
-C_{3} = \{C_{3} \in T_{1} \mid \max_{U}\lvert curvature(a,b) \rvert \cap (\inf_{t \in U} \lvert \frac{\mathrm{d}}{\mathrm{d}t}\gamma(t) \rvert \approx 0) \}
-\end{equation}
-The indexing corresponds to the minimal grade of the polynomial that is necessary.
+A curvature is composed of an infinite amount of local maxima. Therefore the Corner $C$ in a section $[a,b] \subseteq X$ is.
 \begin{align}
-\xi_{C_{1}} : \text{Quadratic Bezier Spline}\\
-\xi_{C_{2}} : \text{Cubic Bezier Spline}\\
-\xi_{C_{3}} : \text{Quartic Bezier Spline}
+C_{4} \subseteq median(\arg \inf_{t \in A} \lvert \frac{\mathrm{d}}{\mathrm{d}t}\xi(t) \rvert \approx 0) \\
+median = \min_{t \in U}\lvert(\frac{b-a}{2})-t\rvert
 \end{align}
-Note: Except for insertion (See Straight), $C_{3},C_{0} \in Y$, but all the others $C_{1},C_{2},C_{4},... \not\in X$, because they are only found in the approximation $C_{1},C_{2},C_{4},... \in A$.\\
-(To be disclosed: Algorithms for finding lower Corner indexes from higher Corner indices $q_{2},q_{5}$, Control points inbetween $q_{1},q_{3},q_{4},q_{6}$ and the inverse.)
 
 \subsection{Turn}
-A turn $T$ is a change of sign in the orientation of the curve. In a segment $[a,b] \subseteq W$ an infinite amount of non-straight sections can be found.
+A turn $T$ is a change of sign in the orientation $ori$ of the curve. In a segment $[a,b] \subseteq X$ an infinite amount of non-straight sections can be found.
 \begin{equation}
-T_{2} \subseteq \inf_{t \in U} \lvert \frac{\mathrm{d}^2}{\mathrm{d}t^2}\gamma(t) \rvert \approx 0
+T_{4} \subseteq \inf_{t \in A} \lvert \frac{\mathrm{d}^2}{\mathrm{d}t^2}\xi(t) \rvert \approx 0
 \end{equation}
 
+\subsection{Notation}
+The indexing corresponds to the minimal degree of the polynomial that is needed by the representation ($C$) or expected by the computation ($T$).
+\begin{align}
+C_{1} : \text{Point on a straight line}\\
+C_{2} : \text{Quadratic on-spline control point}\\
+C_{3} : \text{Cubic on-spline control point}\\
+C_{4} : \text{Quartic on-spline control point}
+\end{align}
+$C_{n}$ : Solution to a linear independent planar projection of a polynomial of one variable t of degree n at domain value t between 0 and 1.\\\\
+Note: Except for insertion (See Straight), $C_{4} \in Y$, but all the others $C_{1},C_{2},C_{3},C_{5}...,C_{n} \not\in X$, because they are only found in the approximation $C_{1},C_{2},C_{3},...,C_{n} \in A$.\\
+The on-spline control points $A_{n}$ and the Bezier control points $Q_{n}$ are labeled using the same scheme.\\\\
+Notation: If numbers are omitted $C$ refers to $C_{4}$ in this paper. In other uses it may be considered to be a local maximum.
+
 \section*{Oriented Sections}
-Sectioning/charting functions are functions of the form $(a,b) \mapsto (a,b')$ that can be applied to certain sections $[a,b] \subseteq (B,d),(A,d)$ with constraints of computational priority. They create further sections of Turns $T$ in the transversality $Y$.
+Sectioning/charting functions are functions of the form $(a,b) \mapsto (a,b')$ that can be applied to certain sections $[a,b] \subseteq (A,d)$ with constraints of computational priority. They create further sections of Turns $T$ in the transversality $Y$.
 
 \section{Non-recursive Sections}
 Non-recursive sections are not proper section types, but merely an expression of intermediate calculation and are therefore of medium computational priority (See discussion of oriented submanifolds in Compact Covers). They do induce a shift inside the Compact Cover if they're not centered.\\\\
 
 \subsection{Cliff}
 A Cliff is a section $[a,b']$. A single Cliff can have no more than the maximum $curvature(a,b)$. The maximum curvature is defined by the area of a half unit circle divided by the diameter $2r=1$. It is a part of a Spiral.
 \begin{align}
-Max_{Curve}=\frac{(\pi r^2) /2}{2r}\\
+Max_{Curve}=\frac{\pi r^2 /2}{2r}\\
 C_{4} \ni b'
 \end{align}
 
 \subsection{Straight}
-A Straight is a segment $[a,b]$ where $straightness(a,b)$ is smaller or equal to the ratio of arc-length of one eight of a circle to its direct connecting line. This happens to coincide with the number of on curve control points for a quartic spline. It is a part of a Spike, or being used at lowest priority of computation to replace the Straight half of an $\{S,C,E\} \subset T$, or to identify a Spike with an angle of less than 90 degrees. A Corner is $inserted$.
+A Straight is a segment $[a,b]$ where $straightness(a,b)$ is smaller or equal to the ratio of the corresponding arc-length of one regular-polygon side in a circle to the length of the direct line. Choosing the polygon $n\geq 4$ is subject to the underlying pen-tablet or signal analog to digital converter. It is a part of an Edge,
 \begin{align}
-Max_{Straight}=\frac{\pi r / 4}{\sqrt{(\frac{r}{2})^2+(\frac{r}{2})^2}}\\
-C_{3} \ni \frac{b-a}{2}
+Max_{Straight}=\frac{2\pi r / n}{\vert (\sin \frac{2\pi r}{n}-r*1,\cos \frac{2\pi r}{n}-r*0) \vert}
 \end{align}
-A special case is when $card(U_{m})=2$, a Corner is inserted as well.\\\\
-Straightness is no more than what is not to be considered straight under any linear transformation of any segment.
+or being used at lowest priority of computation (TT-Qualifier) to replace a curved $\{S,C,E\} \subset T$ with a straight one. The Corner $C_{4} \in U_{m }\subset X,Y,A$ is $replaced$ with $C_{4} \in Z,A; C_{4} \notin X,Y$.
+\begin{align}
+\xi(\frac{b-a}{2}) = \iota_{T}(a)+\frac{\iota_{T}(b)-\iota_{T}(a) }{2}
+\end{align}
+A special case is when $card(U_{m})=2$, a Corner $C_{4} \in Z,A; C_{4} \notin X,Y$ is $inserted$.\\
 
 \subsection{Swing}
-A Swing is the section $[a,b']$ $\footnote{$a \in Y, b' \in A,B$ but it is not guaranteed, that $b' \in X$}$, where a legal segment $[a,b]$ is delimited by a sign change $[c,d]; c<b'<d$ under affine transformation $\xi'$. It is part of the Crest detection.\\
+A Swing is a segment $[a,b']$ $\footnote{$a \in Y, b' \in A$ but it is not guaranteed, that $b' \in X$}$, where a legal segment $[a,b]$ is delimited by a sign change $[c,d]; c<b'<d$ under affine transformation $\xi'$. It is part of the Crest detection.\\
 \begin{align}
-\xi'(c)>0;\xi'(b')=0;\xi'(d)<0\\
-T_{2} \ni b'
+\exists y(\xi'(c))>0,\exists y(\xi'(b'))=0,\exists y(\xi'(d))<0\\
+T_{\approx 3} \ni b'
 \end{align}
 The criteria, whether a segment is within a chart is ~\cite[20.7]{Loring}.
 \begin{equation}
-[a,b] \subseteq U_{m} \Rightarrow \exists  \xi'(t) - \iota_{T}'(t) >0 \land \nexists \xi'(t) - \iota_{T}'(t) \leq 0
+[a,b] \subseteq U_{m} \Rightarrow \exists  y(\xi'(t) - \iota_{T}'(t)) >0 \land \nexists y(\xi'(t) - \iota_{T}'(t)) < 0
 \end{equation}
 (both vice-versa)\\\\
-A special case is where the whole chart is flat and Straight.
-\begin{equation}
-[a,b] \subseteq U_{m} \Rightarrow \nexists \xi'(t) - \iota_{T}'(t) <0 \land \nexists \xi'(t) - \iota_{T}'(t) >0
-\end{equation}
+When $b' \notin X$, it is interpolated $b' \in Z,A; b' \notin X,Y$.
+\begin{align}
+[a,b] \subseteq U_{m}, \exists y(\iota_{X}'(t)) <0 \land \exists y(\iota_{X}'(t)) >0\Rightarrow \exists \land y(\iota_{W}')=0
+\end{align}
 
 \subsection{Dune}
 A frontside Dune $[a,b',c]$ is a segment [a,b], where a Straight segment $[a,b']$ is followed by a Non-Straight segment $[b',c]; $. It is part of the Edge detection.
 \begin{align}
 straightness(a,b')\leq Max_{Straight}\\ straightness(b',c)> Max_{Straight}
 \end{align}
 
 \section{Recursive Sections}
-In the method discussed in this paper, the maximal order of the polynomials considered is quartic with restrictions, i.e. the representation is quadratic.  (The functions $q$ and the points $S,C,E$ pose a constraint on the quartic analytic form ~\cite[Spline\_CharacteristicPolynomials.nb]{Stopeight} and its inverse.)\\\\
-The following recursive subsections reveal hidden derivatives.
-\begin{equation}
-T_{2} \subseteq \inf_{t \in U} \lvert \frac{\mathrm{d}^2}{\mathrm{d}^2t}\gamma(t) \rvert \approx 0
-\end{equation}
+Recursive sections have higher computational priority. This is because they can reduce shift and improve curve-fitting when working with spline polynoms of higher degree and data with relatively high bandwith.
 
 \subsection{Crest}
 A backside Crest section $[a,a']$ is an iteration of:
 \begin{enumerate}
-\item The Forward direction of analysis $dir_{Y}=1$ of a $[a,b']$ Swing, followed by 
-\item The Reverse direction of analysis $dir_{Y}=-1;[b',a]$ reveals a Backward $[b',a']$ Swing
+\item The Forward direction of integration $dir_{X}=1$ of a $[a,b']$ Swing, followed by 
+\item The Reverse direction of integration $dir_{X}=-1;[b',a]$ reveals a Backward $[b',a']$ Swing
 \item Continue iteration $[a',b']...$
 \end{enumerate}
 The breaking condition is that no more entities are being found after the second step.
 \begin{equation}
-b' \in T_{2}
+b' \in T_{4}
 \end{equation}
 
 \subsection{Edge}
-A frontside Edge segment $[a,b']$ is an iteration of:
+A frontside Edge section $[a,b']$ is an iteration of:
 \begin{enumerate}
-\item The Forward direction of analysis $dir_{Y}=1$ of a frontside Dune $[a,b',c]$
-\item The Reverse direction of analysis $dir_{Y}=-1;[b',a]$ of a frontside Dune $[b',b'',a]; b''<b<b'$ 
+\item The Forward direction of integration $dir_{X}=1$ of a frontside Dune $[a,b',c]$
+\item The Reverse direction of integration $dir_{X}=-1;[b',a]$ of a frontside Dune $[b',b'',a]; b''<b<b'$ 
 \item Continue iteration $[a,b'',b']...$
 \end{enumerate}
 The breaking condition is that no more entities are being found after the second step.
 \begin{equation}
-b' \in T_{2}
+b' \in T_{\approx 2}
 \end{equation}
-
-\subsection{Spike}
-A frontside Spike is a section $[a,b',c]$, where
-\begin{enumerate}
-\item The Forward direction of analysis $dir_{Y}=1$ reveals a frontside Edge $[a,b']$, and
-\item The Backward direction of analysis $dir_{Y}=-1$ reveals a frontside Edge $[c,b'']$ 
-\end{enumerate}
-and the $angle$ in the intersection of the extensions of the two edges is between 90 and 135 degrees.\\
-\begin{align}
-Max_{angle}=\frac{3\pi}{4}\\
-Min_{angle}=\frac{pi}{2}\\
-b' \in T_{2},C_{4}
-\end{align}
-Or 90 and 0 degrees:
-\begin{align}
-Max_{angle}=\frac{pi}{2}\\
-Min_{angle}=0\\
-b' \in T_{3}
-\end{align}
-Note: Very steep angles are likely not to be continuous when a lot of data points are available. They may be caught by Cliff detection.\\\\
-It is part of ZigZag detection.
-
-\subsection{Moustache?}
-Indicates a break or change of direction $dir_{Z}$ in Swells and Spirals $[a,b',c]$ at the most. A Spike on the other hand only leads to the creation of a ZigZag.
-\begin{equation}
-b' \in T_{3}
-\end{equation}
-Moustache is correctly handled by the backside Crest, but it would only be a $T_{2}$ if not caught by Compact Covers.
+A backside Edge does not exist. It is handled by Straight detection (~\cite{Analyzer}[3.23]).
 
 \subsection*{Adjusted Differences}
-By now, we can improve the differences by setting $dom(\xi,\iota)=Crest \cup Spike \cup C_{4}$.
+By now, we can improve the differences by setting $dom(\xi,\iota)=Crest \cup Edge \cup C_{4}$.
 
 \section{Compact Covers}
-We introduce another set of charts $\{V_{n}\} \subset Z$ which span one or more of the charts $\{U_{n}\} \subset A$.
+We introduce another set of charts $\{V_{n}\} \subset Z$ which span one or more of the charts $\{U_{m}\} \subset A$.
+\subsubsection*{Notation}
+$T_{0}$ refers to a scalar offset of beginning and end of computational analysis of a Vector Graph in a very flat segment or $C_{0}$ in a very curved segment.
 \subsubsection*{Open}
+~\cite{Mortad}
 \begin{align}
 A \text{ is open} \Leftrightarrow \inf_{A},\sup_{A}\in T_{0},C_{0}
 \end{align}
-In computer science there is the concept of the stream operator. This means that approximation $A$ would have to be recomputed whenever elements are added to the front or to the tail. Also it would require that a supremum arc length would have to be found from all the sections between turns $A \cap T$. It would make sense that the longest Spiral be chosen, which depends on curvature. One could also argue that the longest ZigZag with an absolute straightness of $1$ be chosen for the first center. Spreading out left and right, a mixed approach or a fully centered one could be chosen. One could also decide to interleave frontside and backside entities of the same type.
+In computer science there is the concept of the stream operator. This means that approximation $A$ would have to be recomputed whenever elements are added to the front or to the tail. Also it would require that a supremum arc length would have to be found from all the sections between turns $A \cap T$. It would make sense that the longest Spiral be chosen, which depends on curvature. One could also argue that the longest ZigZag with an absolute straightness of $1$ be chosen for the first center. Spreading out forward and backward, a mixed approach or a fully centered one could be chosen. One could also decide not to interleave frontside and backside entities of the same type.
 \subsubsection*{Closed}
 \begin{align}
 A \text{ is closed} \Leftrightarrow \min_{A},\max_{A}\in T_{0},C_{0}
 \end{align}
-For the time being, the approach in this paper is a compromise. Half-open front and tail sections $\footnote{It is questionable, whether losing front/tail sections is significant for most uses}$ are obliterated and the oriented manifolds between them are never fully centered. In particular the Crests and Edges exhibit a transcendence of fractal dimension, which significantly offset the consecutive oriented functions. Even finding Swings and Edg shifts the adjacent entities. The reversal and priority of segments and sections imposes a certain rigor in programming technique. A compatible software architecture is a requirement.\\
+For the time being, the approach in this paper is a compromise. Half-open front and tail sections $\footnote{It is questionable, whether losing front/tail sections is significant for most uses}$ are obliterated and the oriented manifolds between them are never fully centered. In particular the Crests and Edges exhibit a transcendence of fractal dimension, which significantly offset the consecutive oriented functions. Even finding Swings and Edges shifts the adjacent entities. The reversal and priority of segments and sections imposes a certain rigor in programming technique. A compatible software architecture is a requirement.\\
 Nevertheless the curve can be interpreted, if a threshold in Stopeight Comparator is increased, which lowers the requirement for overlay comparison matching accuracy ($Comparator$).
 It all comes down to whether oriented submanifolds are allowed and whether the enclosing submanifolds and the whole manifold are allowed to be oriented (Causal Structure).
 
 \subsection{Spiral}
-Spiral $\supset$ Cliff $\not \supset$ Straight\\
+Spiral $\supset$ Cliff; Spiral $\not \supset$ Straight; Spiral $\not \supset$ Dune; Spiral $\not \supset$ Swing;\\ Spiral $\not \supset$ Crest; Spiral $\not \supset$ Edge; Spiral $\not \supset$ Moustache; Spiral $\not \supset$ Spike; Spiral $\not \supset$ Ramp\\\\
 A Spiral section $[a,b']$ is a Cliff, where
 \begin{align}
 Max_{Spiral}=\frac{curvature(a,b)}{\{n-m\in \mathbb{N} \vert U_{m},...,U_{n} \subseteq Spiral\}}\\
 b' \in C_{4}
 \end{align}
 The Cliffs are centered outside in so that all cliffs in a spiral have the same curvature measured inward from $a,b$.
+\subsubsection{Moustache}
+A Moustache is a CC-Separator.
+\begin{equation}
+(ori(a,b')<0\land ori(b',c)<0)\lor (ori(a,b')>0\land ori(b',c)>0)
+\end{equation}
+It is handled by Cliff or Crest detection, but it would only be a $T_{4}$ if not caught by Compact Covers. Indicates a break of Spirals $[a,b',c]$ at the most.
+\begin{equation}
+b' \in T_{\infty}
+\end{equation}
+A Moustache is not allowed to occur in a Swell by definition, therefore it divides a Swell $V_{n}$ and a Spiral/Swell $V_{n-1}$ or two Spirals $V_{n-1},V_{n}$.
+\begin{equation}
+V_{n-1}\cap V_{n}\in X; V_{n-1}\supset U_{m-1}\land V_{n}\supset U_{m}
+\end{equation}
+
 \subsection{ZigZag}
-ZigZag $\supset$ Spike $\supset$ Straight\\\\
-Whether it is a Turn or a Corner depends on orientation of the adjacent Straights relative to each other.\\\\
+ZigZag $\not\supset$ Cliff; ZigZag $\supset$ Straight; ZigZag $\not\supset$ Dune; ZigZag $\not\supset$ Swing;\\ ZigZag $\not\supset$ Crest; ZigZag $\supset$ Edge; ZigZag $\not \supset$ Moustache; ZigZag $\supset$ Spike; ZigZag $\not \supset$ Ramp\\\\
+Whether it is a Turn or a Corner depends on orientation $ori$ of the adjacent Straights relative to each other.\\\\
 Whether angles less than 90 degree are allowed to be in the dataset is subject of definition.
-From 90 degree to 180 degree, it is not losing its orientation. A single Spike section is in this case.
-\begin{align}
-b' \in C_{4} \lor b' \in T_{2}
+From 90 degree to 180 degree, it is not losing its orientation.
+\subsubsection{Spike}
+A Spike is a TT-Separator.
+\begin{align}
+straightness(a,b')\leq Max_{Straight}\\ straightness(b',c)\leq Max_{Straight}
+\end{align}
+It is of highest computational priority. The $angle$ in the intersection of the extensions of the two edges determines the type of the Corner.\\\\
+It is between 90 (square) and $\frac{n-2}{n}*180$ degrees ($Max_{Straight}$).
+\begin{align}
+Max_{angle}=\frac{(n-2)\pi}{n}\\
+Min_{angle}=\frac{\pi}{2}\\
+b' \in T_{1} \Rightarrow b' \not\in C_{4}
 \end{align}
-Below 90 degree, a single Spike section is.
+Or 90 and 0 degrees:
 \begin{align}
-b' \in T_{3} \Rightarrow (\text{third derivative }= 0?)
+Max_{angle}=\frac{\pi}{2}\\
+Min_{angle}=0\\
+b' \in T_{1} \land b' \in C_{\infty}
 \end{align}
+Note: Very steep angles are likely not to be continuous when a lot of data points are available. They may be caught by Cliff detection.\\\\
+If $b'$ is not in the in the Vector Graph $X$, it has to be $approximated$ in the transversality $(Z \subset A) \ni T; T \notin X,Y$ by linear regression of $(U_{m-1}\cup U_{m})\subset X$. $T=U_{m-1}\cap U_{m}$ is then re-assigned to the new approximated $T_{0}\in Z$.
+
+
 \subsection{Swell}
-Swell $\supset$ Crest $\supset$ Swing $\supset$ Straight(?)\\
+Swell $\not\supset$ Cliff; Swell $\supset$ Straight; Swell $\supset$ Dune; Swell $\supset$ Swing;\\ Swell $\supset$ Crest; Swell $\supset$ Edge; Swell $\not \supset$ Moustache; Swell $\not \supset$ Spike; Swell $\supset$ Ramp\\\\
 A swell is centered by triplets.\\\\
 The Captain of Swing\\
 Picking up where Sisyphos left in the previous article. At the top of the hill. Waves fall in formation. The captain is steering in high seas. He is swinging the wheel off the top as the next wave builds up. As if the water could feel the magnetic disruption, the surface tension breaks up. The second peak crumbles. The engine roars up in an attempt to dig the stern deeper into the dune. It stutters and almost...\\
 The rigidity of the frame makes it tremble in a gigantic resonant groan to the impact of the third wave. To which it can not react. This is almost real-time. Hawaiians measure the wave from the back.\\
 So how many waves does it take to measure the peak?\\
 You can see the first peak from the second. But because the wave segment reacts to its environment, the second peak is only locally defined when the third peak has passed.\\
 But we are not looking at the peaks, are we?\\
 We are dealing with frequencies. The waveform starts with an upward swing. The ship is almost in a suspended state mid-air, before it starts falling into the trough after the second swing. At the foot of the third swing we can almost make out the first peak. This is when we can start finding out where we fell through:\\
 The second swing.\\
 The triplet of swings is our most accurate index for stabilising the frequencies.
+\subsubsection{Ramp}
+A Ramp is a TT-Qualifier.
+\begin{align}
+(ori(a,b')=0\land ori(b',c)<0)\lor (ori(a,b')=0\land ori(b',c)>0)\\
+(ori(a,b')<0\land ori(b',c)=0)\lor (ori(a,b')>0\land ori(b',c)=0)
+\end{align}
+A frontside Ramp is handled by Edge detection, a backside Ramp is handled by Crest detection. It is not a break of the Compact Cover and is only a $T_{4}$.
+\begin{equation}
+U_{m-1}\cap U_{m}\in X; V_{n}\supset U_{m-1},U_{m}
+\end{equation}
 
 \subsection*{Direction}
-If the affine transformations $dir_{Y}$ are applied left to right $[a,b];a<b$, the Compact Cover $dir_{Z}$ is positive. If the direction of analysis $dir_{Y}$ is reversed $[b,a]$, it is negative. The same applies to the diameter, but it is not the analytic direction but the direction of integration $dir_{X}$.\\\\
+If the affine transformations $dir_{Y}$ are applied left to right $[a,b];a<b$, the Compact Cover $dir_{Y}$ is positive. If the direction of analysis $dir_{Y}$ is reversed $[b,a]$, it is negative. The same applies to the diameter, but it is not the analytic direction but the direction of integration $dir_{X}$.\\\\
 Summary: $X$ is original data, $A$ full approximation, $Y$ initial transversality only, $Z$ Compact Cover point transversality only.
 
 \iffalse
 \printbibliography
 \fi
 \bibliography{Stopeight}{}
 \bibliographystyle{plain}
```

### Comparing `stopeight-0.3.14/doc/make.bat` & `stopeight-0.3.22/doc/make.bat`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/mathematica/Spline_EVConstraint.nb` & `stopeight-0.3.22/doc/mathematica/Spline_EVConstraint.nb`

 * *Files 11% similar despite different names*

```diff
@@ -1,826 +1,821 @@
-(* Content-type: application/vnd.wolfram.mathematica *)
-
-(*** Wolfram Notebook File ***)
-(* http://www.wolfram.com/nb *)
-
-(* CreatedBy='Mathematica 11.3' *)
-
-(*CacheID: 234*)
-(* Internal cache information:
-NotebookFileLineBreakTest
-NotebookFileLineBreakTest
-NotebookDataPosition[       158,          7]
-NotebookDataLength[     38326,        818]
-NotebookOptionsPosition[     36604,        785]
-NotebookOutlinePosition[     36938,        800]
-CellTagsIndexPosition[     36895,        797]
-WindowFrame->Normal*)
-
-(* Beginning of Notebook Content *)
-Notebook[{
-Cell[BoxData[
- RowBox[{"ClearAll", "[", 
-  RowBox[{"Evaluate", "[", 
-   RowBox[{
-    RowBox[{"Context", "[", "]"}], "<>", "\"\<*\>\""}], "]"}], "]"}]], "Input",\
-
- CellLabel->"In[68]:=",ExpressionUUID->"65d45139-50ab-4f38-9cd3-0897640d6bab"],
-
-Cell[BoxData[
- RowBox[{
-  RowBox[{"Needs", "[", "\"\<Spline`\>\"", "]"}], ";", 
-  RowBox[{"Needs", "[", "\"\<SubSpaces`\>\"", "]"}]}]], "Input",
- CellChangeTimes->{{3.753702624847374*^9, 3.753702651682048*^9}, {
-   3.7562091338207912`*^9, 3.7562091398916073`*^9}, 3.756456930926633*^9, {
-   3.756459845923547*^9, 3.756459850214402*^9}},
- CellLabel->"In[69]:=",ExpressionUUID->"a16c6f53-7e6a-436e-811b-f62e51de4298"],
-
-Cell["\<\
-find all x,y for which the pythagorean mean of the first eigenvalues of the \
-master and submatrix are 1\
-\>", "Text",
- CellChangeTimes->{{3.756459409955472*^9, 3.756459446031177*^9}, {
-  3.756459496634173*^9, 
-  3.7564595889340076`*^9}},ExpressionUUID->"09960bfd-191c-4f23-99f8-\
-c9c531996076"],
-
-Cell[BoxData[{
- RowBox[{
-  RowBox[{"Clear", "[", 
-   RowBox[{"x", ",", "y", ",", "s1", ",", "s2", ",", "esystems"}], "]"}], 
-  ";"}], "\[IndentingNewLine]", 
- RowBox[{
-  RowBox[{"MatrixForm", "[", 
-   RowBox[{"Coef", "=", 
-    RowBox[{"{", 
-     RowBox[{
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"-", "1"}], ",", "1", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", 
-        RowBox[{"-", "1"}], ",", "1"}], "}"}]}], "}"}]}], "]"}], 
-  ";"}], "\n", 
- RowBox[{
-  RowBox[{"H", "=", 
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"{", 
-      RowBox[{"0", ",", "0", ",", "0"}], "}"}], ",", 
-     RowBox[{"{", 
-      RowBox[{"x", ",", "y", ",", "0"}], "}"}], ",", 
-     RowBox[{"{", 
-      RowBox[{"1", ",", "0", ",", "0"}], "}"}]}], "}"}]}], ";"}]}], "Input",
- CellChangeTimes->{{3.756456910325953*^9, 3.756456911485878*^9}, {
-   3.756457065393977*^9, 3.756457130704842*^9}, {3.756457178963238*^9, 
-   3.756457223203022*^9}, {3.75645729613369*^9, 3.756457333093988*^9}, {
-   3.756457372152726*^9, 3.756457478694639*^9}, {3.756457658210804*^9, 
-   3.756457660387308*^9}, {3.756457711409144*^9, 3.7564577816200113`*^9}, {
-   3.756457881891737*^9, 3.7564578884936943`*^9}, {3.7564579385243483`*^9, 
-   3.756458004808157*^9}, {3.756458046281458*^9, 3.756458048865675*^9}, {
-   3.7564580839009333`*^9, 3.756458102168103*^9}, {3.7564581450655203`*^9, 
-   3.756458208920618*^9}, {3.756458267009261*^9, 3.756458294052622*^9}, {
-   3.7564583290316896`*^9, 3.756458428297187*^9}, {3.756458855368375*^9, 
-   3.7564588581547728`*^9}, {3.756458892060815*^9, 3.7564589405618467`*^9}, {
-   3.756459077469171*^9, 3.756459183708806*^9}, {3.75645923963918*^9, 
-   3.75645924531663*^9}, {3.756459275720622*^9, 3.75645927833908*^9}, {
-   3.7564593148279123`*^9, 3.7564593317472267`*^9}, 3.756459602885786*^9, {
-   3.756459789695437*^9, 3.756459827876498*^9}, {3.7564598914279413`*^9, 
-   3.7564599186397867`*^9}, {3.756460027633892*^9, 3.756460050436306*^9}, {
-   3.756460144948061*^9, 3.756460145388665*^9}, {3.7564601993688803`*^9, 
-   3.756460199450418*^9}, {3.7564602359505167`*^9, 3.7564602436489277`*^9}, {
-   3.756460315927175*^9, 3.7564603294688253`*^9}, {3.7564605357754107`*^9, 
-   3.756460544057013*^9}, {3.75646057805752*^9, 3.756460635423991*^9}, {
-   3.756460905331465*^9, 3.7564609101990747`*^9}, {3.756461005127858*^9, 
-   3.756461011764902*^9}},
- CellLabel->"In[70]:=",ExpressionUUID->"9dbc3571-1f42-4c1e-a479-47dc7b02f091"],
-
-Cell[CellGroupData[{
-
-Cell[BoxData[{
- RowBox[{
-  RowBox[{"Clear", "[", 
-   RowBox[{"x", ",", "y", ",", "s1", ",", "s2", ",", "esystems"}], "]"}], 
-  ";"}], "\[IndentingNewLine]", 
- RowBox[{"esystems", "=", 
-  RowBox[{
-   RowBox[{
-    RowBox[{"Eigensystem", "[", "#", "]"}], "&"}], "/@", 
-   RowBox[{"ListSubSpaces", "[", 
-    RowBox[{"Coef", ".", 
-     RowBox[{"H2", "[", 
-      RowBox[{"Coef", ",", 
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"{", 
-          RowBox[{"1", ",", "0", ",", "0"}], "}"}], ",", 
-         RowBox[{"{", 
-          RowBox[{"0", ",", "1", ",", "0"}], "}"}], ",", 
-         RowBox[{"{", 
-          RowBox[{"0", ",", "0", ",", "1"}], "}"}]}], "}"}], ",", 
-       RowBox[{"{", 
-        RowBox[{"0", ",", "0"}], "}"}], ",", 
-       RowBox[{"{", 
-        RowBox[{"x", ",", "y"}], "}"}], ",", 
-       RowBox[{"{", 
-        RowBox[{"1", ",", "0"}], "}"}]}], "]"}]}], 
-    "]"}]}]}], "\[IndentingNewLine]", 
- RowBox[{"s1", "=", 
-  RowBox[{
-   RowBox[{
-    RowBox[{"esystems", "[", 
-     RowBox[{"[", "1", "]"}], "]"}], "[", 
-    RowBox[{"[", "1", "]"}], "]"}], "[", 
-   RowBox[{"[", "3", "]"}], "]"}]}], "\[IndentingNewLine]", 
- RowBox[{"s2", "=", 
-  RowBox[{
-   RowBox[{
-    RowBox[{"esystems", "[", 
-     RowBox[{"[", "2", "]"}], "]"}], "[", 
-    RowBox[{"[", "1", "]"}], "]"}], "[", 
-   RowBox[{"[", "1", "]"}], "]"}]}], "\[IndentingNewLine]", 
- RowBox[{
-  RowBox[{"Sqrt", "[", 
-   RowBox[{
-    RowBox[{"s1", "^", "2"}], "+", 
-    RowBox[{"s2", "^", "2"}]}], "]"}], "\[Equal]", "1"}]}], "Input",
- CellChangeTimes->{{3.756456910325953*^9, 3.756456911485878*^9}, {
-   3.756457065393977*^9, 3.756457130704842*^9}, {3.756457178963238*^9, 
-   3.756457223203022*^9}, {3.75645729613369*^9, 3.756457333093988*^9}, {
-   3.756457372152726*^9, 3.756457478694639*^9}, {3.756457658210804*^9, 
-   3.756457660387308*^9}, {3.756457711409144*^9, 3.7564577816200113`*^9}, {
-   3.756457881891737*^9, 3.7564578884936943`*^9}, {3.7564579385243483`*^9, 
-   3.756458004808157*^9}, {3.756458046281458*^9, 3.756458048865675*^9}, {
-   3.7564580839009333`*^9, 3.756458102168103*^9}, {3.7564581450655203`*^9, 
-   3.756458208920618*^9}, {3.756458267009261*^9, 3.756458294052622*^9}, {
-   3.7564583290316896`*^9, 3.756458428297187*^9}, {3.756458855368375*^9, 
-   3.7564588581547728`*^9}, {3.756458892060815*^9, 3.7564589405618467`*^9}, {
-   3.756459077469171*^9, 3.756459183708806*^9}, {3.75645923963918*^9, 
-   3.75645924531663*^9}, {3.756459275720622*^9, 3.75645927833908*^9}, {
-   3.7564593148279123`*^9, 3.7564593317472267`*^9}, 3.756459602885786*^9, {
-   3.756459789695437*^9, 3.756459827876498*^9}, {3.7564598914279413`*^9, 
-   3.7564599186397867`*^9}, {3.756460027633892*^9, 3.756460050436306*^9}, {
-   3.756460144948061*^9, 3.756460145388665*^9}, {3.7564601993688803`*^9, 
-   3.756460199450418*^9}, {3.7564602359505167`*^9, 3.7564602436489277`*^9}, {
-   3.756460315927175*^9, 3.7564603294688253`*^9}, {3.7564605357754107`*^9, 
-   3.756460544057013*^9}, {3.75646057805752*^9, 3.756460635423991*^9}, {
-   3.756460905331465*^9, 3.7564609101990747`*^9}, {3.756461041354941*^9, 
-   3.7564610487404137`*^9}, {3.75646109613271*^9, 3.756461099021854*^9}, {
-   3.756462938804141*^9, 3.75646294093736*^9}, {3.7564629731644773`*^9, 
-   3.756463085738658*^9}, {3.756463116824527*^9, 3.7564631371320143`*^9}, {
-   3.756463172944376*^9, 3.756463196038673*^9}},
- CellLabel->"In[73]:=",ExpressionUUID->"bbb8814f-becb-4de9-bddf-5c74453e3308"],
-
-Cell[BoxData[
- RowBox[{"{", 
-  RowBox[{
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"{", 
-      RowBox[{"0", ",", "0", ",", 
-       RowBox[{"4", " ", "y"}]}], "}"}], ",", 
-     RowBox[{"{", 
-      RowBox[{
-       RowBox[{"{", 
-        RowBox[{"0", ",", "0", ",", "1"}], "}"}], ",", 
-       RowBox[{"{", 
-        RowBox[{"0", ",", "0", ",", "0"}], "}"}], ",", 
-       RowBox[{"{", 
-        RowBox[{"0", ",", 
-         RowBox[{"-", "1"}], ",", "1"}], "}"}]}], "}"}]}], "}"}], ",", 
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"{", 
-      RowBox[{
-       RowBox[{
-        RowBox[{"-", "1"}], "+", 
-        RowBox[{"4", " ", "x"}]}], ",", 
-       RowBox[{
-        RowBox[{"-", "4"}], " ", "y"}]}], "}"}], ",", 
-     RowBox[{"{", 
-      RowBox[{
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"-", 
-          FractionBox[
-           RowBox[{
-            RowBox[{"-", "1"}], "+", 
-            RowBox[{"4", " ", "x"}], "+", 
-            RowBox[{"4", " ", "y"}]}], 
-           RowBox[{"2", " ", 
-            RowBox[{"(", 
-             RowBox[{
-              RowBox[{"-", "1"}], "+", 
-              RowBox[{"2", " ", "x"}]}], ")"}]}]]}], ",", "1"}], "}"}], ",", 
-       RowBox[{"{", 
-        RowBox[{"0", ",", "1"}], "}"}]}], "}"}]}], "}"}]}], "}"}]], "Output",
- CellChangeTimes->{
-  3.756461052325547*^9, 3.756461104280448*^9, 3.7564611562637453`*^9, 
-   3.756462576169718*^9, {3.756462954525395*^9, 3.756463091054825*^9}, {
-   3.756463122452183*^9, 3.7564631381334753`*^9}, {3.756463173751932*^9, 
-   3.7564631970682697`*^9}, 3.7564632311744537`*^9, 3.756463268375197*^9},
- CellLabel->"Out[74]=",ExpressionUUID->"be51b51d-8bd7-4009-9add-9f6f8096525f"],
-
-Cell[BoxData[
- RowBox[{"4", " ", "y"}]], "Output",
- CellChangeTimes->{
-  3.756461052325547*^9, 3.756461104280448*^9, 3.7564611562637453`*^9, 
-   3.756462576169718*^9, {3.756462954525395*^9, 3.756463091054825*^9}, {
-   3.756463122452183*^9, 3.7564631381334753`*^9}, {3.756463173751932*^9, 
-   3.7564631970682697`*^9}, 3.7564632311744537`*^9, 3.756463268378667*^9},
- CellLabel->"Out[75]=",ExpressionUUID->"5ea17af6-c31e-4e6c-868e-0cad49e30927"],
-
-Cell[BoxData[
- RowBox[{
-  RowBox[{"-", "1"}], "+", 
-  RowBox[{"4", " ", "x"}]}]], "Output",
- CellChangeTimes->{
-  3.756461052325547*^9, 3.756461104280448*^9, 3.7564611562637453`*^9, 
-   3.756462576169718*^9, {3.756462954525395*^9, 3.756463091054825*^9}, {
-   3.756463122452183*^9, 3.7564631381334753`*^9}, {3.756463173751932*^9, 
-   3.7564631970682697`*^9}, 3.7564632311744537`*^9, 3.756463268382415*^9},
- CellLabel->"Out[76]=",ExpressionUUID->"5eb77e74-e787-4b55-ab2e-93d10d425eaa"],
-
-Cell[BoxData[
- RowBox[{
-  SqrtBox[
-   RowBox[{
-    SuperscriptBox[
-     RowBox[{"(", 
-      RowBox[{
-       RowBox[{"-", "1"}], "+", 
-       RowBox[{"4", " ", "x"}]}], ")"}], "2"], "+", 
-    RowBox[{"16", " ", 
-     SuperscriptBox["y", "2"]}]}]], "\[Equal]", "1"}]], "Output",
- CellChangeTimes->{
-  3.756461052325547*^9, 3.756461104280448*^9, 3.7564611562637453`*^9, 
-   3.756462576169718*^9, {3.756462954525395*^9, 3.756463091054825*^9}, {
-   3.756463122452183*^9, 3.7564631381334753`*^9}, {3.756463173751932*^9, 
-   3.7564631970682697`*^9}, 3.7564632311744537`*^9, 3.756463268386621*^9},
- CellLabel->"Out[77]=",ExpressionUUID->"6df6066a-d441-4b2b-af69-d3c5495616d2"]
-}, Open  ]],
-
-Cell[CellGroupData[{
-
-Cell[BoxData[{
- RowBox[{
-  RowBox[{"Clear", "[", 
-   RowBox[{"x", ",", "y", ",", "s1", ",", "s2", ",", "esystems"}], "]"}], 
-  ";"}], "\[IndentingNewLine]", 
- RowBox[{"sol", "=", 
-  RowBox[{"Solve", "[", 
-   RowBox[{
-    RowBox[{
-     RowBox[{"esystems", "=", 
-      RowBox[{
-       RowBox[{
-        RowBox[{"Eigenvalues", "[", "#", "]"}], "&"}], "/@", 
-       RowBox[{"ListSubSpaces", "[", 
-        RowBox[{"Coef", ".", 
-         RowBox[{"H2", "[", 
-          RowBox[{"Coef", ",", 
-           RowBox[{"{", 
-            RowBox[{
-             RowBox[{"{", 
-              RowBox[{"1", ",", "0", ",", "0"}], "}"}], ",", 
-             RowBox[{"{", 
-              RowBox[{"0", ",", "1", ",", "0"}], "}"}], ",", 
-             RowBox[{"{", 
-              RowBox[{"0", ",", "0", ",", "1"}], "}"}]}], "}"}], ",", 
-           RowBox[{"{", 
-            RowBox[{"0", ",", "0"}], "}"}], ",", 
-           RowBox[{"{", 
-            RowBox[{"x", ",", "y"}], "}"}], ",", 
-           RowBox[{"{", 
-            RowBox[{"1", ",", "0"}], "}"}]}], "]"}]}], "]"}]}]}], ";", 
-     "\[IndentingNewLine]", 
-     RowBox[{"s1", "=", 
-      RowBox[{
-       RowBox[{"esystems", "[", 
-        RowBox[{"[", "1", "]"}], "]"}], "[", 
-       RowBox[{"[", "3", "]"}], "]"}]}], ";", "\[IndentingNewLine]", 
-     RowBox[{"s2", "=", 
-      RowBox[{
-       RowBox[{"esystems", "[", 
-        RowBox[{"[", "2", "]"}], "]"}], "[", 
-       RowBox[{"[", "1", "]"}], "]"}]}], ";", "\[IndentingNewLine]", 
-     RowBox[{
-      RowBox[{"Sqrt", "[", 
-       RowBox[{
-        RowBox[{"s1", "^", "2"}], "+", 
-        RowBox[{"s2", "^", "2"}]}], "]"}], "\[Equal]", "1"}]}], ",", 
-    RowBox[{"{", 
-     RowBox[{"x", ",", "y"}], "}"}]}], "]"}]}], "\[IndentingNewLine]", 
- RowBox[{"Plot", "[", 
-  RowBox[{
-   RowBox[{
-    RowBox[{
-     RowBox[{"sol", "[", 
-      RowBox[{"[", "1", "]"}], "]"}], "[", 
-     RowBox[{"[", "1", "]"}], "]"}], "[", 
-    RowBox[{"[", "2", "]"}], "]"}], ",", 
-   RowBox[{"{", 
-    RowBox[{"x", ",", "0", ",", "0.5"}], "}"}]}], "]"}]}], "Input",
- CellChangeTimes->{{3.756456910325953*^9, 3.756456911485878*^9}, {
-   3.756457065393977*^9, 3.756457130704842*^9}, {3.756457178963238*^9, 
-   3.756457223203022*^9}, {3.75645729613369*^9, 3.756457333093988*^9}, {
-   3.756457372152726*^9, 3.756457478694639*^9}, {3.756457658210804*^9, 
-   3.756457660387308*^9}, {3.756457711409144*^9, 3.7564577816200113`*^9}, {
-   3.756457881891737*^9, 3.7564578884936943`*^9}, {3.7564579385243483`*^9, 
-   3.756458004808157*^9}, {3.756458046281458*^9, 3.756458048865675*^9}, {
-   3.7564580839009333`*^9, 3.756458102168103*^9}, {3.7564581450655203`*^9, 
-   3.756458208920618*^9}, {3.756458267009261*^9, 3.756458294052622*^9}, {
-   3.7564583290316896`*^9, 3.756458428297187*^9}, {3.756458855368375*^9, 
-   3.7564588581547728`*^9}, {3.756458892060815*^9, 3.7564589405618467`*^9}, {
-   3.756459077469171*^9, 3.756459183708806*^9}, {3.75645923963918*^9, 
-   3.75645924531663*^9}, {3.756459275720622*^9, 3.75645927833908*^9}, {
-   3.7564593148279123`*^9, 3.7564593317472267`*^9}, 3.756459602885786*^9, {
-   3.756459789695437*^9, 3.756459827876498*^9}, {3.7564598914279413`*^9, 
-   3.7564599186397867`*^9}, {3.756460027633892*^9, 3.756460050436306*^9}, {
-   3.756460144948061*^9, 3.756460145388665*^9}, {3.7564601993688803`*^9, 
-   3.756460199450418*^9}, {3.7564602359505167`*^9, 3.7564602436489277`*^9}, {
-   3.756460315927175*^9, 3.7564603294688253`*^9}, {3.7564605357754107`*^9, 
-   3.756460544057013*^9}, {3.75646057805752*^9, 3.756460635423991*^9}, {
-   3.756460905331465*^9, 3.7564609101990747`*^9}, {3.756461041354941*^9, 
-   3.7564610487404137`*^9}, {3.756462907993943*^9, 3.756462910854012*^9}},
- CellLabel->"In[78]:=",ExpressionUUID->"410501b7-6de2-4a82-a1d2-385e66e5b7f6"],
-
-Cell[BoxData[
- TemplateBox[{
-  "Solve","svars",
-   "\"Equations may not give solutions for all \\\"solve\\\" variables.\"",2,
-   79,2,33223559986653868476,"Local"},
-  "MessageTemplate"]], "Message", "MSG",
- CellChangeTimes->{{3.7564589171791058`*^9, 3.756458958036316*^9}, {
-   3.756459085229855*^9, 3.7564591002891083`*^9}, {3.756459133568548*^9, 
-   3.756459167613634*^9}, 3.756459200912953*^9, 3.756459245812299*^9, {
-   3.756459296222108*^9, 3.756459339929934*^9}, 3.756459603862586*^9, 
-   3.756459919188964*^9, {3.7564600621012173`*^9, 3.7564600912349253`*^9}, {
-   3.756460146352265*^9, 3.756460164720677*^9}, 3.756460210713407*^9, {
-   3.756460244409607*^9, 3.756460267877121*^9}, 3.7564603178714542`*^9, 
-   3.756460544583508*^9, {3.756460580412614*^9, 3.756460636129538*^9}, 
-   3.756461052862645*^9, 3.756461104758013*^9, 3.756461156674327*^9, 
-   3.756462576227322*^9, 3.756462911613645*^9, {3.75646305223693*^9, 
-   3.756463070123383*^9}, 3.756463127368025*^9, 3.756463231636546*^9, 
-   3.7564632684671288`*^9},
- CellLabel->
-  "During evaluation of \
-In[78]:=",ExpressionUUID->"db85290c-cb69-4394-bc83-be8c581fbbcb"],
-
-Cell[BoxData[
- RowBox[{"{", 
-  RowBox[{
-   RowBox[{"{", 
-    RowBox[{"y", "\[Rule]", 
-     RowBox[{"-", 
-      FractionBox[
-       SqrtBox[
-        RowBox[{"x", "-", 
-         RowBox[{"2", " ", 
-          SuperscriptBox["x", "2"]}]}]], 
-       SqrtBox["2"]]}]}], "}"}], ",", 
-   RowBox[{"{", 
-    RowBox[{"y", "\[Rule]", 
-     FractionBox[
-      SqrtBox[
-       RowBox[{"x", "-", 
-        RowBox[{"2", " ", 
-         SuperscriptBox["x", "2"]}]}]], 
-      SqrtBox["2"]]}], "}"}]}], "}"}]], "Output",
- CellChangeTimes->{{3.756457481670076*^9, 3.756457501576932*^9}, {
-   3.756457662160788*^9, 3.756457676664591*^9}, {3.756457713422348*^9, 
-   3.75645778463975*^9}, 3.756457889745634*^9, 3.75645810574946*^9, 
-   3.7564581561252203`*^9, {3.756458188704734*^9, 3.756458209691869*^9}, {
-   3.756458269855393*^9, 3.756458294542178*^9}, 3.7564584017929296`*^9, 
-   3.7564584395145063`*^9, {3.756458917239855*^9, 3.756458958085984*^9}, {
-   3.75645908525062*^9, 3.756459100360383*^9}, {3.756459133587274*^9, 
-   3.756459167597069*^9}, 3.756459200876762*^9, 3.756459245803225*^9, {
-   3.756459296211677*^9, 3.7564593399224873`*^9}, 3.756459603848732*^9, 
-   3.7564599191778*^9, {3.756460062239423*^9, 3.756460091259613*^9}, {
-   3.756460146346614*^9, 3.756460164716612*^9}, 3.756460210681127*^9, {
-   3.756460244379775*^9, 3.756460267872299*^9}, 3.756460317864443*^9, 
-   3.756460544544866*^9, {3.756460580368079*^9, 3.7564606360851173`*^9}, 
-   3.7564610529058332`*^9, 3.756461104797967*^9, 3.756461156725276*^9, 
-   3.7564625762843103`*^9, 3.756462911688354*^9, {3.756463052301784*^9, 
-   3.756463070193972*^9}, 3.7564631274293537`*^9, 3.756463231759986*^9, 
-   3.7564632685333633`*^9},
- CellLabel->"Out[79]=",ExpressionUUID->"4cff916e-930f-44e7-9100-26c43bbdd9cb"],
-
-Cell[BoxData[
- GraphicsBox[{{{}, {}, 
-    TagBox[
-     {RGBColor[0.368417, 0.506779, 0.709798], AbsoluteThickness[1.6], Opacity[
-      1.], LineBox[CompressedData["
-1:eJwV2Hk8VF8bAHC0oIWIRIskypKEqMhToZKEsivK0ktkS6EIRaFCWZM1Sin7
-vuQg65iZe8eabSZCCqHCT7b39Nd8vp977j33bM/z3BGzdrlgx8HGxmbNzsb2
-7/es3Sij+ruWunDhPn/fMn60WkPElSW8BwZ8c4oMfgYgxeS4hAJhJfDdneUd
-Yx6ChrbvCfCUVAc7nvLPGzaEIx1aV36isCZ8DNP2Fxp/hvY82fF6RVQb3hjo
-Zn3mikKLZ21ir0qeh/3NBuL+09HIxHbu43NhQ/CWbNB9ZPgC1WmIlHxKMIZv
-6yz4Wvvikbz4sdw/omYwu56xLVcvAXEN3n9lLGkJ909vghW2ZNR/4JHGU2Fb
-OHYke0/811QUlby1WsLCDiZG3YwZLq/QWd5MtaqEa9DoOqvwbe4VKv5JPTQp
-6gD6AVu6lhbTUFgW/z4DSWf42mnVNTbwGqUI6j0MFfaAG8bLKqFq79BdWmyd
-cbkHeOsdvZaX/A4ZB33hELe4BQ1b9Lj12DPRhhk3v4qE2/Afw7pCvjoTebVH
-eY2LekMkz+23EnIfkEFkz/XzkvdgXD3rwEB7NpLVEX8n0ngPMh7/fO4skYO4
-Vjl9G/mfH0zy/ujbdSsHWZUt5yFDf4jQi6Wu5c5FglIRcqYxAaCxI6PMMDUX
-BXAV7A0RDoQTH6y/xtbkIenTz4LzXbET0y/v/ZaHWoNcvvc2BoLHQTkR6w35
-aM8q2fdyt4Ogpkfr2oBRPmpYSpdrb30IUT+q9FWH89GG3zGHRJ+EAGdZ1OaG
-2QIU139Ho2g5DNr2y7ItThShE9vN0plG4TATsk+nbn0x+mGusoYrKxx4aKsO
-WUkVo53j3jZZ+yPg0IBmIa9tMXJxUJZg64uAWkUGp3NXMeK3zXn7+vBzWK84
-UJNRXIJMzVJzpqajYHVe+fok8zI02Wu47pVINDReewQS7mXooSWX3UWNaPBu
-flH6PKQMFdi4iBRHRQNy948UKy1DPM7Hgu6qxMDrXmHDLQLlqP5+t/la31hg
-m79xPbKxHCl84Fu7nSsebgkduWa9sxKtXwm4dHpnMujLB+RxRFehOAcTS9lT
-yVD4mcPMIKMK7WmXvcLnnAzrzir2PiurQurvumx6PyZDpchE22h/FSp7F1NU
-IpcC7CazGtMSCE1cHK/UoafAma0o1r8AIaO3sS03N76CQkX7tFjraiRh8HP0
-0+N0+Jsa7WhnU4M86Ucg7s87WPYx+mJt8AkJFfIx2dlzwH1xV7rpQB0qHtSg
-Emr5QBebWvpm2YBqryduMxsvhL8KmxPjMhvRjOQx3qwbJXBsza2yl6gJccy/
-37RNohyuGql0GtOakfLKleKL2ZWgo+JzKiGHgqiBSvQGaQSbjCSyuz1bkGjE
-2Py7n9UQP/tVcY0qFY3NsZgd8rXwaLlFbqafitJ/VFB4wj6BRUS40ta7NMSz
-I2NyaKgOtLndhEkOOnriUHQtZU8DVLTpiWa70dHs8fdD9n6NoFARKvO0m44q
-08deegY2gt2C9tPpHjq6zyV78WFII6igxnVGfXTEQ36oSYtsBMovbzNhFh1J
-WmUnMTMagenIpx07REfGvnmmhmQjOPn7PrafpKOishIqiDVBvAtyvLqaQB4K
-dYVbPjXBRfbEqnwZAl1T2pXyrKkJbpcwVuZkCWSq7PN4A70JBOIUj6nJEUj1
-qJI1R3cT6FksfaiRJxDHyXTenz+bwKddyLb6EIHCDQKv14s0w9NmH52nQKBM
-V81dHu7NsFgUyrC7QKAE95T1k57N0Mx7qy30IoGeeizOOvg2g0fd6Y5sQwK5
-ehXSrIKb4dmKYPdvYwKp+O+5q5PUDNB0ecjNgkB14as7d1Pw/ez3xNRtCcTK
-rnvMEKOApvvlSaFbBCInVo8r7KXADTEZm623CVQtq3UuSpYCQQlnvgp5Eigl
-s36DiQoFel4SXALeBLJ+0/C07xw2NWKMzZdAI4lN4d88KbCl5414ViCBJp5Q
-I5doFODT0J3TiyQQs2XDH8s2Cmz3F9ulEEUg+jpdw+rPFJhuWjDZHE2g7GCa
-wIOvFFCe5p9pjcHjCaRHc81TgPv5/MipeAL9uUvGbt7TAnQtSjl7KoEWrre/
-lLrTAm0OVW8+ZRHIUPnyMzm/FmANaRTcySbQB/aRh4qBLaBpsHVKPodAlnFz
-bsfCWiD8x/Df+FwC1dSLnDF41QIi7bHGdgUEerTr6h8vSgtEcqoptJUSaHPn
-xLkmESpcDFXu3PyJQE6pt0/SRKlQXuW8Ng+7zmlFpXUPFZyHo+x16wh0exWf
-eJ8cFUqCemof1BOoW15pfvIkFWY7I8mRRgIlP77zWsiRCoYNdPOHVALJnOBc
-vlZBhdqWEE+ZDgLlZr7f+7maChpenGvKsZUE9A20G6jwROFr6ulOAql9i0uX
-YWAPj3Bf6SLQ+afSOlMjVPjE5h0V1E0g927dOG9+Gmz30E1K6yfQ7MlfNT+E
-aLBQfGmvOJNAdz/EjFnsoMHhS8HVqdiBfix19X00sLO+Kp7AIlCMhNswhzoN
-ON/qfggaIFCZW5TCEwca5K22bpcZJpB67+FLS840OPpJwzYBu1azP8jZgwaZ
-Fj9WbxghEEVIslvfjwZaJ7O8RrH7Ppb4CUbTgHpGSCZmlEBs63qpSdU0SGek
-fKobI9DpV2L/yxOiw7VuHTaXaTzeOB7Jhu104PfP1azE3hW2MNQjRoe+/ttl
-XL8I9Ne7w3q1LB3M5kEpGTvLIMTS5DgdVpqsXWp/4/VinzZasqfDse05bIMz
-uL+5fgF+Zzp0/G7Q3T1LoPFxSpvkTTpEy8W0XMVu+JxuoO9Lh8h1zmZMbO9c
-U920Z3QYePqwijaHz4dVtaZ2OR2mjxzPD5onENUoa5UlosOVpz83lGGX6sTX
-utfRIZczPm4M+7mKx/EEOh2oJXMnz/8lkBbvPrXJQTo8CDg0xL1AIIU1ggur
-RumgOqvUqIy9c4G9fOsEHbYFne+1xv5vpFfl5Bx+PvTHlGK/rwpXjF5PAG9n
-rYX5IoHiCn1+vdtEQOTRiUZ/7MBMh7wqQQKmKs7avcG2jNE4MCpKQLZjpuIk
-Np/znLSqEgHOTmdEPZcItGwz9F3vCAE8m00FY7F/mDHe2qoTwD6Wo1aMXaf1
-XjLsDAGfw06I/sL23GG1e+ASAeVd0kpXlvF515c37rtKwFzgA2Vv7PMP2EO7
-rhFg1qfu/gxb8nvaNM2VAI3goWiEzb/9lkTzLfz8w62+HdhL50+Z1d0hQPuM
-VPIP7PbC0eryQAIYqcJh/Cs43nwr+1MUgsfXWmQhgf1e5PG+vDACRhVqrFWw
-7/vvj8iIw/3lS+8ww3YuWP70KpEAE63HpD222Qgxl/iKgIJJq4+e2PLn3K2i
-PhBwtc1BIxJ7u59GZHgeAVwbU/uSsTnzBRpDi3F7S/2c99i/hob/BlUQ4JHu
-VVGMzRQqkQuoJuDbexH2GmzK2WBrn3oCjimp+FOwi3zNYjwpBCj/pB9uw07J
-laa4EwSI+QxK92I/+bqwdKOdgH43d+NBbK8ttIMO3diGfhWj2DbaSXa2TAL2
-JHCb/8Q+7+PywuorAVq5fAq/sY/mHKeZjxJwbSxWYw5bcpCP3XiCALUXCWF/
-sfkEvyoZ/CJg85zo5iXsxdOF9ufmCPikuJuxjD16Jyjh9CIBpS5pTSvYP4xl
-7FPZSJiqTJv/5ytTmzlEV5GwsFPc9p87QxZfJqwhYSlUjOvf/Triw4dEuEh4
-8y1peOHf+lTSiNh1JKhvfLn4H7aycbGD4EYSEusFdWewP0wmrYrkJWEfladr
-Cnt3yKPETfwksGhB8WPYcbtdVcIESDjrcCd2GJun0pSxXoiEULlxGhM70OiE
-Y4gwvp7cc6wLe/6n1BrO7SRQ5bS+0f+tdzB/cuBOEgZOyFDqsYfEFg5ziJHw
-Xe7JSAU2aUh1WpIgQfptRctr7FM/C9fe3UfCbFxw1AvsykeJKf9Jk9ArS4t5
-gp1R7tz++wAJJ+zLTrv+2x+GJs5uCiTQ2axmr2A/nwCuSSUSnuz0Yupj39vF
-p/bjCAkMWTYLOew/ZfMd/1MjoTXeaXIb9vWLgy7D6iTMBZ/+yIVt9LAg7YsG
-CZknNNZ8wftddtxofZcuCaP39p4Kwi41PIdC9UnQHKUEXcfW+HjypvpFErwW
-PvSexzYPO9D72pSErmfiFAHsEHnu9x42eH7VIvOi8fkUeLFiue8aCXbqw69u
-Yqewz/L32ZNQW38lUx+7tHXwjoYzbm/YtMCJPeJReZbfm4T3CWxvHXF8cO/P
-X66/S4JrwKmzJ7GXtN7le98jwb7mJcdWbAGhGJGBByT0I7uiahyPNMpcfuSE
-kfBQe6M4J3bK0u5Q3XQSf+sIbrPH8U/2mrA6ewYJqmlu2+WxS+i8vwrfkXDz
-YLzi3H843ycvmm3PIWH1TdW0+9hLJzqlxspIiKuTfxSG4635w5DmYIKEXUOH
-Lt/B8Xvkp5+vWisJu3N6ShWx3UxuH5xqJ+FK2W+p8T8ECt5n88KkB7/PZ4dz
-5tjFFDUHyWG8X4cLn8n8ywe8U1x1f0kY1/5P6NUUgVo/hj7SXiIh9rTk/QvY
-z50k1hIrJCTJF4lyYPNTzFf1rGZATkT/H8tJ7KD6pUkeBrDnv1/L+5NAmxbi
-f20TZ4CDU1rtGZy/yHeH3FIlGND6+rvV+A8CRZiSk5L7GNAyuE8+HJu3eM3E
-wf0MGDh926H1O97vbq7fTqswwNs5UF0P58MN37T6buowQJaYc9yN8yk1+ov5
-vC4DRrqvHiobwvFD8273PX0GxIPuQT3s9a9yO0OMGKCyNrja6yuB1l3exki2
-YsCf6+9Ua3G+5mqbqm+5yYBC51OJcji/r0Yvc8QTGJD/4A/hhOuHHjXNM6wk
-BjSKWXUwcX2RUz7+JT6VAYNZAqN62ObFx/j5Mxgwb7P/0IF2AuVlsTzY8hlA
-imY6DTJwfkkQP9rfyICFXfu1ttHw/vJ+XxfzmwEuVk+OdtYSKGzu4uULs3g8
-Uv10KWybW4szG+cZkDJT4OxT82/8unuDlhnwebyQ3FlNIDv7yZCb3K2gEH5m
-u+lHPN8minr6oq3QpfH4U0IJgRyVKrq5dVpB9MapvhvvcfwhOz6U6raCYUWm
-15tMAgnemPL7n34rcI5Y7mW+IxB6LSFZb9QKX1RdK86+xesvFOHuf6UVopka
-lVtfE6hi3nb93K1WIDpaNgUn4flEPMeGUlpB2uBpQEEEzjfa1ilVs61QPWa7
-5Yg7rkdkxdRhvhV6R6v2nXYjUBXPl1600ArF3X3/M3TF6992WaiGrQ1+bNjq
-5OSM48Fls7BP69ogjeYS+vw6rpfc9X2adrbB25KHG0uscft4ddPWU23gHXgj
-5Qqu52fGRDaNxLTB4zl9g4MHCBSV+K0x4UUbZDG+zkztJ5CiXqHfxYQ2cBIs
-fJmDvyfc8nUnq1PbQCDp2Q8paVxfe/nTX35og56U3mf8EgQaXjPyxKC2De7d
-FxsrECFQh2ge98eJNogNXhg+tAbnq4unV0VptoNyf+2DA1105HcmKLlwpB2E
-rR70HbhNR2L9Zz+nBXVAqXZLwhsuOjqqEhglrNAJrqVuTwb8aejSTmKeva0T
-1mrsDfSfpqIZytNB14AuqC+95VhykoriVlt6XNjzGdx9KzXXPWlBm5lFrzjq
-PsOStFeGcj0FrfENMDzi1g2h9qqkbUczYntnmTPI3wMWhvl/b/Y1Iff4nKf8
-tT0QJcY+VZvTiD7KBHPxOfeCFb/oMx/bBsR31l32Pk8frF5snLvOXY/69pNt
-3pV90B4sl+9s+QnlJsGeIct+6PlOnTGNrEG/7/zmvHq1H1ICT4XXPa5ByiYZ
-Y/02/fDTQtNTJrAGVfDyFnTZ94NzipbImEcNavBnnmhx74erybeX5I1rUK+1
-r1X+w354uUswnCFUg9burYj3z+6He1Ol+w7FVqPLOcp8O5b7Id88R/YeN0LF
-5v/xkGxMeKoZSVmaqUI8a8s3PFjFBDfTQYMbg1Wo+tIxru9cTBi/VJ26raIK
-7V6nuVK4mQmDKuda8xyr0IitwcQ5KSb46By3zWj+iJxFnJp9DJnAIZKQXuhZ
-iRrq9zceMGHCa0e12fGrlUjUbbJu0IwJ+W9r7Tadq0Rko3v1GSsmlOcF9wrt
-qkQKt7xLBK4zIW+xOkW8sQLNEQ9ff/BjQqK9Y/nKpgrkH5Qa0JfJhIkXTadE
-n5ehjZ6cZ69mMYEm7ag6c6cMxdvf4B/JYYL2yiWefJsyVKBzJG2ykAkfEp8d
-ZimVoRE+Rh0HYsLaNoGilY5SpJPExiXVxgS5UZaq4OZStKXEKuzWAhOyWQPH
-ttwuRmlv643/LjHhojyH426LYiQfLyPqx8aCk7VO1tzHi5G271xO8BoWsC1c
-CLXjLkY+GuGMl7wsuPBFdPpUfBEaJKoEasVZcFT7LtpdWIiyRne85DnHAg6X
-nLKe2nwUnBh0hXmeBQG+u1TXJOUj2wsTEtkGLLgtWerG8spH2ysrc3VNWFDu
-Btov9+ej0HCLhifWLOh8Mc81+zwP2Su/mF7nzYIiDmMxHp1cpDnGVtJzF193
-PS4mvCsXiabY+2TeY8EbrbQdBt9zUCf3Yc6zgSzQS9jFH3I4B2n1d24PCWeB
-zCbDwqHmLLQ7UOAM5xsW/HduTZJOdiZaPuyzsestC2ojxVWHNDJR98TX1jfv
-WRD3Rv1IQdc7FGFScPlUHgveXh3gjp1/i1akL9wMqmRB6gnvmOviGaiHVXbY
-CLEgI82hoyDjDSqOElveU8uCPu+jFEWpN8h5eSq4rpEFx61803nEX6M+RnjS
-qjYWHDMN8doz9gqVPpyzaetggde4+UOpC69QlKqVVNpnFmQ+u0kZLUhFOq/l
-Ck8yWTCXHWkoZ5eCJM1jvPkHWHBuXsfwyrVkxMG7rD74lQXKNqrLCdOJqNyL
-1hzwnQV3dX6P5VPiUcz+Q+EG47i//dwyHZteILfBBEOxSRZwetp29h6KRedi
-V4tMT7OA5k1GbDkYjfadc2JV/8HrTeHgkp95jlazt6dHzLFASuOybYljBPpS
-pHr9yl8WPD16w7mHEYoqr6cdkF9igYd0gCB17j6KFV0/s7LCglPXF/3+/R/8
-fwaAERI=
-       "]]},
-     Annotation[#, "Charting`Private`Tag$2390#1"]& ]}, {}, {}},
-  AspectRatio->NCache[GoldenRatio^(-1), 0.6180339887498948],
-  Axes->{True, True},
-  AxesLabel->{None, None},
-  AxesOrigin->{0, 0},
-  DisplayFunction->Identity,
-  Frame->{{False, False}, {False, False}},
-  FrameLabel->{{None, None}, {None, None}},
-  FrameTicks->{{Automatic, 
-     Charting`ScaledFrameTicks[{Identity, Identity}]}, {Automatic, 
-     Charting`ScaledFrameTicks[{Identity, Identity}]}},
-  GridLines->{None, None},
-  GridLinesStyle->Directive[
-    GrayLevel[0.5, 0.4]],
-  ImagePadding->All,
-  Method->{
-   "DefaultBoundaryStyle" -> Automatic, "DefaultMeshStyle" -> 
-    AbsolutePointSize[6], "ScalingFunctions" -> None, 
-    "CoordinatesToolOptions" -> {"DisplayFunction" -> ({
-        (Identity[#]& )[
-         Part[#, 1]], 
-        (Identity[#]& )[
-         Part[#, 2]]}& ), "CopiedValueFunction" -> ({
-        (Identity[#]& )[
-         Part[#, 1]], 
-        (Identity[#]& )[
-         Part[#, 2]]}& )}},
-  PlotRange->{{0, 0.5}, {-0.24999999703820874`, 0.}},
-  PlotRangeClipping->True,
-  PlotRangePadding->{{
-     Scaled[0.02], 
-     Scaled[0.02]}, {
-     Scaled[0.05], 
-     Scaled[0.05]}},
-  Ticks->{Automatic, Automatic}]], "Output",
- CellChangeTimes->{{3.756457481670076*^9, 3.756457501576932*^9}, {
-   3.756457662160788*^9, 3.756457676664591*^9}, {3.756457713422348*^9, 
-   3.75645778463975*^9}, 3.756457889745634*^9, 3.75645810574946*^9, 
-   3.7564581561252203`*^9, {3.756458188704734*^9, 3.756458209691869*^9}, {
-   3.756458269855393*^9, 3.756458294542178*^9}, 3.7564584017929296`*^9, 
-   3.7564584395145063`*^9, {3.756458917239855*^9, 3.756458958085984*^9}, {
-   3.75645908525062*^9, 3.756459100360383*^9}, {3.756459133587274*^9, 
-   3.756459167597069*^9}, 3.756459200876762*^9, 3.756459245803225*^9, {
-   3.756459296211677*^9, 3.7564593399224873`*^9}, 3.756459603848732*^9, 
-   3.7564599191778*^9, {3.756460062239423*^9, 3.756460091259613*^9}, {
-   3.756460146346614*^9, 3.756460164716612*^9}, 3.756460210681127*^9, {
-   3.756460244379775*^9, 3.756460267872299*^9}, 3.756460317864443*^9, 
-   3.756460544544866*^9, {3.756460580368079*^9, 3.7564606360851173`*^9}, 
-   3.7564610529058332`*^9, 3.756461104797967*^9, 3.756461156725276*^9, 
-   3.7564625762843103`*^9, 3.756462911688354*^9, {3.756463052301784*^9, 
-   3.756463070193972*^9}, 3.7564631274293537`*^9, 3.756463231759986*^9, 
-   3.756463268720327*^9},
- CellLabel->"Out[80]=",ExpressionUUID->"8e9365d4-6d7d-4a93-b35b-adbf4f832fec"]
-}, Open  ]],
-
-Cell[CellGroupData[{
-
-Cell[BoxData[{
- RowBox[{
-  RowBox[{"Clear", "[", 
-   RowBox[{"x", ",", "y", ",", "s1", ",", "s2", ",", "esystems"}], "]"}], 
-  ";"}], "\[IndentingNewLine]", 
- RowBox[{"RegionPlot", "[", 
-  RowBox[{
-   RowBox[{
-    RowBox[{"esystems", "=", 
-     RowBox[{
-      RowBox[{
-       RowBox[{"Eigenvalues", "[", "#", "]"}], "&"}], "/@", 
-      RowBox[{"ListSubSpaces", "[", 
-       RowBox[{"Coef", ".", 
-        RowBox[{"H2", "[", 
-         RowBox[{"Coef", ",", 
-          RowBox[{"{", 
-           RowBox[{
-            RowBox[{"{", 
-             RowBox[{"1", ",", "0", ",", "0"}], "}"}], ",", 
-            RowBox[{"{", 
-             RowBox[{"0", ",", "1", ",", "0"}], "}"}], ",", 
-            RowBox[{"{", 
-             RowBox[{"0", ",", "0", ",", "1"}], "}"}]}], "}"}], ",", 
-          RowBox[{"{", 
-           RowBox[{"0", ",", "0"}], "}"}], ",", 
-          RowBox[{"{", 
-           RowBox[{"x", ",", "y"}], "}"}], ",", 
-          RowBox[{"{", 
-           RowBox[{"1", ",", "0"}], "}"}]}], "]"}]}], "]"}]}]}], ";", 
-    "\[IndentingNewLine]", 
-    RowBox[{"s1", "=", 
-     RowBox[{
-      RowBox[{"esystems", "[", 
-       RowBox[{"[", "1", "]"}], "]"}], "[", 
-      RowBox[{"[", "3", "]"}], "]"}]}], ";", "\[IndentingNewLine]", 
-    RowBox[{"s2", "=", 
-     RowBox[{
-      RowBox[{"esystems", "[", 
-       RowBox[{"[", "2", "]"}], "]"}], "[", 
-      RowBox[{"[", "1", "]"}], "]"}]}], ";", "\[IndentingNewLine]", 
-    RowBox[{
-     RowBox[{"Sqrt", "[", 
-      RowBox[{
-       RowBox[{"s1", "^", "2"}], "+", 
-       RowBox[{"s2", "^", "2"}]}], "]"}], "<=", "1"}]}], ",", 
-   RowBox[{"{", 
-    RowBox[{"x", ",", 
-     RowBox[{"-", "0.5"}], ",", "1.0"}], "}"}], ",", 
-   RowBox[{"{", 
-    RowBox[{"y", ",", 
-     RowBox[{"-", "0.5"}], ",", "0.5"}], "}"}]}], "]"}]}], "Input",
- CellChangeTimes->{{3.756460797461627*^9, 3.7564608637775497`*^9}, {
-  3.756460947372512*^9, 3.756460950210264*^9}, {3.7564610224148407`*^9, 
-  3.756461023352928*^9}, {3.7564625934761257`*^9, 3.7564626725544252`*^9}},
- CellLabel->"In[81]:=",ExpressionUUID->"d2e61497-cfc2-48d7-9b6d-2c510de52f4d"],
-
-Cell[BoxData[
- GraphicsBox[GraphicsComplexBox[CompressedData["
-1:eJxll39M1GUcx09llRQuWalDTfojupWFYUfimt8WZM25PByFkmMNi61oozFt
-ndnGj/gaONt0N9oK0XPRppUEkdh17CQEAUGRgLslkNJh/hixbsLQ0uu6Z6/P
-sQf/ca+9n+/7Ps/z/Tzvz5dH8wo3vz3XYrHkzLFY/v9/c+viwj3BY8aa+G9z
-ffZz3itTR+1O3ynh6X/3tZnBLuHyOWkHPWaf8Gcx3/hsTp/w5/cuj69zDQnj
-X7r9nZ9tzjPiD+MP4w/jD+MP49/dmLQk7Cv+MP4w/jD+MP4w/k8+0HEtYGsU
-fxh/GH8Yfxh/GP9pd+w+M/iF+MP4w/jD+MP4w/h7FBv4w/jD+MP4w/jD+C9T
-+xF/GH8Yfxh/GH8Y/9PqfYg/jD+MP4w/jD+M/y7VT+IP4w/jD+MP4w/jv0rd
-B/GH8Yfxh/GH8Yc9Q+sergxWGsOR99HlXTb/9boC6+/C6I9HzvO06DD6aGS9
-W3QY/VqEj4kOo1si/2o86DD6WbXeQIfR+9TviQ6jr1D1ig6jD6j9ig6jk0fo
-MDp5gg6jkwfoMDr3GR1G5z6iw+jcJ3QYnfuADqPTz+gwOv2IDqPTT+jwC82r
-bzt9h40rzbvPhELnvTmf/vRm3NiwMPqIYgMddv9ZuDLV2ST9CHP+E7eW7o0b
-axMdRld91Cs6jB47r2itI25AdBg9/p7AjmDCb6LD6A2BO397zAbZz7vTo+P2
-3Fbh3Xfb89IdPcKvlA7cSOj6Vdhe/nKS0+cXZn/0H8x58nucT+v1y/l1Lo8w
-++d5mOepj/U7/smydhV0CHM+PA/zPPth/S/F1a/mpl8Q5vx4HuZ59s/67rIF
-FT77oDDny/Mwz3NerO83i1vtuReFyUvOk/OByU+Y/cPkKcz+YPIVpn6YvIWp
-DyZ/9XroL+qtzL84edzVLfWgUy869aBTLzr1oFMvOvWgUy96zVTFJmsomncw
-+QaTZzD5BZNXMPkEk0cw+QOTNzD9wPuOcZztsIX7lPOEOT+Y84I5H5jzgIMp
-j7ly9zQYd29kDCZYer2fHFzZsmAq1hjZWJvne7BbeMj6fpOtv9NbeeiDNlf4
-frG+ujZnrTN8X2D/a4ey08P9D1/asvCAJ9zP8PU3yrpt4fyD2a/+e9aaPK8t
-q004addTDzkXt8p6XQ+MGGusyc3R+qsGLgd+PCnrdf2vuTv/6Cyoiz5fdDg1
-3fG1rNd1e+LRrXFjJcL+FRGW96Xr7crPgHuVn6yfpat6hftVvbJe1x9R5yGc
-qM5D1ut6v3p/woPqvGU9ujdx7MvMwcPGbfV+DN4XTL/ApdXuprjwfYbpDzgr
-q8XuCN9nmH6BU77rG7WF7zNM/8DPf5+xvC58n2H6Cc744US2NXyfYe6L3s/6
-98x9qv8ln1jPfYK5TzD3CeY+wXwf4M/vkycweQKTJzB5ApMnMHkCkycweQLr
-38Pcf+qFef/sp2Vr6Ra/P8pdjRM3A4HhWTrnjw4z3zkP5jXM/IWZpzDzEaZf
-yXOYfILLJuftNxs6hPmeh/U86VnfMh6YbBHm+17yScuTp1fdcZpFJ4T53pe8
-0fKkpHai2gy6hPn+h/U8qX8i9VIotF+YvwckD7Q8Sbh6YF36rXph/j6Q+63l
-ifnSknKzyCvM3wuwnieOC+fGAjvbhfl+gfU8SS5eWGGm9BhFVYMvLjVnzxfe
-H/ycWi/M+9uQuWmRZca82Za9em/ww+i8OXn8/uJgZ3TenKr/2F0wY95Qj+5P
-P8Alan/Cej/oOv0BV6nzFNb7Q9fpF5l36v1F69H6RdfpH3hc9Yvoev/oOv0E
-b1e/J6z3k67TXzKP1H6F9f7SdfoNblPnLaz3m67Tf/BHql+E6T+eRyePyDv6
-k7yKSZu/KPNIdJ6RV6ynH9GdR66GEt6LzjfyjPX0q8ynrHy3OWPekXesp5/R
-t2X7b4ZmzD/ykPX0O/pbORuSHTPmIfOZ+8D+YOYzzH5g5jNM/TDzOXo/Vb0w
-8xmmPv1+pn21/llr4XnhZxTL+0SH0f8DHSNyaQ==
-   "], {{
-     {RGBColor[0.368417, 0.506779, 0.709798], AbsoluteThickness[1.6], Opacity[
-      0.3], EdgeForm[None], GraphicsGroupBox[{PolygonBox[CompressedData["
-1:eJxVlld01kUQxWdpIcEIIYEEQqhpEAihCCkgSO+9igiCihiKFRQUFBQLCqJI
-DdjLm7333nvXo0/23p7sc8/8csCHe3b+++3O7ty5O/N1W7J6xqomZjYlmTX1
-cajDTctwNDj2O1Y6djmudSxz7HHsdix3HHQccKx2DGNftqONI9OR5WjraOU4
-wnEka1o6WjNq3T7HXke9Y7Sjg6OLIwcf2t/Zke8oADn4bodf+WvPqPNHOnLx
-1RE7z1HEuny+s9lfyLf8dWLUumNYk8ueNpzd9TDf/R0Vjt6Osdy9xNEdv/LX
-g1Hnr3EMdvRzlLJe/sod3djXk1H7ejEWO8bju4LvIrjpxl0KuUcJvisdZfge
-wG99HFWcId8T8af7DOR37TuKsS93VpzVfJezfxDf8jcZH4PxUcrZZcSnO67j
-HjWOTZxRZ5H/leRbOpNOpEXpTlqTVqRHaU16kO6OttBVJnlpzW9tyVEGuc22
-Q5rTt/Rbz74txDCEs3PwlQ+vRcwVMKf90kaeHdKcvkewRmfnkosO/C4fnbhH
-nh3SYiHrGjWn7+H4UFwbyEetYxT30RkT4Fu5G2Ohg87s7w7PjZrTdxdyUUIe
-yvhu1FZPfpM2KthfzrpGLZYTRzH7OrJO/sbhp5iYu3KmfEkz/dgvnVTir4pv
-nTmAdX2IV9+TyEsV96i0/+tyIPsH8V3K7/L3qWO+i2eqhd6q8b8JLrV3moV+
-WlhooA4/Uyy0IL8zLeqa8jaD3Cgvcy3qi2Kdb1GzFO9si3qh/M6y0IRyOd2i
-tmZw5gz8zCGvBZwznTWLLN6keDsWfsXtQov3L16PhyPxc4LF29O7O5HYFNcC
-i3qk3C4mtkHcRdzofc2z0JD0c5yFtnoRx0xiX+I4GV5GsaczHMwm3hHEo1ik
-2xryOBaOunD3BdxnHOc11p+FxDWB2KrgdS48D4fTtsS6CH5OIn7FfopF7UjE
-txR7J7y0gF+tUT04nT2Jb9WZTHhaQry7WKM+eSprmsD9Yvg8g980vwdb/XSF
-RZ2RfSbfsvdhN3Ossqh7srOwVcPO4jfNN2A3d5xmUQObs062tHQ2v2n+ILbi
-vZw4FeMV3FX33MaddJ+rOE9nXY0v+dGbWQPPa7GrGdfC+bnY1YznMK/cr8PH
-euwaxvWsz4QfxX0+81qj97kBHxsdFzC/kflaxo3M691uYt9m7Drsi1h/icU7
-H8Lvm5m/GFvrL8RnLXndgu8t7K/jjudxf81dyvxSuBbP0stWeN4K77Ib+4p6
-gjRyJfwrtzvg/DL86p7SyHbysp08NWPfNvbuIGeN2riGvGvciS2N7GfNSmxp
-RzXyM4u3ov67D//qubu483K+mxCX5pcxv5sc6tyDnKP6doBz81PUYvkf4Pa3
-Fu//AOu1Zp7P/2Tx3sRDw2F3bODOq9kjnb/vGJ1CE/XcoSl79nL/H8Rfirpw
-i3KYotbc5hia4t2+JH8p6s0ryneKOvSqo3WK9/2io3+KuqVz9nDWGJ/7wEIv
-w91+x+Id1HOHLPK7B55G+pr3LDS+Ap61VnVX9V21/Uhfc6tF7WuV4t6684eO
-cSl0/LFjYgrNzfXxOota39bt3BR1q9THxy1qc1O3m6Wo2d19fMSirrd3+06L
-PjA5xf9/6XSqj9NS6Gu6jzNS6E7cvGzBT63br1nU4Eq3n7Wo8S3czkgRk/hr
-A4e9fHzKopaLyxcs+BT32fCf6WNWip4w08dZKXQ928c5KbT8t+Mfiz5Q4XNf
-W/SGlm7fDI9N3L7Rog/1dfsbo/e4/YVFf33bMSxFnWru400W/azM7a8s+tlf
-just+nQPn//Sohd2dvtBi179h+NPC73r0acUPfBnxy8W9eAtx+8WvfN1uBNv
-/zpusOhn7zpGpKgpyn9NCg0M9vE7i774o+JDz3eRP+XuCfKtXCvunilifxre
-xbni65MixnY+3mHRD3R+SYo7PEP+lLtfHfdb9Ms8n7vd4m3Wuf29Rd99A81J
-b8+TP+XuOTQhPTwGL+JE+emXIke/Od606NuTfO4Ti5qXk+J9LiZWvWHF+yja
-lW6fRNPSs2pJVYp6Ii2Up9CD8tYtRe7G+/iRRY1/gJwpX+J1YApupZHeKXQi
-jRSk0Im0UJxCD8p/1xQa0JsrSvHuHkIT0sPDaFT6FE/VKbjq6OM9Fr22g9t3
-W/Rg8araJ24/t3jP8qnaqnqr/yOFPnevRW/u5PZ9Fr35Pyi+N54=
-         "]], 
-        PolygonBox[CompressedData["
-1:eJwtlPdvj1EUxu+VCiGEIHZoEARBkLa0ShWlWlptbapFRKQogiAIYm//hL33
-3nvvEftne4bg8+ScHz455/m+7/u99z7nnJtYMiW/rEIIoQAS4DnUiSFMI66E
-KuRVYSR5FryGhugZxPXwEuqjy4mroQZ5TSgmHwCvoAF6OnEt7NTv6BXEVHgL
-n2EcbIYn0Jfni4lLoRp5dRhN3h+OQTP0YGJPqEVeG0rIc6ESeWUYTt4HdkNd
-9EBiGpyEluhCYi84D+3Rw7QunIE26CHE3nAYmqDziOmwTd+h5xNTYLvWQS8i
-doU30Ag9k7gRXsBHKA22hy3wBcZDEmyFHrw/h5gMO6BftLN3gw9wByYEO2MC
-zyrCUPJM2Ac/YHIwj7+6x6n+TSrv3iTmwFitgb5GzIYx0Bl9WWvCKOiAvuBe
-jIBE9FHtEfKhLfqseyPP6qH3uLfyqDH6ELE7DILm6ONeK3neFH3EvVQNW6FP
-eS3keQv0CWKG92RRtB5Rb2zS/6DvE+fBXLgqH6PtXWfKjuahvFsON5RHO6s8
-yIpWM9VqiXoK/dTfXaZ9o+8SZ8Ms78XH/q56Mj1aDZP8nYxoNUz2PWWiHxIX
-wgL5FK1nUvy3A/ALpgbrkdY8P+21LIJ7vgetrZ74KZ/QG4hl8jTaTGmW1sB3
-9VW0fJJqFG1GNZvrIDfajGo2V3mv5EV7pp7ZBd9gYrCZ/w1/vNaq4V/457VQ
-D+z1NbVWuZ+lMFptdKZPwe4Q3R2l/t850dbWGgXRZkSzoTPdhvfBelMz8cg9
-lHeaqQdec9VaM5dGfivYrBfLV/T1YHeN7oh26HPBZl8z0hF9MdjdpTvhmddc
-tdYdFMkrRPNePbffPZfXuuO68OxKsLtHd+BBeBest3VnXYJO0WZFM/QfZqWd
-JQ==
-         "]]}]}, {}, {}, {}, {}}, 
-    {RGBColor[0.368417, 0.506779, 0.709798], AbsoluteThickness[1.6], 
-     LineBox[CompressedData["
-1:eJwt0mdXj3Ecx/H/315RyCirYSYho+xVspWZmz0APaSSTbQkI6VkZG8yQiIN
-JbIzXudw431en+/v3nXOFZWVnbE7GAgEzinTqOcHdeqZwr0V8LM22Bv1wh7N
-Yn7RJnuzXtoRLOFXpdsZemVH8gS/aYu9VQ32GJbyu7bZ2/Xa/qiTatQObzkc
-yzL+0E91K1dR3s/wl37rj/ZoYvDfdwUYVA/lOafyPHuyl3prrzueF9iHfdVP
-+9yzeIn9OUADtd89l7UcxBAN1gF3Mq9zCEMVpoPuxbzFoRym4Trk3skO3lGX
-jmu9t6dcyydcx2Ncwzqu5mOmMZ+pfMRVfMgUHuVKPuBy3ucKHuEy3uMS3uVS
-HuYn3Va7dnl7z0W8yQW8wYVsYxKvcR6vcj5bOYdXOJuXmcgWzuRFzmANE9jM
-6azmNFYxju84hZWcxApOZhNjWc5onmUM33ICT3McT3E833AUiziChRzJ5///
-9780KWGU
-      "]]}}],
-  AspectRatio->1,
-  Axes->{False, False},
-  AxesLabel->{None, None},
-  AxesOrigin->{Automatic, Automatic},
-  DisplayFunction->Identity,
-  Frame->{{True, True}, {True, True}},
-  FrameLabel->{{None, None}, {None, None}},
-  FrameTicks->{{Automatic, Automatic}, {Automatic, Automatic}},
-  GridLinesStyle->Directive[
-    GrayLevel[0.5, 0.4]],
-  Method->{
-   "ScalingFunctions" -> None, "TransparentPolygonMesh" -> True, 
-    "AxesInFront" -> True},
-  PlotRange->{{-0.5, 1.}, {-0.5, 0.5}},
-  PlotRangeClipping->True,
-  PlotRangePadding->{{
-     Scaled[0.02], 
-     Scaled[0.02]}, {
-     Scaled[0.02], 
-     Scaled[0.02]}},
-  Ticks->{Automatic, Automatic}]], "Output",
- CellChangeTimes->{{3.7564608583352003`*^9, 3.756460864567773*^9}, {
-   3.756460936619575*^9, 3.756460954703095*^9}, 3.756461117799111*^9, 
-   3.7564611613430367`*^9, 3.75646257720791*^9, {3.756462618595438*^9, 
-   3.756462676311294*^9}, {3.756463055647995*^9, 3.7564630736449757`*^9}, 
-   3.756463130794215*^9, 3.756463271972125*^9},
- CellLabel->"Out[82]=",ExpressionUUID->"0aff9c7c-5cd5-4b06-8d92-9f6754c6a9d7"]
-}, Open  ]]
-},
-WindowSize->{949, 957},
-WindowMargins->{{345, Automatic}, {0, Automatic}},
-FrontEndVersion->"11.3 for Linux x86 (64-bit) (March 6, 2018)",
-StyleDefinitions->"Default.nb"
-]
-(* End of Notebook Content *)
-
-(* Internal cache information *)
-(*CellTagsOutline
-CellTagsIndex->{}
-*)
-(*CellTagsIndex
-CellTagsIndex->{}
-*)
-(*NotebookFileOutline
-Notebook[{
-Cell[558, 20, 241, 6, 31, "Input",ExpressionUUID->"65d45139-50ab-4f38-9cd3-0897640d6bab"],
-Cell[802, 28, 415, 7, 31, "Input",ExpressionUUID->"a16c6f53-7e6a-436e-811b-f62e51de4298"],
-Cell[1220, 37, 305, 7, 35, "Text",ExpressionUUID->"09960bfd-191c-4f23-99f8-c9c531996076"],
-Cell[1528, 46, 2521, 51, 78, "Input",ExpressionUUID->"9dbc3571-1f42-4c1e-a479-47dc7b02f091"],
-Cell[CellGroupData[{
-Cell[4074, 101, 3413, 72, 147, "Input",ExpressionUUID->"bbb8814f-becb-4de9-bddf-5c74453e3308"],
-Cell[7490, 175, 1650, 48, 56, "Output",ExpressionUUID->"be51b51d-8bd7-4009-9add-9f6f8096525f"],
-Cell[9143, 225, 442, 7, 35, "Output",ExpressionUUID->"5ea17af6-c31e-4e6c-868e-0cad49e30927"],
-Cell[9588, 234, 483, 9, 35, "Output",ExpressionUUID->"5eb77e74-e787-4b55-ab2e-93d10d425eaa"],
-Cell[10074, 245, 668, 16, 44, "Output",ExpressionUUID->"6df6066a-d441-4b2b-af69-d3c5495616d2"]
-}, Open  ]],
-Cell[CellGroupData[{
-Cell[10779, 266, 3725, 81, 239, "Input",ExpressionUUID->"410501b7-6de2-4a82-a1d2-385e66e5b7f6"],
-Cell[14507, 349, 1129, 20, 22, "Message",ExpressionUUID->"db85290c-cb69-4394-bc83-be8c581fbbcb"],
-Cell[15639, 371, 1758, 37, 68, "Output",ExpressionUUID->"4cff916e-930f-44e7-9100-26c43bbdd9cb"],
-Cell[17400, 410, 9858, 177, 225, "Output",ExpressionUUID->"8e9365d4-6d7d-4a93-b35b-adbf4f832fec"]
-}, Open  ]],
-Cell[CellGroupData[{
-Cell[27295, 592, 2061, 55, 193, "Input",ExpressionUUID->"d2e61497-cfc2-48d7-9b6d-2c510de52f4d"],
-Cell[29359, 649, 7229, 133, 403, "Output",ExpressionUUID->"0aff9c7c-5cd5-4b06-8d92-9f6754c6a9d7"]
-}, Open  ]]
-}
-]
-*)
-
+(* Content-type: application/vnd.wolfram.mathematica *)
+
+(*** Wolfram Notebook File ***)
+(* http://www.wolfram.com/nb *)
+
+(* CreatedBy='Mathematica 11.3' *)
+
+(*CacheID: 234*)
+(* Internal cache information:
+NotebookFileLineBreakTest
+NotebookFileLineBreakTest
+NotebookDataPosition[       158,          7]
+NotebookDataLength[     39008,        813]
+NotebookOptionsPosition[     37229,        779]
+NotebookOutlinePosition[     37619,        795]
+CellTagsIndexPosition[     37576,        792]
+WindowFrame->Normal*)
+
+(* Beginning of Notebook Content *)
+Notebook[{
+Cell[BoxData[
+ RowBox[{"ClearAll", "[", 
+  RowBox[{"Evaluate", "[", 
+   RowBox[{
+    RowBox[{"Context", "[", "]"}], "<>", "\"\<*\>\""}], "]"}], "]"}]], "Input",
+ CellLabel->"In[78]:=",ExpressionUUID->"65d45139-50ab-4f38-9cd3-0897640d6bab"],
+
+Cell[BoxData[
+ RowBox[{
+  RowBox[{"Needs", "[", "\"\<Spline`\>\"", "]"}], ";", 
+  RowBox[{"Needs", "[", "\"\<SubSpaces`\>\"", "]"}]}]], "Input",
+ CellChangeTimes->{{3.753702624847374*^9, 3.753702651682048*^9}, {
+   3.7562091338207912`*^9, 3.7562091398916073`*^9}, 3.756456930926633*^9, {
+   3.756459845923547*^9, 3.756459850214402*^9}},
+ CellLabel->"In[79]:=",ExpressionUUID->"a16c6f53-7e6a-436e-811b-f62e51de4298"],
+
+Cell["\<\
+find all x,y for which the pythagorean mean of the first eigenvalues of the \
+master and submatrix are 1\
+\>", "Text",
+ CellChangeTimes->{{3.756459409955472*^9, 3.756459446031177*^9}, {
+  3.756459496634173*^9, 
+  3.7564595889340076`*^9}},ExpressionUUID->"09960bfd-191c-4f23-99f8-\
+c9c531996076"],
+
+Cell[BoxData[{
+ RowBox[{
+  RowBox[{"Clear", "[", 
+   RowBox[{"x", ",", "y", ",", "s1", ",", "s2", ",", "esystems"}], "]"}], 
+  ";"}], "\[IndentingNewLine]", 
+ RowBox[{
+  RowBox[{"H", "=", 
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"{", 
+      RowBox[{"0", ",", "0", ",", "0"}], "}"}], ",", 
+     RowBox[{"{", 
+      RowBox[{"x", ",", "y", ",", "0"}], "}"}], ",", 
+     RowBox[{"{", 
+      RowBox[{"1", ",", "0", ",", "0"}], "}"}]}], "}"}]}], ";"}]}], "Input",
+ CellChangeTimes->{{3.756456910325953*^9, 3.756456911485878*^9}, {
+   3.756457065393977*^9, 3.756457130704842*^9}, {3.756457178963238*^9, 
+   3.756457223203022*^9}, {3.75645729613369*^9, 3.756457333093988*^9}, {
+   3.756457372152726*^9, 3.756457478694639*^9}, {3.756457658210804*^9, 
+   3.756457660387308*^9}, {3.756457711409144*^9, 3.7564577816200113`*^9}, {
+   3.756457881891737*^9, 3.7564578884936943`*^9}, {3.7564579385243483`*^9, 
+   3.756458004808157*^9}, {3.756458046281458*^9, 3.756458048865675*^9}, {
+   3.7564580839009333`*^9, 3.756458102168103*^9}, {3.7564581450655203`*^9, 
+   3.756458208920618*^9}, {3.756458267009261*^9, 3.756458294052622*^9}, {
+   3.7564583290316896`*^9, 3.756458428297187*^9}, {3.756458855368375*^9, 
+   3.7564588581547728`*^9}, {3.756458892060815*^9, 3.7564589405618467`*^9}, {
+   3.756459077469171*^9, 3.756459183708806*^9}, {3.75645923963918*^9, 
+   3.75645924531663*^9}, {3.756459275720622*^9, 3.75645927833908*^9}, {
+   3.7564593148279123`*^9, 3.7564593317472267`*^9}, 3.756459602885786*^9, {
+   3.756459789695437*^9, 3.756459827876498*^9}, {3.7564598914279413`*^9, 
+   3.7564599186397867`*^9}, {3.756460027633892*^9, 3.756460050436306*^9}, {
+   3.756460144948061*^9, 3.756460145388665*^9}, {3.7564601993688803`*^9, 
+   3.756460199450418*^9}, {3.7564602359505167`*^9, 3.7564602436489277`*^9}, {
+   3.756460315927175*^9, 3.7564603294688253`*^9}, {3.7564605357754107`*^9, 
+   3.756460544057013*^9}, {3.75646057805752*^9, 3.756460635423991*^9}, {
+   3.756460905331465*^9, 3.7564609101990747`*^9}, {3.756461005127858*^9, 
+   3.756461011764902*^9}, 3.806250128512622*^9},
+ CellLabel->"In[80]:=",ExpressionUUID->"9dbc3571-1f42-4c1e-a479-47dc7b02f091"],
+
+Cell[CellGroupData[{
+
+Cell[BoxData[{
+ RowBox[{
+  RowBox[{"Clear", "[", 
+   RowBox[{"x", ",", "y", ",", "s1", ",", "s2", ",", "esystems"}], "]"}], 
+  ";"}], "\[IndentingNewLine]", 
+ RowBox[{"esystems", "=", 
+  RowBox[{
+   RowBox[{
+    RowBox[{"Eigensystem", "[", "#", "]"}], "&"}], "/@", 
+   RowBox[{"ListSubSpaces", "[", 
+    RowBox[{
+     RowBox[{"pascalMatrix", "[", "3", "]"}], ".", 
+     RowBox[{"H2", "[", 
+      RowBox[{
+       RowBox[{"pascalMatrix", "[", "3", "]"}], ",", 
+       RowBox[{"IdentityMatrix", "[", "3", "]"}], ",", 
+       RowBox[{"{", 
+        RowBox[{"0", ",", "0"}], "}"}], ",", 
+       RowBox[{"{", 
+        RowBox[{"x", ",", "y"}], "}"}], ",", 
+       RowBox[{"{", 
+        RowBox[{"1", ",", "0"}], "}"}]}], "]"}]}], 
+    "]"}]}]}], "\[IndentingNewLine]", 
+ RowBox[{"s1", "=", 
+  RowBox[{
+   RowBox[{
+    RowBox[{"esystems", "[", 
+     RowBox[{"[", "1", "]"}], "]"}], "[", 
+    RowBox[{"[", "1", "]"}], "]"}], "[", 
+   RowBox[{"[", "3", "]"}], "]"}]}], "\[IndentingNewLine]", 
+ RowBox[{"s2", "=", 
+  RowBox[{
+   RowBox[{
+    RowBox[{"esystems", "[", 
+     RowBox[{"[", "2", "]"}], "]"}], "[", 
+    RowBox[{"[", "1", "]"}], "]"}], "[", 
+   RowBox[{"[", "1", "]"}], "]"}]}], "\[IndentingNewLine]", 
+ RowBox[{
+  RowBox[{"Sqrt", "[", 
+   RowBox[{
+    RowBox[{"s1", "^", "2"}], "+", 
+    RowBox[{"s2", "^", "2"}]}], "]"}], "\[Equal]", "1"}]}], "Input",
+ CellChangeTimes->{{3.756456910325953*^9, 3.756456911485878*^9}, {
+   3.756457065393977*^9, 3.756457130704842*^9}, {3.756457178963238*^9, 
+   3.756457223203022*^9}, {3.75645729613369*^9, 3.756457333093988*^9}, {
+   3.756457372152726*^9, 3.756457478694639*^9}, {3.756457658210804*^9, 
+   3.756457660387308*^9}, {3.756457711409144*^9, 3.7564577816200113`*^9}, {
+   3.756457881891737*^9, 3.7564578884936943`*^9}, {3.7564579385243483`*^9, 
+   3.756458004808157*^9}, {3.756458046281458*^9, 3.756458048865675*^9}, {
+   3.7564580839009333`*^9, 3.756458102168103*^9}, {3.7564581450655203`*^9, 
+   3.756458208920618*^9}, {3.756458267009261*^9, 3.756458294052622*^9}, {
+   3.7564583290316896`*^9, 3.756458428297187*^9}, {3.756458855368375*^9, 
+   3.7564588581547728`*^9}, {3.756458892060815*^9, 3.7564589405618467`*^9}, {
+   3.756459077469171*^9, 3.756459183708806*^9}, {3.75645923963918*^9, 
+   3.75645924531663*^9}, {3.756459275720622*^9, 3.75645927833908*^9}, {
+   3.7564593148279123`*^9, 3.7564593317472267`*^9}, 3.756459602885786*^9, {
+   3.756459789695437*^9, 3.756459827876498*^9}, {3.7564598914279413`*^9, 
+   3.7564599186397867`*^9}, {3.756460027633892*^9, 3.756460050436306*^9}, {
+   3.756460144948061*^9, 3.756460145388665*^9}, {3.7564601993688803`*^9, 
+   3.756460199450418*^9}, {3.7564602359505167`*^9, 3.7564602436489277`*^9}, {
+   3.756460315927175*^9, 3.7564603294688253`*^9}, {3.7564605357754107`*^9, 
+   3.756460544057013*^9}, {3.75646057805752*^9, 3.756460635423991*^9}, {
+   3.756460905331465*^9, 3.7564609101990747`*^9}, {3.756461041354941*^9, 
+   3.7564610487404137`*^9}, {3.75646109613271*^9, 3.756461099021854*^9}, {
+   3.756462938804141*^9, 3.75646294093736*^9}, {3.7564629731644773`*^9, 
+   3.756463085738658*^9}, {3.756463116824527*^9, 3.7564631371320143`*^9}, {
+   3.756463172944376*^9, 3.756463196038673*^9}, {3.8062501066314178`*^9, 
+   3.806250109662733*^9}, {3.8062996744119797`*^9, 3.8062996820274496`*^9}},
+ CellLabel->"In[82]:=",ExpressionUUID->"bbb8814f-becb-4de9-bddf-5c74453e3308"],
+
+Cell[BoxData[
+ RowBox[{"{", 
+  RowBox[{
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"{", 
+      RowBox[{"0", ",", "0", ",", 
+       RowBox[{"4", " ", "y"}]}], "}"}], ",", 
+     RowBox[{"{", 
+      RowBox[{
+       RowBox[{"{", 
+        RowBox[{"0", ",", "0", ",", "1"}], "}"}], ",", 
+       RowBox[{"{", 
+        RowBox[{"0", ",", "0", ",", "0"}], "}"}], ",", 
+       RowBox[{"{", 
+        RowBox[{"0", ",", 
+         RowBox[{"-", "1"}], ",", "1"}], "}"}]}], "}"}]}], "}"}], ",", 
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"{", 
+      RowBox[{
+       RowBox[{
+        RowBox[{"-", "1"}], "+", 
+        RowBox[{"4", " ", "x"}]}], ",", 
+       RowBox[{
+        RowBox[{"-", "4"}], " ", "y"}]}], "}"}], ",", 
+     RowBox[{"{", 
+      RowBox[{
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"-", 
+          FractionBox[
+           RowBox[{
+            RowBox[{"-", "1"}], "+", 
+            RowBox[{"4", " ", "x"}], "+", 
+            RowBox[{"4", " ", "y"}]}], 
+           RowBox[{"2", " ", 
+            RowBox[{"(", 
+             RowBox[{
+              RowBox[{"-", "1"}], "+", 
+              RowBox[{"2", " ", "x"}]}], ")"}]}]]}], ",", "1"}], "}"}], ",", 
+       RowBox[{"{", 
+        RowBox[{"0", ",", "1"}], "}"}]}], "}"}]}], "}"}]}], "}"}]], "Output",
+ CellChangeTimes->{
+  3.756461052325547*^9, 3.756461104280448*^9, 3.7564611562637453`*^9, 
+   3.756462576169718*^9, {3.756462954525395*^9, 3.756463091054825*^9}, {
+   3.756463122452183*^9, 3.7564631381334753`*^9}, {3.756463173751932*^9, 
+   3.7564631970682697`*^9}, 3.7564632311744537`*^9, 3.756463268375197*^9, 
+   3.8062500283321915`*^9, 3.806250132840497*^9, {3.8062997073540583`*^9, 
+   3.8062997209314313`*^9}, 3.807187557860154*^9},
+ CellLabel->"Out[83]=",ExpressionUUID->"7a42f501-4df4-4aad-ac57-99e361b74b01"],
+
+Cell[BoxData[
+ RowBox[{"4", " ", "y"}]], "Output",
+ CellChangeTimes->{
+  3.756461052325547*^9, 3.756461104280448*^9, 3.7564611562637453`*^9, 
+   3.756462576169718*^9, {3.756462954525395*^9, 3.756463091054825*^9}, {
+   3.756463122452183*^9, 3.7564631381334753`*^9}, {3.756463173751932*^9, 
+   3.7564631970682697`*^9}, 3.7564632311744537`*^9, 3.756463268375197*^9, 
+   3.8062500283321915`*^9, 3.806250132840497*^9, {3.8062997073540583`*^9, 
+   3.8062997209314313`*^9}, 3.8071875578615503`*^9},
+ CellLabel->"Out[84]=",ExpressionUUID->"1ac32966-5d9c-46b9-8744-3a16f76be19a"],
+
+Cell[BoxData[
+ RowBox[{
+  RowBox[{"-", "1"}], "+", 
+  RowBox[{"4", " ", "x"}]}]], "Output",
+ CellChangeTimes->{
+  3.756461052325547*^9, 3.756461104280448*^9, 3.7564611562637453`*^9, 
+   3.756462576169718*^9, {3.756462954525395*^9, 3.756463091054825*^9}, {
+   3.756463122452183*^9, 3.7564631381334753`*^9}, {3.756463173751932*^9, 
+   3.7564631970682697`*^9}, 3.7564632311744537`*^9, 3.756463268375197*^9, 
+   3.8062500283321915`*^9, 3.806250132840497*^9, {3.8062997073540583`*^9, 
+   3.8062997209314313`*^9}, 3.807187557862767*^9},
+ CellLabel->"Out[85]=",ExpressionUUID->"9b76a2fc-ff7b-4002-b38d-88cb5f43120e"],
+
+Cell[BoxData[
+ RowBox[{
+  SqrtBox[
+   RowBox[{
+    SuperscriptBox[
+     RowBox[{"(", 
+      RowBox[{
+       RowBox[{"-", "1"}], "+", 
+       RowBox[{"4", " ", "x"}]}], ")"}], "2"], "+", 
+    RowBox[{"16", " ", 
+     SuperscriptBox["y", "2"]}]}]], "\[Equal]", "1"}]], "Output",
+ CellChangeTimes->{
+  3.756461052325547*^9, 3.756461104280448*^9, 3.7564611562637453`*^9, 
+   3.756462576169718*^9, {3.756462954525395*^9, 3.756463091054825*^9}, {
+   3.756463122452183*^9, 3.7564631381334753`*^9}, {3.756463173751932*^9, 
+   3.7564631970682697`*^9}, 3.7564632311744537`*^9, 3.756463268375197*^9, 
+   3.8062500283321915`*^9, 3.806250132840497*^9, {3.8062997073540583`*^9, 
+   3.8062997209314313`*^9}, 3.807187557866102*^9},
+ CellLabel->"Out[86]=",ExpressionUUID->"8b42b3ef-d666-4fe1-ab11-89d3b79fb690"]
+}, Open  ]],
+
+Cell[CellGroupData[{
+
+Cell[BoxData[{
+ RowBox[{
+  RowBox[{"Clear", "[", 
+   RowBox[{"x", ",", "y", ",", "s1", ",", "s2", ",", "esystems"}], "]"}], 
+  ";"}], "\[IndentingNewLine]", 
+ RowBox[{"sol", "=", 
+  RowBox[{"Solve", "[", 
+   RowBox[{
+    RowBox[{
+     RowBox[{"esystems", "=", 
+      RowBox[{
+       RowBox[{
+        RowBox[{"Eigenvalues", "[", "#", "]"}], "&"}], "/@", 
+       RowBox[{"ListSubSpaces", "[", 
+        RowBox[{
+         RowBox[{"pascalMatrix", "[", "3", "]"}], ".", 
+         RowBox[{"H2", "[", 
+          RowBox[{
+           RowBox[{"pascalMatrix", "[", "3", "]"}], ",", 
+           RowBox[{"IdentityMatrix", "[", "3", "]"}], ",", 
+           RowBox[{"{", 
+            RowBox[{"0", ",", "0"}], "}"}], ",", 
+           RowBox[{"{", 
+            RowBox[{"x", ",", "y"}], "}"}], ",", 
+           RowBox[{"{", 
+            RowBox[{"1", ",", "0"}], "}"}]}], "]"}]}], "]"}]}]}], ";", 
+     "\[IndentingNewLine]", 
+     RowBox[{"s1", "=", 
+      RowBox[{
+       RowBox[{"esystems", "[", 
+        RowBox[{"[", "1", "]"}], "]"}], "[", 
+       RowBox[{"[", "3", "]"}], "]"}]}], ";", "\[IndentingNewLine]", 
+     RowBox[{"s2", "=", 
+      RowBox[{
+       RowBox[{"esystems", "[", 
+        RowBox[{"[", "2", "]"}], "]"}], "[", 
+       RowBox[{"[", "1", "]"}], "]"}]}], ";", "\[IndentingNewLine]", 
+     RowBox[{
+      RowBox[{"Sqrt", "[", 
+       RowBox[{
+        RowBox[{"s1", "^", "2"}], "+", 
+        RowBox[{"s2", "^", "2"}]}], "]"}], "\[Equal]", "1"}]}], ",", 
+    RowBox[{"{", 
+     RowBox[{"x", ",", "y"}], "}"}]}], "]"}]}], "\[IndentingNewLine]", 
+ RowBox[{"Plot", "[", 
+  RowBox[{
+   RowBox[{
+    RowBox[{
+     RowBox[{"sol", "[", 
+      RowBox[{"[", "1", "]"}], "]"}], "[", 
+     RowBox[{"[", "1", "]"}], "]"}], "[", 
+    RowBox[{"[", "2", "]"}], "]"}], ",", 
+   RowBox[{"{", 
+    RowBox[{"x", ",", "0", ",", "0.5"}], "}"}]}], "]"}]}], "Input",
+ CellChangeTimes->{{3.756456910325953*^9, 3.756456911485878*^9}, {
+   3.756457065393977*^9, 3.756457130704842*^9}, {3.756457178963238*^9, 
+   3.756457223203022*^9}, {3.75645729613369*^9, 3.756457333093988*^9}, {
+   3.756457372152726*^9, 3.756457478694639*^9}, {3.756457658210804*^9, 
+   3.756457660387308*^9}, {3.756457711409144*^9, 3.7564577816200113`*^9}, {
+   3.756457881891737*^9, 3.7564578884936943`*^9}, {3.7564579385243483`*^9, 
+   3.756458004808157*^9}, {3.756458046281458*^9, 3.756458048865675*^9}, {
+   3.7564580839009333`*^9, 3.756458102168103*^9}, {3.7564581450655203`*^9, 
+   3.756458208920618*^9}, {3.756458267009261*^9, 3.756458294052622*^9}, {
+   3.7564583290316896`*^9, 3.756458428297187*^9}, {3.756458855368375*^9, 
+   3.7564588581547728`*^9}, {3.756458892060815*^9, 3.7564589405618467`*^9}, {
+   3.756459077469171*^9, 3.756459183708806*^9}, {3.75645923963918*^9, 
+   3.75645924531663*^9}, {3.756459275720622*^9, 3.75645927833908*^9}, {
+   3.7564593148279123`*^9, 3.7564593317472267`*^9}, 3.756459602885786*^9, {
+   3.756459789695437*^9, 3.756459827876498*^9}, {3.7564598914279413`*^9, 
+   3.7564599186397867`*^9}, {3.756460027633892*^9, 3.756460050436306*^9}, {
+   3.756460144948061*^9, 3.756460145388665*^9}, {3.7564601993688803`*^9, 
+   3.756460199450418*^9}, {3.7564602359505167`*^9, 3.7564602436489277`*^9}, {
+   3.756460315927175*^9, 3.7564603294688253`*^9}, {3.7564605357754107`*^9, 
+   3.756460544057013*^9}, {3.75646057805752*^9, 3.756460635423991*^9}, {
+   3.756460905331465*^9, 3.7564609101990747`*^9}, {3.756461041354941*^9, 
+   3.7564610487404137`*^9}, {3.756462907993943*^9, 3.756462910854012*^9}, {
+   3.806250112593328*^9, 3.806250114719123*^9}, {3.8062996876740074`*^9, 
+   3.806299691731862*^9}},
+ CellLabel->"In[87]:=",ExpressionUUID->"410501b7-6de2-4a82-a1d2-385e66e5b7f6"],
+
+Cell[BoxData[
+ TemplateBox[{
+  "Solve", "svars", 
+   "\"Equations may not give solutions for all \\\"solve\\\" variables.\"", 2,
+    88, 6, 17818314643544740346, "Local"},
+  "MessageTemplate"]], "Message", "MSG",
+ CellChangeTimes->{{3.7564589171791058`*^9, 3.756458958036316*^9}, {
+   3.756459085229855*^9, 3.7564591002891083`*^9}, {3.756459133568548*^9, 
+   3.756459167613634*^9}, 3.756459200912953*^9, 3.756459245812299*^9, {
+   3.756459296222108*^9, 3.756459339929934*^9}, 3.756459603862586*^9, 
+   3.756459919188964*^9, {3.7564600621012173`*^9, 3.7564600912349253`*^9}, {
+   3.756460146352265*^9, 3.756460164720677*^9}, 3.756460210713407*^9, {
+   3.756460244409607*^9, 3.756460267877121*^9}, 3.7564603178714542`*^9, 
+   3.756460544583508*^9, {3.756460580412614*^9, 3.756460636129538*^9}, 
+   3.756461052862645*^9, 3.756461104758013*^9, 3.756461156674327*^9, 
+   3.756462576227322*^9, 3.756462911613645*^9, {3.75646305223693*^9, 
+   3.756463070123383*^9}, 3.756463127368025*^9, 3.756463231636546*^9, 
+   3.7564632684671288`*^9, 3.806250028383093*^9, 3.8062501328824964`*^9, {
+   3.8062997074076977`*^9, 3.8062997209825387`*^9}, 3.8071875579018793`*^9},
+ CellLabel->
+  "During evaluation of \
+In[87]:=",ExpressionUUID->"502cbb4a-b36c-4fc7-a481-7eefc62fd30a"],
+
+Cell[BoxData[
+ RowBox[{"{", 
+  RowBox[{
+   RowBox[{"{", 
+    RowBox[{"y", "\[Rule]", 
+     RowBox[{"-", 
+      FractionBox[
+       SqrtBox[
+        RowBox[{"x", "-", 
+         RowBox[{"2", " ", 
+          SuperscriptBox["x", "2"]}]}]], 
+       SqrtBox["2"]]}]}], "}"}], ",", 
+   RowBox[{"{", 
+    RowBox[{"y", "\[Rule]", 
+     FractionBox[
+      SqrtBox[
+       RowBox[{"x", "-", 
+        RowBox[{"2", " ", 
+         SuperscriptBox["x", "2"]}]}]], 
+      SqrtBox["2"]]}], "}"}]}], "}"}]], "Output",
+ CellChangeTimes->{{3.756457481670076*^9, 3.756457501576932*^9}, {
+   3.756457662160788*^9, 3.756457676664591*^9}, {3.756457713422348*^9, 
+   3.75645778463975*^9}, 3.756457889745634*^9, 3.75645810574946*^9, 
+   3.7564581561252203`*^9, {3.756458188704734*^9, 3.756458209691869*^9}, {
+   3.756458269855393*^9, 3.756458294542178*^9}, 3.7564584017929296`*^9, 
+   3.7564584395145063`*^9, {3.756458917239855*^9, 3.756458958085984*^9}, {
+   3.75645908525062*^9, 3.756459100360383*^9}, {3.756459133587274*^9, 
+   3.756459167597069*^9}, 3.756459200876762*^9, 3.756459245803225*^9, {
+   3.756459296211677*^9, 3.7564593399224873`*^9}, 3.756459603848732*^9, 
+   3.7564599191778*^9, {3.756460062239423*^9, 3.756460091259613*^9}, {
+   3.756460146346614*^9, 3.756460164716612*^9}, 3.756460210681127*^9, {
+   3.756460244379775*^9, 3.756460267872299*^9}, 3.756460317864443*^9, 
+   3.756460544544866*^9, {3.756460580368079*^9, 3.7564606360851173`*^9}, 
+   3.7564610529058332`*^9, 3.756461104797967*^9, 3.756461156725276*^9, 
+   3.7564625762843103`*^9, 3.756462911688354*^9, {3.756463052301784*^9, 
+   3.756463070193972*^9}, 3.7564631274293537`*^9, 3.756463231759986*^9, 
+   3.7564632685333633`*^9, 3.806250028421071*^9, 3.8062501329296513`*^9, {
+   3.8062997074677134`*^9, 3.8062997210561657`*^9}, 3.807187557941372*^9},
+ CellLabel->"Out[88]=",ExpressionUUID->"276ea6b3-7c61-4918-8ec3-3fd04c7ba735"],
+
+Cell[BoxData[
+ GraphicsBox[{{{}, {}, 
+    TagBox[
+     {RGBColor[0.368417, 0.506779, 0.709798], AbsoluteThickness[1.6], Opacity[
+      1.], LineBox[CompressedData["
+1:eJwV2Hk8VF8bAHC0oIWIRIskypKEqMhToZKEsivK0ktkS6EIRaFCWZM1Sin7
+vuQg65iZe8eabSZCCqHCT7b39Nd8vp977j33bM/z3BGzdrlgx8HGxmbNzsb2
+7/es3Sij+ruWunDhPn/fMn60WkPElSW8BwZ8c4oMfgYgxeS4hAJhJfDdneUd
+Yx6ChrbvCfCUVAc7nvLPGzaEIx1aV36isCZ8DNP2Fxp/hvY82fF6RVQb3hjo
+Zn3mikKLZ21ir0qeh/3NBuL+09HIxHbu43NhQ/CWbNB9ZPgC1WmIlHxKMIZv
+6yz4Wvvikbz4sdw/omYwu56xLVcvAXEN3n9lLGkJ909vghW2ZNR/4JHGU2Fb
+OHYke0/811QUlby1WsLCDiZG3YwZLq/QWd5MtaqEa9DoOqvwbe4VKv5JPTQp
+6gD6AVu6lhbTUFgW/z4DSWf42mnVNTbwGqUI6j0MFfaAG8bLKqFq79BdWmyd
+cbkHeOsdvZaX/A4ZB33hELe4BQ1b9Lj12DPRhhk3v4qE2/Afw7pCvjoTebVH
+eY2LekMkz+23EnIfkEFkz/XzkvdgXD3rwEB7NpLVEX8n0ngPMh7/fO4skYO4
+Vjl9G/mfH0zy/ujbdSsHWZUt5yFDf4jQi6Wu5c5FglIRcqYxAaCxI6PMMDUX
+BXAV7A0RDoQTH6y/xtbkIenTz4LzXbET0y/v/ZaHWoNcvvc2BoLHQTkR6w35
+aM8q2fdyt4Ogpkfr2oBRPmpYSpdrb30IUT+q9FWH89GG3zGHRJ+EAGdZ1OaG
+2QIU139Ho2g5DNr2y7ItThShE9vN0plG4TATsk+nbn0x+mGusoYrKxx4aKsO
+WUkVo53j3jZZ+yPg0IBmIa9tMXJxUJZg64uAWkUGp3NXMeK3zXn7+vBzWK84
+UJNRXIJMzVJzpqajYHVe+fok8zI02Wu47pVINDReewQS7mXooSWX3UWNaPBu
+flH6PKQMFdi4iBRHRQNy948UKy1DPM7Hgu6qxMDrXmHDLQLlqP5+t/la31hg
+m79xPbKxHCl84Fu7nSsebgkduWa9sxKtXwm4dHpnMujLB+RxRFehOAcTS9lT
+yVD4mcPMIKMK7WmXvcLnnAzrzir2PiurQurvumx6PyZDpchE22h/FSp7F1NU
+IpcC7CazGtMSCE1cHK/UoafAma0o1r8AIaO3sS03N76CQkX7tFjraiRh8HP0
+0+N0+Jsa7WhnU4M86Ucg7s87WPYx+mJt8AkJFfIx2dlzwH1xV7rpQB0qHtSg
+Emr5QBebWvpm2YBqryduMxsvhL8KmxPjMhvRjOQx3qwbJXBsza2yl6gJccy/
+37RNohyuGql0GtOakfLKleKL2ZWgo+JzKiGHgqiBSvQGaQSbjCSyuz1bkGjE
+2Py7n9UQP/tVcY0qFY3NsZgd8rXwaLlFbqafitJ/VFB4wj6BRUS40ta7NMSz
+I2NyaKgOtLndhEkOOnriUHQtZU8DVLTpiWa70dHs8fdD9n6NoFARKvO0m44q
+08deegY2gt2C9tPpHjq6zyV78WFII6igxnVGfXTEQ36oSYtsBMovbzNhFh1J
+WmUnMTMagenIpx07REfGvnmmhmQjOPn7PrafpKOishIqiDVBvAtyvLqaQB4K
+dYVbPjXBRfbEqnwZAl1T2pXyrKkJbpcwVuZkCWSq7PN4A70JBOIUj6nJEUj1
+qJI1R3cT6FksfaiRJxDHyXTenz+bwKddyLb6EIHCDQKv14s0w9NmH52nQKBM
+V81dHu7NsFgUyrC7QKAE95T1k57N0Mx7qy30IoGeeizOOvg2g0fd6Y5sQwK5
+ehXSrIKb4dmKYPdvYwKp+O+5q5PUDNB0ecjNgkB14as7d1Pw/ez3xNRtCcTK
+rnvMEKOApvvlSaFbBCInVo8r7KXADTEZm623CVQtq3UuSpYCQQlnvgp5Eigl
+s36DiQoFel4SXALeBLJ+0/C07xw2NWKMzZdAI4lN4d88KbCl5414ViCBJp5Q
+I5doFODT0J3TiyQQs2XDH8s2Cmz3F9ulEEUg+jpdw+rPFJhuWjDZHE2g7GCa
+wIOvFFCe5p9pjcHjCaRHc81TgPv5/MipeAL9uUvGbt7TAnQtSjl7KoEWrre/
+lLrTAm0OVW8+ZRHIUPnyMzm/FmANaRTcySbQB/aRh4qBLaBpsHVKPodAlnFz
+bsfCWiD8x/Df+FwC1dSLnDF41QIi7bHGdgUEerTr6h8vSgtEcqoptJUSaHPn
+xLkmESpcDFXu3PyJQE6pt0/SRKlQXuW8Ng+7zmlFpXUPFZyHo+x16wh0exWf
+eJ8cFUqCemof1BOoW15pfvIkFWY7I8mRRgIlP77zWsiRCoYNdPOHVALJnOBc
+vlZBhdqWEE+ZDgLlZr7f+7maChpenGvKsZUE9A20G6jwROFr6ulOAql9i0uX
+YWAPj3Bf6SLQ+afSOlMjVPjE5h0V1E0g927dOG9+Gmz30E1K6yfQ7MlfNT+E
+aLBQfGmvOJNAdz/EjFnsoMHhS8HVqdiBfix19X00sLO+Kp7AIlCMhNswhzoN
+ON/qfggaIFCZW5TCEwca5K22bpcZJpB67+FLS840OPpJwzYBu1azP8jZgwaZ
+Fj9WbxghEEVIslvfjwZaJ7O8RrH7Ppb4CUbTgHpGSCZmlEBs63qpSdU0SGek
+fKobI9DpV2L/yxOiw7VuHTaXaTzeOB7Jhu104PfP1azE3hW2MNQjRoe+/ttl
+XL8I9Ne7w3q1LB3M5kEpGTvLIMTS5DgdVpqsXWp/4/VinzZasqfDse05bIMz
+uL+5fgF+Zzp0/G7Q3T1LoPFxSpvkTTpEy8W0XMVu+JxuoO9Lh8h1zmZMbO9c
+U920Z3QYePqwijaHz4dVtaZ2OR2mjxzPD5onENUoa5UlosOVpz83lGGX6sTX
+utfRIZczPm4M+7mKx/EEOh2oJXMnz/8lkBbvPrXJQTo8CDg0xL1AIIU1ggur
+RumgOqvUqIy9c4G9fOsEHbYFne+1xv5vpFfl5Bx+PvTHlGK/rwpXjF5PAG9n
+rYX5IoHiCn1+vdtEQOTRiUZ/7MBMh7wqQQKmKs7avcG2jNE4MCpKQLZjpuIk
+Np/znLSqEgHOTmdEPZcItGwz9F3vCAE8m00FY7F/mDHe2qoTwD6Wo1aMXaf1
+XjLsDAGfw06I/sL23GG1e+ASAeVd0kpXlvF515c37rtKwFzgA2Vv7PMP2EO7
+rhFg1qfu/gxb8nvaNM2VAI3goWiEzb/9lkTzLfz8w62+HdhL50+Z1d0hQPuM
+VPIP7PbC0eryQAIYqcJh/Cs43nwr+1MUgsfXWmQhgf1e5PG+vDACRhVqrFWw
+7/vvj8iIw/3lS+8ww3YuWP70KpEAE63HpD222Qgxl/iKgIJJq4+e2PLn3K2i
+PhBwtc1BIxJ7u59GZHgeAVwbU/uSsTnzBRpDi3F7S/2c99i/hob/BlUQ4JHu
+VVGMzRQqkQuoJuDbexH2GmzK2WBrn3oCjimp+FOwi3zNYjwpBCj/pB9uw07J
+laa4EwSI+QxK92I/+bqwdKOdgH43d+NBbK8ttIMO3diGfhWj2DbaSXa2TAL2
+JHCb/8Q+7+PywuorAVq5fAq/sY/mHKeZjxJwbSxWYw5bcpCP3XiCALUXCWF/
+sfkEvyoZ/CJg85zo5iXsxdOF9ufmCPikuJuxjD16Jyjh9CIBpS5pTSvYP4xl
+7FPZSJiqTJv/5ytTmzlEV5GwsFPc9p87QxZfJqwhYSlUjOvf/Triw4dEuEh4
+8y1peOHf+lTSiNh1JKhvfLn4H7aycbGD4EYSEusFdWewP0wmrYrkJWEfladr
+Cnt3yKPETfwksGhB8WPYcbtdVcIESDjrcCd2GJun0pSxXoiEULlxGhM70OiE
+Y4gwvp7cc6wLe/6n1BrO7SRQ5bS+0f+tdzB/cuBOEgZOyFDqsYfEFg5ziJHw
+Xe7JSAU2aUh1WpIgQfptRctr7FM/C9fe3UfCbFxw1AvsykeJKf9Jk9ArS4t5
+gp1R7tz++wAJJ+zLTrv+2x+GJs5uCiTQ2axmr2A/nwCuSSUSnuz0Yupj39vF
+p/bjCAkMWTYLOew/ZfMd/1MjoTXeaXIb9vWLgy7D6iTMBZ/+yIVt9LAg7YsG
+CZknNNZ8wftddtxofZcuCaP39p4Kwi41PIdC9UnQHKUEXcfW+HjypvpFErwW
+PvSexzYPO9D72pSErmfiFAHsEHnu9x42eH7VIvOi8fkUeLFiue8aCXbqw69u
+Yqewz/L32ZNQW38lUx+7tHXwjoYzbm/YtMCJPeJReZbfm4T3CWxvHXF8cO/P
+X66/S4JrwKmzJ7GXtN7le98jwb7mJcdWbAGhGJGBByT0I7uiahyPNMpcfuSE
+kfBQe6M4J3bK0u5Q3XQSf+sIbrPH8U/2mrA6ewYJqmlu2+WxS+i8vwrfkXDz
+YLzi3H843ycvmm3PIWH1TdW0+9hLJzqlxspIiKuTfxSG4635w5DmYIKEXUOH
+Lt/B8Xvkp5+vWisJu3N6ShWx3UxuH5xqJ+FK2W+p8T8ECt5n88KkB7/PZ4dz
+5tjFFDUHyWG8X4cLn8n8ywe8U1x1f0kY1/5P6NUUgVo/hj7SXiIh9rTk/QvY
+z50k1hIrJCTJF4lyYPNTzFf1rGZATkT/H8tJ7KD6pUkeBrDnv1/L+5NAmxbi
+f20TZ4CDU1rtGZy/yHeH3FIlGND6+rvV+A8CRZiSk5L7GNAyuE8+HJu3eM3E
+wf0MGDh926H1O97vbq7fTqswwNs5UF0P58MN37T6buowQJaYc9yN8yk1+ov5
+vC4DRrqvHiobwvFD8273PX0GxIPuQT3s9a9yO0OMGKCyNrja6yuB1l3exki2
+YsCf6+9Ua3G+5mqbqm+5yYBC51OJcji/r0Yvc8QTGJD/4A/hhOuHHjXNM6wk
+BjSKWXUwcX2RUz7+JT6VAYNZAqN62ObFx/j5Mxgwb7P/0IF2AuVlsTzY8hlA
+imY6DTJwfkkQP9rfyICFXfu1ttHw/vJ+XxfzmwEuVk+OdtYSKGzu4uULs3g8
+Uv10KWybW4szG+cZkDJT4OxT82/8unuDlhnwebyQ3FlNIDv7yZCb3K2gEH5m
+u+lHPN8minr6oq3QpfH4U0IJgRyVKrq5dVpB9MapvhvvcfwhOz6U6raCYUWm
+15tMAgnemPL7n34rcI5Y7mW+IxB6LSFZb9QKX1RdK86+xesvFOHuf6UVopka
+lVtfE6hi3nb93K1WIDpaNgUn4flEPMeGUlpB2uBpQEEEzjfa1ilVs61QPWa7
+5Yg7rkdkxdRhvhV6R6v2nXYjUBXPl1600ArF3X3/M3TF6992WaiGrQ1+bNjq
+5OSM48Fls7BP69ogjeYS+vw6rpfc9X2adrbB25KHG0uscft4ddPWU23gHXgj
+5Qqu52fGRDaNxLTB4zl9g4MHCBSV+K0x4UUbZDG+zkztJ5CiXqHfxYQ2cBIs
+fJmDvyfc8nUnq1PbQCDp2Q8paVxfe/nTX35og56U3mf8EgQaXjPyxKC2De7d
+FxsrECFQh2ge98eJNogNXhg+tAbnq4unV0VptoNyf+2DA1105HcmKLlwpB2E
+rR70HbhNR2L9Zz+nBXVAqXZLwhsuOjqqEhglrNAJrqVuTwb8aejSTmKeva0T
+1mrsDfSfpqIZytNB14AuqC+95VhykoriVlt6XNjzGdx9KzXXPWlBm5lFrzjq
+PsOStFeGcj0FrfENMDzi1g2h9qqkbUczYntnmTPI3wMWhvl/b/Y1Iff4nKf8
+tT0QJcY+VZvTiD7KBHPxOfeCFb/oMx/bBsR31l32Pk8frF5snLvOXY/69pNt
+3pV90B4sl+9s+QnlJsGeIct+6PlOnTGNrEG/7/zmvHq1H1ICT4XXPa5ByiYZ
+Y/02/fDTQtNTJrAGVfDyFnTZ94NzipbImEcNavBnnmhx74erybeX5I1rUK+1
+r1X+w354uUswnCFUg9burYj3z+6He1Ol+w7FVqPLOcp8O5b7Id88R/YeN0LF
+5v/xkGxMeKoZSVmaqUI8a8s3PFjFBDfTQYMbg1Wo+tIxru9cTBi/VJ26raIK
+7V6nuVK4mQmDKuda8xyr0IitwcQ5KSb46By3zWj+iJxFnJp9DJnAIZKQXuhZ
+iRrq9zceMGHCa0e12fGrlUjUbbJu0IwJ+W9r7Tadq0Rko3v1GSsmlOcF9wrt
+qkQKt7xLBK4zIW+xOkW8sQLNEQ9ff/BjQqK9Y/nKpgrkH5Qa0JfJhIkXTadE
+n5ehjZ6cZ69mMYEm7ag6c6cMxdvf4B/JYYL2yiWefJsyVKBzJG2ykAkfEp8d
+ZimVoRE+Rh0HYsLaNoGilY5SpJPExiXVxgS5UZaq4OZStKXEKuzWAhOyWQPH
+ttwuRmlv643/LjHhojyH426LYiQfLyPqx8aCk7VO1tzHi5G271xO8BoWsC1c
+CLXjLkY+GuGMl7wsuPBFdPpUfBEaJKoEasVZcFT7LtpdWIiyRne85DnHAg6X
+nLKe2nwUnBh0hXmeBQG+u1TXJOUj2wsTEtkGLLgtWerG8spH2ysrc3VNWFDu
+Btov9+ej0HCLhifWLOh8Mc81+zwP2Su/mF7nzYIiDmMxHp1cpDnGVtJzF193
+PS4mvCsXiabY+2TeY8EbrbQdBt9zUCf3Yc6zgSzQS9jFH3I4B2n1d24PCWeB
+zCbDwqHmLLQ7UOAM5xsW/HduTZJOdiZaPuyzsestC2ojxVWHNDJR98TX1jfv
+WRD3Rv1IQdc7FGFScPlUHgveXh3gjp1/i1akL9wMqmRB6gnvmOviGaiHVXbY
+CLEgI82hoyDjDSqOElveU8uCPu+jFEWpN8h5eSq4rpEFx61803nEX6M+RnjS
+qjYWHDMN8doz9gqVPpyzaetggde4+UOpC69QlKqVVNpnFmQ+u0kZLUhFOq/l
+Ck8yWTCXHWkoZ5eCJM1jvPkHWHBuXsfwyrVkxMG7rD74lQXKNqrLCdOJqNyL
+1hzwnQV3dX6P5VPiUcz+Q+EG47i//dwyHZteILfBBEOxSRZwetp29h6KRedi
+V4tMT7OA5k1GbDkYjfadc2JV/8HrTeHgkp95jlazt6dHzLFASuOybYljBPpS
+pHr9yl8WPD16w7mHEYoqr6cdkF9igYd0gCB17j6KFV0/s7LCglPXF/3+/R/8
+fwaAERI=
+       "]]},
+     Annotation[#, "Charting`Private`Tag$178844#1"]& ]}, {}},
+  AspectRatio->NCache[GoldenRatio^(-1), 0.6180339887498948],
+  Axes->{True, True},
+  AxesLabel->{None, None},
+  AxesOrigin->{0, 0},
+  DisplayFunction->Identity,
+  Frame->{{False, False}, {False, False}},
+  FrameLabel->{{None, None}, {None, None}},
+  FrameTicks->{{Automatic, Automatic}, {Automatic, Automatic}},
+  GridLines->{None, None},
+  GridLinesStyle->Directive[
+    GrayLevel[0.5, 0.4]],
+  ImagePadding->All,
+  Method->{
+   "DefaultBoundaryStyle" -> Automatic, 
+    "DefaultGraphicsInteraction" -> {
+     "Version" -> 1.2, "TrackMousePosition" -> {True, False}, 
+      "Effects" -> {
+       "Highlight" -> {"ratio" -> 2}, "HighlightPoint" -> {"ratio" -> 2}, 
+        "Droplines" -> {
+         "freeformCursorMode" -> True, 
+          "placement" -> {"x" -> "All", "y" -> "None"}}}}, "DefaultMeshStyle" -> 
+    AbsolutePointSize[6], "ScalingFunctions" -> None, 
+    "CoordinatesToolOptions" -> {"DisplayFunction" -> ({
+        (Identity[#]& )[
+         Part[#, 1]], 
+        (Identity[#]& )[
+         Part[#, 2]]}& ), "CopiedValueFunction" -> ({
+        (Identity[#]& )[
+         Part[#, 1]], 
+        (Identity[#]& )[
+         Part[#, 2]]}& )}},
+  PlotRange->{{0, 0.5}, {-0.24999999703820874`, 0.}},
+  PlotRangeClipping->True,
+  PlotRangePadding->{{
+     Scaled[0.02], 
+     Scaled[0.02]}, {
+     Scaled[0.05], 
+     Scaled[0.05]}},
+  Ticks->{Automatic, Automatic}]], "Output",
+ CellChangeTimes->{{3.756457481670076*^9, 3.756457501576932*^9}, {
+   3.756457662160788*^9, 3.756457676664591*^9}, {3.756457713422348*^9, 
+   3.75645778463975*^9}, 3.756457889745634*^9, 3.75645810574946*^9, 
+   3.7564581561252203`*^9, {3.756458188704734*^9, 3.756458209691869*^9}, {
+   3.756458269855393*^9, 3.756458294542178*^9}, 3.7564584017929296`*^9, 
+   3.7564584395145063`*^9, {3.756458917239855*^9, 3.756458958085984*^9}, {
+   3.75645908525062*^9, 3.756459100360383*^9}, {3.756459133587274*^9, 
+   3.756459167597069*^9}, 3.756459200876762*^9, 3.756459245803225*^9, {
+   3.756459296211677*^9, 3.7564593399224873`*^9}, 3.756459603848732*^9, 
+   3.7564599191778*^9, {3.756460062239423*^9, 3.756460091259613*^9}, {
+   3.756460146346614*^9, 3.756460164716612*^9}, 3.756460210681127*^9, {
+   3.756460244379775*^9, 3.756460267872299*^9}, 3.756460317864443*^9, 
+   3.756460544544866*^9, {3.756460580368079*^9, 3.7564606360851173`*^9}, 
+   3.7564610529058332`*^9, 3.756461104797967*^9, 3.756461156725276*^9, 
+   3.7564625762843103`*^9, 3.756462911688354*^9, {3.756463052301784*^9, 
+   3.756463070193972*^9}, 3.7564631274293537`*^9, 3.756463231759986*^9, 
+   3.7564632685333633`*^9, 3.806250028421071*^9, 3.8062501329296513`*^9, {
+   3.8062997074677134`*^9, 3.8062997210561657`*^9}, 3.807187558004471*^9},
+ CellLabel->"Out[89]=",ExpressionUUID->"586ad8e7-7262-452c-8b4d-0f9c8ae4c38a"]
+}, Open  ]],
+
+Cell[CellGroupData[{
+
+Cell[BoxData[{
+ RowBox[{
+  RowBox[{"Clear", "[", 
+   RowBox[{"x", ",", "y", ",", "s1", ",", "s2", ",", "esystems"}], "]"}], 
+  ";"}], "\[IndentingNewLine]", 
+ RowBox[{"RegionPlot", "[", 
+  RowBox[{
+   RowBox[{
+    RowBox[{"esystems", "=", 
+     RowBox[{
+      RowBox[{
+       RowBox[{"Eigenvalues", "[", "#", "]"}], "&"}], "/@", 
+      RowBox[{"ListSubSpaces", "[", 
+       RowBox[{
+        RowBox[{"pascalMatrix", "[", "3", "]"}], ".", 
+        RowBox[{"H2", "[", 
+         RowBox[{
+          RowBox[{"pascalMatrix", "[", "3", "]"}], ",", 
+          RowBox[{"IdentityMatrix", "[", "3", "]"}], ",", 
+          RowBox[{"{", 
+           RowBox[{"0", ",", "0"}], "}"}], ",", 
+          RowBox[{"{", 
+           RowBox[{"x", ",", "y"}], "}"}], ",", 
+          RowBox[{"{", 
+           RowBox[{"1", ",", "0"}], "}"}]}], "]"}]}], "]"}]}]}], ";", 
+    "\[IndentingNewLine]", 
+    RowBox[{"s1", "=", 
+     RowBox[{
+      RowBox[{"esystems", "[", 
+       RowBox[{"[", "1", "]"}], "]"}], "[", 
+      RowBox[{"[", "3", "]"}], "]"}]}], ";", "\[IndentingNewLine]", 
+    RowBox[{"s2", "=", 
+     RowBox[{
+      RowBox[{"esystems", "[", 
+       RowBox[{"[", "2", "]"}], "]"}], "[", 
+      RowBox[{"[", "1", "]"}], "]"}]}], ";", "\[IndentingNewLine]", 
+    RowBox[{
+     RowBox[{"Sqrt", "[", 
+      RowBox[{
+       RowBox[{"s1", "^", "2"}], "+", 
+       RowBox[{"s2", "^", "2"}]}], "]"}], "<=", "1"}]}], ",", 
+   RowBox[{"{", 
+    RowBox[{"x", ",", 
+     RowBox[{"-", "0.5"}], ",", "1.0"}], "}"}], ",", 
+   RowBox[{"{", 
+    RowBox[{"y", ",", 
+     RowBox[{"-", "0.5"}], ",", "0.5"}], "}"}]}], "]"}]}], "Input",
+ CellChangeTimes->{{3.756460797461627*^9, 3.7564608637775497`*^9}, {
+  3.756460947372512*^9, 3.756460950210264*^9}, {3.7564610224148407`*^9, 
+  3.756461023352928*^9}, {3.7564625934761257`*^9, 3.7564626725544252`*^9}, {
+  3.806250117150222*^9, 3.8062501190793753`*^9}, {3.806299699054471*^9, 
+  3.8062997175296564`*^9}},
+ CellLabel->"In[90]:=",ExpressionUUID->"d2e61497-cfc2-48d7-9b6d-2c510de52f4d"],
+
+Cell[BoxData[
+ GraphicsBox[{GraphicsComplexBox[CompressedData["
+1:eJxll39M1GUcx09llRQuWalDTfojupWFYUfimt8WZM25PByFkmMNi61oozFt
+ndnGj/gaONt0N9oK0XPRppUEkdh17CQEAUGRgLslkNJh/hixbsLQ0uu6Z6/P
+sQf/ca+9n+/7Ps/z/Tzvz5dH8wo3vz3XYrHkzLFY/v9/c+viwj3BY8aa+G9z
+ffZz3itTR+1O3ynh6X/3tZnBLuHyOWkHPWaf8Gcx3/hsTp/w5/cuj69zDQnj
+X7r9nZ9tzjPiD+MP4w/jD+MP49/dmLQk7Cv+MP4w/jD+MP4w/k8+0HEtYGsU
+fxh/GH8Yfxh/GP9pd+w+M/iF+MP4w/jD+MP4w/h7FBv4w/jD+MP4w/jD+C9T
++xF/GH8Yfxh/GH8Y/9PqfYg/jD+MP4w/jD+M/y7VT+IP4w/jD+MP4w/jv0rd
+B/GH8Yfxh/GH8Yc9Q+sergxWGsOR99HlXTb/9boC6+/C6I9HzvO06DD6aGS9
+W3QY/VqEj4kOo1si/2o86DD6WbXeQIfR+9TviQ6jr1D1ig6jD6j9ig6jk0fo
+MDp5gg6jkwfoMDr3GR1G5z6iw+jcJ3QYnfuADqPTz+gwOv2IDqPTT+jwC82r
+bzt9h40rzbvPhELnvTmf/vRm3NiwMPqIYgMddv9ZuDLV2ST9CHP+E7eW7o0b
+axMdRld91Cs6jB47r2itI25AdBg9/p7AjmDCb6LD6A2BO397zAbZz7vTo+P2
+3Fbh3Xfb89IdPcKvlA7cSOj6Vdhe/nKS0+cXZn/0H8x58nucT+v1y/l1Lo8w
+++d5mOepj/U7/smydhV0CHM+PA/zPPth/S/F1a/mpl8Q5vx4HuZ59s/67rIF
+FT77oDDny/Mwz3NerO83i1vtuReFyUvOk/OByU+Y/cPkKcz+YPIVpn6YvIWp
+DyZ/9XroL+qtzL84edzVLfWgUy869aBTLzr1oFMvOvWgUy96zVTFJmsomncw
++QaTZzD5BZNXMPkEk0cw+QOTNzD9wPuOcZztsIX7lPOEOT+Y84I5H5jzgIMp
+j7ly9zQYd29kDCZYer2fHFzZsmAq1hjZWJvne7BbeMj6fpOtv9NbeeiDNlf4
+frG+ujZnrTN8X2D/a4ey08P9D1/asvCAJ9zP8PU3yrpt4fyD2a/+e9aaPK8t
+q004addTDzkXt8p6XQ+MGGusyc3R+qsGLgd+PCnrdf2vuTv/6Cyoiz5fdDg1
+3fG1rNd1e+LRrXFjJcL+FRGW96Xr7crPgHuVn6yfpat6hftVvbJe1x9R5yGc
+qM5D1ut6v3p/woPqvGU9ujdx7MvMwcPGbfV+DN4XTL/ApdXuprjwfYbpDzgr
+q8XuCN9nmH6BU77rG7WF7zNM/8DPf5+xvC58n2H6Cc744US2NXyfYe6L3s/6
+98x9qv8ln1jPfYK5TzD3CeY+wXwf4M/vkycweQKTJzB5ApMnMHkCkycweQLr
+38Pcf+qFef/sp2Vr6Ra/P8pdjRM3A4HhWTrnjw4z3zkP5jXM/IWZpzDzEaZf
+yXOYfILLJuftNxs6hPmeh/U86VnfMh6YbBHm+17yScuTp1fdcZpFJ4T53pe8
+0fKkpHai2gy6hPn+h/U8qX8i9VIotF+YvwckD7Q8Sbh6YF36rXph/j6Q+63l
+ifnSknKzyCvM3wuwnieOC+fGAjvbhfl+gfU8SS5eWGGm9BhFVYMvLjVnzxfe
+H/ycWi/M+9uQuWmRZca82Za9em/ww+i8OXn8/uJgZ3TenKr/2F0wY95Qj+5P
+P8Alan/Cej/oOv0BV6nzFNb7Q9fpF5l36v1F69H6RdfpH3hc9Yvoev/oOv0E
+b1e/J6z3k67TXzKP1H6F9f7SdfoNblPnLaz3m67Tf/BHql+E6T+eRyePyDv6
+k7yKSZu/KPNIdJ6RV6ynH9GdR66GEt6LzjfyjPX0q8ynrHy3OWPekXesp5/R
+t2X7b4ZmzD/ykPX0O/pbORuSHTPmIfOZ+8D+YOYzzH5g5jNM/TDzOXo/Vb0w
+8xmmPv1+pn21/llr4XnhZxTL+0SH0f8DHSNyaQ==
+    "], {{
+      {RGBColor[0.368417, 0.506779, 0.709798], AbsoluteThickness[1.6], 
+       Opacity[0.3], EdgeForm[None], 
+       GraphicsGroupBox[{PolygonBox[CompressedData["
+1:eJxVlld01kUQxWdpIcEIIYEEQqhpEAihCCkgSO+9igiCihiKFRQUFBQLCqJI
+DdjLm7333nvXo0/23p7sc8/8csCHe3b+++3O7ty5O/N1W7J6xqomZjYlmTX1
+cajDTctwNDj2O1Y6djmudSxz7HHsdix3HHQccKx2DGNftqONI9OR5WjraOU4
+wnEka1o6WjNq3T7HXke9Y7Sjg6OLIwcf2t/Zke8oADn4bodf+WvPqPNHOnLx
+1RE7z1HEuny+s9lfyLf8dWLUumNYk8ueNpzd9TDf/R0Vjt6Osdy9xNEdv/LX
+g1Hnr3EMdvRzlLJe/sod3djXk1H7ejEWO8bju4LvIrjpxl0KuUcJvisdZfge
+wG99HFWcId8T8af7DOR37TuKsS93VpzVfJezfxDf8jcZH4PxUcrZZcSnO67j
+HjWOTZxRZ5H/leRbOpNOpEXpTlqTVqRHaU16kO6OttBVJnlpzW9tyVEGuc22
+Q5rTt/Rbz74txDCEs3PwlQ+vRcwVMKf90kaeHdKcvkewRmfnkosO/C4fnbhH
+nh3SYiHrGjWn7+H4UFwbyEetYxT30RkT4Fu5G2Ohg87s7w7PjZrTdxdyUUIe
+yvhu1FZPfpM2KthfzrpGLZYTRzH7OrJO/sbhp5iYu3KmfEkz/dgvnVTir4pv
+nTmAdX2IV9+TyEsV96i0/+tyIPsH8V3K7/L3qWO+i2eqhd6q8b8JLrV3moV+
+WlhooA4/Uyy0IL8zLeqa8jaD3Cgvcy3qi2Kdb1GzFO9si3qh/M6y0IRyOd2i
+tmZw5gz8zCGvBZwznTWLLN6keDsWfsXtQov3L16PhyPxc4LF29O7O5HYFNcC
+i3qk3C4mtkHcRdzofc2z0JD0c5yFtnoRx0xiX+I4GV5GsaczHMwm3hHEo1ik
+2xryOBaOunD3BdxnHOc11p+FxDWB2KrgdS48D4fTtsS6CH5OIn7FfopF7UjE
+txR7J7y0gF+tUT04nT2Jb9WZTHhaQry7WKM+eSprmsD9Yvg8g980vwdb/XSF
+RZ2RfSbfsvdhN3Ossqh7srOwVcPO4jfNN2A3d5xmUQObs062tHQ2v2n+ILbi
+vZw4FeMV3FX33MaddJ+rOE9nXY0v+dGbWQPPa7GrGdfC+bnY1YznMK/cr8PH
+euwaxvWsz4QfxX0+81qj97kBHxsdFzC/kflaxo3M691uYt9m7Drsi1h/icU7
+H8Lvm5m/GFvrL8RnLXndgu8t7K/jjudxf81dyvxSuBbP0stWeN4K77Ib+4p6
+gjRyJfwrtzvg/DL86p7SyHbysp08NWPfNvbuIGeN2riGvGvciS2N7GfNSmxp
+RzXyM4u3ov67D//qubu483K+mxCX5pcxv5sc6tyDnKP6doBz81PUYvkf4Pa3
+Fu//AOu1Zp7P/2Tx3sRDw2F3bODOq9kjnb/vGJ1CE/XcoSl79nL/H8Rfirpw
+i3KYotbc5hia4t2+JH8p6s0ryneKOvSqo3WK9/2io3+KuqVz9nDWGJ/7wEIv
+w91+x+Id1HOHLPK7B55G+pr3LDS+Ap61VnVX9V21/Uhfc6tF7WuV4t6684eO
+cSl0/LFjYgrNzfXxOota39bt3BR1q9THxy1qc1O3m6Wo2d19fMSirrd3+06L
+PjA5xf9/6XSqj9NS6Gu6jzNS6E7cvGzBT63br1nU4Eq3n7Wo8S3czkgRk/hr
+A4e9fHzKopaLyxcs+BT32fCf6WNWip4w08dZKXQ928c5KbT8t+Mfiz5Q4XNf
+W/SGlm7fDI9N3L7Rog/1dfsbo/e4/YVFf33bMSxFnWru400W/azM7a8s+tlf
+just+nQPn//Sohd2dvtBi179h+NPC73r0acUPfBnxy8W9eAtx+8WvfN1uBNv
+/zpusOhn7zpGpKgpyn9NCg0M9vE7i774o+JDz3eRP+XuCfKtXCvunilifxre
+xbni65MixnY+3mHRD3R+SYo7PEP+lLtfHfdb9Ms8n7vd4m3Wuf29Rd99A81J
+b8+TP+XuOTQhPTwGL+JE+emXIke/Od606NuTfO4Ti5qXk+J9LiZWvWHF+yja
+lW6fRNPSs2pJVYp6Ii2Up9CD8tYtRe7G+/iRRY1/gJwpX+J1YApupZHeKXQi
+jRSk0Im0UJxCD8p/1xQa0JsrSvHuHkIT0sPDaFT6FE/VKbjq6OM9Fr22g9t3
+W/Rg8araJ24/t3jP8qnaqnqr/yOFPnevRW/u5PZ9Fr35Pyi+N54=
+          "]], PolygonBox[CompressedData["
+1:eJwtlPdvj1EUxu+VCiGEIHZoEARBkLa0ShWlWlptbapFRKQogiAIYm//hL33
+3nvvEftne4bg8+ScHz455/m+7/u99z7nnJtYMiW/rEIIoQAS4DnUiSFMI66E
+KuRVYSR5FryGhugZxPXwEuqjy4mroQZ5TSgmHwCvoAF6OnEt7NTv6BXEVHgL
+n2EcbIYn0Jfni4lLoRp5dRhN3h+OQTP0YGJPqEVeG0rIc6ESeWUYTt4HdkNd
+9EBiGpyEluhCYi84D+3Rw7QunIE26CHE3nAYmqDziOmwTd+h5xNTYLvWQS8i
+doU30Ag9k7gRXsBHKA22hy3wBcZDEmyFHrw/h5gMO6BftLN3gw9wByYEO2MC
+zyrCUPJM2Ac/YHIwj7+6x6n+TSrv3iTmwFitgb5GzIYx0Bl9WWvCKOiAvuBe
+jIBE9FHtEfKhLfqseyPP6qH3uLfyqDH6ELE7DILm6ONeK3neFH3EvVQNW6FP
+eS3keQv0CWKG92RRtB5Rb2zS/6DvE+fBXLgqH6PtXWfKjuahvFsON5RHO6s8
+yIpWM9VqiXoK/dTfXaZ9o+8SZ8Ms78XH/q56Mj1aDZP8nYxoNUz2PWWiHxIX
+wgL5FK1nUvy3A/ALpgbrkdY8P+21LIJ7vgetrZ74KZ/QG4hl8jTaTGmW1sB3
+9VW0fJJqFG1GNZvrIDfajGo2V3mv5EV7pp7ZBd9gYrCZ/w1/vNaq4V/457VQ
+D+z1NbVWuZ+lMFptdKZPwe4Q3R2l/t850dbWGgXRZkSzoTPdhvfBelMz8cg9
+lHeaqQdec9VaM5dGfivYrBfLV/T1YHeN7oh26HPBZl8z0hF9MdjdpTvhmddc
+tdYdFMkrRPNePbffPZfXuuO68OxKsLtHd+BBeBest3VnXYJO0WZFM/QfZqWd
+JQ==
+          "]]}]}, {}, {}, {}, {}}, 
+     {RGBColor[0.368417, 0.506779, 0.709798], AbsoluteThickness[1.6], 
+      LineBox[CompressedData["
+1:eJwt0mdXj3Ecx/H/315RyCirYSYho+xVspWZmz0APaSSTbQkI6VkZG8yQiIN
+JbIzXudw431en+/v3nXOFZWVnbE7GAgEzinTqOcHdeqZwr0V8LM22Bv1wh7N
+Yn7RJnuzXtoRLOFXpdsZemVH8gS/aYu9VQ32GJbyu7bZ2/Xa/qiTatQObzkc
+yzL+0E91K1dR3s/wl37rj/ZoYvDfdwUYVA/lOafyPHuyl3prrzueF9iHfdVP
++9yzeIn9OUADtd89l7UcxBAN1gF3Mq9zCEMVpoPuxbzFoRym4Trk3skO3lGX
+jmu9t6dcyydcx2Ncwzqu5mOmMZ+pfMRVfMgUHuVKPuBy3ucKHuEy3uMS3uVS
+HuYn3Va7dnl7z0W8yQW8wYVsYxKvcR6vcj5bOYdXOJuXmcgWzuRFzmANE9jM
+6azmNFYxju84hZWcxApOZhNjWc5onmUM33ICT3McT3E833AUiziChRzJ5///
+9780KWGU
+       "]]}}], {}},
+  AspectRatio->1,
+  Axes->{False, False},
+  AxesLabel->{None, None},
+  AxesOrigin->{Automatic, Automatic},
+  DisplayFunction->Identity,
+  Frame->{{True, True}, {True, True}},
+  FrameLabel->{{None, None}, {None, None}},
+  FrameTicks->{{Automatic, Automatic}, {Automatic, Automatic}},
+  GridLinesStyle->Directive[
+    GrayLevel[0.5, 0.4]],
+  ImagePadding->All,
+  Method->{
+   "DefaultGraphicsInteraction" -> {
+     "Version" -> 1.2, "TrackMousePosition" -> {True, False}, 
+      "Effects" -> {
+       "Highlight" -> {"ratio" -> 2}, "HighlightPoint" -> {"ratio" -> 2}, 
+        "Droplines" -> {
+         "freeformCursorMode" -> True, 
+          "placement" -> {"x" -> "All", "y" -> "None"}}}}, "ScalingFunctions" -> 
+    None, "TransparentPolygonMesh" -> True, "AxesInFront" -> True},
+  PlotRange->{{-0.5, 1.}, {-0.5, 0.5}},
+  PlotRangeClipping->True,
+  PlotRangePadding->{{
+     Scaled[0.02], 
+     Scaled[0.02]}, {
+     Scaled[0.02], 
+     Scaled[0.02]}},
+  Ticks->{Automatic, Automatic}]], "Output",
+ CellChangeTimes->{3.806299722704319*^9, 3.807187560161076*^9},
+ CellLabel->"Out[91]=",ExpressionUUID->"85f72645-7795-4418-aca4-d106ef3bd741"]
+}, Open  ]]
+},
+WindowSize->{949, 957},
+WindowMargins->{{345, Automatic}, {0, Automatic}},
+FrontEndVersion->"12.1 for Linux x86 (64-bit) (June 19, 2020)",
+StyleDefinitions->"Default.nb",
+ExpressionUUID->"5191d0a1-71b6-4f81-bb29-e56b0c389be5"
+]
+(* End of Notebook Content *)
+
+(* Internal cache information *)
+(*CellTagsOutline
+CellTagsIndex->{}
+*)
+(*CellTagsIndex
+CellTagsIndex->{}
+*)
+(*NotebookFileOutline
+Notebook[{
+Cell[558, 20, 239, 5, 30, "Input",ExpressionUUID->"65d45139-50ab-4f38-9cd3-0897640d6bab"],
+Cell[800, 27, 415, 7, 30, "Input",ExpressionUUID->"a16c6f53-7e6a-436e-811b-f62e51de4298"],
+Cell[1218, 36, 305, 7, 35, "Text",ExpressionUUID->"09960bfd-191c-4f23-99f8-c9c531996076"],
+Cell[1526, 45, 2144, 37, 53, "Input",ExpressionUUID->"9dbc3571-1f42-4c1e-a479-47dc7b02f091"],
+Cell[CellGroupData[{
+Cell[3695, 86, 3361, 68, 163, "Input",ExpressionUUID->"bbb8814f-becb-4de9-bddf-5c74453e3308"],
+Cell[7059, 156, 1776, 50, 51, "Output",ExpressionUUID->"7a42f501-4df4-4aad-ac57-99e361b74b01"],
+Cell[8838, 208, 570, 9, 34, "Output",ExpressionUUID->"1ac32966-5d9c-46b9-8744-3a16f76be19a"],
+Cell[9411, 219, 609, 11, 34, "Output",ExpressionUUID->"9b76a2fc-ff7b-4002-b38d-88cb5f43120e"],
+Cell[10023, 232, 794, 18, 36, "Output",ExpressionUUID->"8b42b3ef-d666-4fe1-ab11-89d3b79fb690"]
+}, Open  ]],
+Cell[CellGroupData[{
+Cell[10854, 255, 3653, 78, 229, "Input",ExpressionUUID->"410501b7-6de2-4a82-a1d2-385e66e5b7f6"],
+Cell[14510, 335, 1260, 21, 22, "Message",ExpressionUUID->"502cbb4a-b36c-4fc7-a481-7eefc62fd30a"],
+Cell[15773, 358, 1880, 38, 59, "Output",ExpressionUUID->"276ea6b3-7c61-4918-8ec3-3fd04c7ba735"],
+Cell[17656, 398, 10214, 183, 225, "Output",ExpressionUUID->"586ad8e7-7262-452c-8b4d-0f9c8ae4c38a"]
+}, Open  ]],
+Cell[CellGroupData[{
+Cell[27907, 586, 1994, 52, 185, "Input",ExpressionUUID->"d2e61497-cfc2-48d7-9b6d-2c510de52f4d"],
+Cell[29904, 640, 7309, 136, 390, "Output",ExpressionUUID->"85f72645-7795-4418-aca4-d106ef3bd741"]
+}, Open  ]]
+}
+]
+*)
+
```

### Comparing `stopeight-0.3.14/doc/mathematica/Spline_Eigensystems.nb` & `stopeight-0.3.22/doc/mathematica/Spline_CharacteristicPolynomials.nb`

 * *Files 12% similar despite different names*

```diff
@@ -1,1124 +1,1125 @@
-(* Content-type: application/vnd.wolfram.mathematica *)
-
-(*** Wolfram Notebook File ***)
-(* http://www.wolfram.com/nb *)
-
-(* CreatedBy='Mathematica 11.3' *)
-
-(*CacheID: 234*)
-(* Internal cache information:
-NotebookFileLineBreakTest
-NotebookFileLineBreakTest
-NotebookDataPosition[       158,          7]
-NotebookDataLength[     48552,       1116]
-NotebookOptionsPosition[     46971,       1083]
-NotebookOutlinePosition[     47305,       1098]
-CellTagsIndexPosition[     47262,       1095]
-WindowFrame->Normal*)
-
-(* Beginning of Notebook Content *)
-Notebook[{
-Cell[BoxData[
- RowBox[{"ClearAll", "[", 
-  RowBox[{"Evaluate", "[", 
-   RowBox[{
-    RowBox[{"Context", "[", "]"}], "<>", "\"\<*\>\""}], "]"}], "]"}]], "Input",\
-
- CellLabel->"In[58]:=",ExpressionUUID->"50fcc07e-b04b-4b06-be90-516d39e07f29"],
-
-Cell[BoxData[
- RowBox[{
-  RowBox[{"Needs", "[", "\"\<Spline`\>\"", "]"}], ";", 
-  RowBox[{"Needs", "[", "\"\<SubSpaces`\>\"", "]"}]}]], "Input",
- CellChangeTimes->{{3.753702624847374*^9, 3.753702651682048*^9}, {
-  3.7562091338207912`*^9, 3.7562091398916073`*^9}},
- CellLabel->"In[59]:=",ExpressionUUID->"dc37c5c1-800f-42da-88ac-3d4a585491bb"],
-
-Cell[CellGroupData[{
-
-Cell[BoxData[{
- RowBox[{
-  RowBox[{"MatrixForm", "[", 
-   RowBox[{"Coef1", "=", 
-    RowBox[{"{", 
-     RowBox[{
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"-", "1"}], ",", "1"}], "}"}]}], "}"}]}], "]"}], 
-  ";"}], "\[IndentingNewLine]", 
- RowBox[{
-  RowBox[{"MatrixForm", "[", 
-   RowBox[{"M1", "=", 
-    RowBox[{"{", 
-     RowBox[{
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "1"}], "}"}]}], "}"}]}], "]"}], 
-  ";"}], "\[IndentingNewLine]", 
- RowBox[{"DynamicModule", "[", 
-  RowBox[{
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"s", "=", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0"}], "}"}]}], ",", 
-     RowBox[{"e", "=", 
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0"}], "}"}]}]}], "}"}], ",", 
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"Dynamic", "[", 
-          RowBox[{"Point", "[", 
-           RowBox[{"arc1", "[", 
-            RowBox[{"Coef1", ",", "M1", ",", "s", ",", "e"}], "]"}], "]"}], 
-          "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "s", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "e", "]"}], "]"}]}], "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
-     RowBox[{"{", 
-      RowBox[{"Dynamic", "[", 
-       RowBox[{
-        RowBox[{"poly1", "=", " ", 
-         RowBox[{"M1", ".", 
-          RowBox[{"H1", "[", 
-           RowBox[{"Coef1", ",", "M1", ",", "s", ",", "e"}], "]"}]}]}], ";", 
-        RowBox[{
-         RowBox[{
-          RowBox[{"Expand", "[", 
-           RowBox[{"Eigensystem", "[", "#", "]"}], "]"}], "&"}], "/@", 
-         RowBox[{"ListSubSpaces", "[", "poly1", "]"}]}]}], "]"}], "}"}]}], 
-    "}"}]}], "]"}]}], "Input",
- CellChangeTimes->{{3.753647826762274*^9, 3.753647880150669*^9}, 
-   3.753647910990225*^9, 3.753647956047772*^9, {3.754051357194474*^9, 
-   3.754051375763378*^9}, {3.7544907583082743`*^9, 3.754490759418449*^9}, {
-   3.754493202534712*^9, 3.754493207290389*^9}, 3.754494334324523*^9, {
-   3.756202908250494*^9, 3.756202940289824*^9}, {3.756208614257291*^9, 
-   3.75620861729255*^9}, {3.7562086919980917`*^9, 3.7562087164388943`*^9}, {
-   3.7562087575876904`*^9, 3.7562087600865498`*^9}, {3.756208807900044*^9, 
-   3.7562088316229753`*^9}, {3.756208913210165*^9, 3.756208934547175*^9}, {
-   3.756209115618925*^9, 3.7562091293772583`*^9}, {3.756209177255796*^9, 
-   3.756209190652864*^9}, {3.756209236601375*^9, 3.756209255119244*^9}, {
-   3.756209317142363*^9, 3.756209327001225*^9}, 3.7562093704289722`*^9, {
-   3.756209493111932*^9, 3.7562094937007008`*^9}, {3.756210616723448*^9, 
-   3.756210621768497*^9}, {3.756369115676627*^9, 3.756369120321404*^9}, {
-   3.7563697119570303`*^9, 3.756369712460309*^9}, {3.756369759357086*^9, 
-   3.756369759668892*^9}, {3.756369791287663*^9, 3.756369808123178*^9}},
- CellLabel->"In[60]:=",ExpressionUUID->"af07487f-0f3b-4347-96f1-f47706dc5442"],
-
-Cell[BoxData[
- DynamicModuleBox[{$CellContext`s$$ = {0, 0}, $CellContext`e$$ = {1, 0}}, 
-  RowBox[{"{", 
-   RowBox[{
-    GraphicsBox[{
-      DynamicBox[Typeset`ToBoxes[
-        Point[
-         Spline`arc1[$CellContext`Coef1, $CellContext`M1, $CellContext`s$$, \
-$CellContext`e$$]], StandardForm, Graphics],
-       ImageSizeCache->{{88.5, 136.5}, {-4.5, -1.5}}], 
-      LocatorBox[Dynamic[$CellContext`s$$]], 
-      LocatorBox[Dynamic[$CellContext`e$$]]},
-     PlotRange->2], ",", 
-    RowBox[{"{", 
-     DynamicBox[ToBoxes[$CellContext`poly1 = Dot[$CellContext`M1, 
-          
-          Spline`H1[$CellContext`Coef1, $CellContext`M1, $CellContext`s$$, \
-$CellContext`e$$]]; Map[Expand[
-          Eigensystem[#]]& , 
-         SubSpaces`ListSubSpaces[$CellContext`poly1]], StandardForm],
-      ImageSizeCache->{209., {4., 9.}}], "}"}]}], "}"}],
-  DynamicModuleValues:>{}]], "Output",
- CellChangeTimes->{
-  3.7536478955333557`*^9, {3.7536479475604362`*^9, 3.7536479639347963`*^9}, 
-   3.7536480588698683`*^9, 3.753648164285756*^9, 3.7536506614158916`*^9, 
-   3.753650703490481*^9, 3.753651192986566*^9, 3.7536517557303047`*^9, {
-   3.753702641710807*^9, 3.753702656534095*^9}, 3.7537026966354303`*^9, 
-   3.7537027278789377`*^9, 3.753702778008477*^9, 3.754049641728168*^9, 
-   3.754050050324438*^9, 3.754050339675961*^9, 3.754051534404728*^9, 
-   3.75405186595748*^9, 3.754483916397828*^9, 3.754484116973093*^9, 
-   3.75448449135192*^9, 3.754490858022478*^9, 3.754491753600704*^9, 
-   3.754492473818857*^9, 3.754493282404735*^9, 3.754494358860622*^9, 
-   3.756202843518077*^9, {3.756202918843285*^9, 3.7562029528363743`*^9}, 
-   3.756208460972535*^9, 3.756208630279348*^9, {3.756208693339801*^9, 
-   3.7562087176436367`*^9}, 3.756208767744597*^9, {3.756208821188278*^9, 
-   3.7562088325570374`*^9}, {3.756208914204125*^9, 3.756208935373376*^9}, {
-   3.75620909715893*^9, 3.756209192781035*^9}, {3.756209241563202*^9, 
-   3.756209255863587*^9}, 3.756209332348178*^9, 3.756209371418935*^9, {
-   3.7562094829009027`*^9, 3.7562094956286173`*^9}, 3.756209854129446*^9, 
-   3.7562099612191677`*^9, 3.756210205871806*^9, {3.756210602711171*^9, 
-   3.756210623211475*^9}, 3.7562107200259733`*^9, 3.756210954868672*^9, 
-   3.756369149526269*^9, 3.756369267839787*^9, {3.7563696973159037`*^9, 
-   3.756369760484866*^9}, {3.756369809330225*^9, 3.756369830194756*^9}, 
-   3.756369965094653*^9, {3.756370012125058*^9, 3.7563700411399603`*^9}, {
-   3.756370114549138*^9, 3.756370135049575*^9}, 3.756370353367415*^9, 
-   3.7563712333884783`*^9},
- CellLabel->"Out[62]=",ExpressionUUID->"133f418f-7d6a-4567-a8bf-39ccf019329c"]
-}, Open  ]],
-
-Cell[CellGroupData[{
-
-Cell[BoxData[{
- RowBox[{
-  RowBox[{"MatrixForm", "[", 
-   RowBox[{"Coef2", "=", 
-    RowBox[{"{", 
-     RowBox[{
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"-", "1"}], ",", "1", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", 
-        RowBox[{"-", "1"}], ",", "1"}], "}"}]}], "}"}]}], "]"}], 
-  ";"}], "\[IndentingNewLine]", 
- RowBox[{
-  RowBox[{"MatrixForm", "[", 
-   RowBox[{"M2", "=", 
-    RowBox[{"{", 
-     RowBox[{
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "1", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0", ",", "1"}], "}"}]}], "}"}]}], "]"}], ";", 
-  RowBox[{"l2", "=", 
-   RowBox[{"(", 
-    RowBox[{"2", "*", 
-     RowBox[{"Cos", "[", 
-      RowBox[{"3", "*", 
-       RowBox[{"Pi", "/", "8"}]}], "]"}]}], ")"}]}], ";", 
-  RowBox[{"x2", "=", 
-   RowBox[{
-    RowBox[{"(", 
-     RowBox[{"1", "/", "l2"}], ")"}], "*", "0"}]}], ";", 
-  RowBox[{"y2", "=", 
-   RowBox[{
-    RowBox[{"(", 
-     RowBox[{"1", "/", "l2"}], ")"}], "*", 
-    RowBox[{"(", 
-     RowBox[{"1", "-", 
-      RowBox[{"Sin", "[", 
-       RowBox[{"3", "*", 
-        RowBox[{"Pi", "/", "8"}]}], "]"}]}], ")"}]}]}], ";", 
-  RowBox[{"DynamicModule", "[", 
-   RowBox[{
-    RowBox[{"{", 
-     RowBox[{
-      RowBox[{"s", "=", 
-       RowBox[{"{", 
-        RowBox[{"0", ",", "0"}], "}"}]}], ",", 
-      RowBox[{"c1", "=", 
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{
-          RowBox[{"1", "/", "2"}], "+", "x2"}], ",", 
-         RowBox[{"0", "+", "y2"}]}], "}"}]}], ",", 
-      RowBox[{"e", "=", 
-       RowBox[{"{", 
-        RowBox[{"1", ",", "0"}], "}"}]}]}], "}"}], ",", 
-    RowBox[{"{", 
-     RowBox[{
-      RowBox[{"Graphics", "[", 
-       RowBox[{
-        RowBox[{"{", 
-         RowBox[{
-          RowBox[{"Dynamic", "[", 
-           RowBox[{"Point", "[", 
-            RowBox[{"arc2", "[", 
-             RowBox[{"Coef2", ",", "M2", ",", "s", ",", "c1", ",", "e"}], 
-             "]"}], "]"}], "]"}], ",", 
-          RowBox[{"Locator", "[", 
-           RowBox[{"Dynamic", "[", "s", "]"}], "]"}], ",", 
-          RowBox[{"Locator", "[", 
-           RowBox[{"Dynamic", "[", "c1", "]"}], "]"}], ",", 
-          RowBox[{"Locator", "[", 
-           RowBox[{"Dynamic", "[", "e", "]"}], "]"}]}], "}"}], ",", 
-        RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"Dynamic", "[", 
-        RowBox[{
-         RowBox[{"poly2", "=", " ", 
-          RowBox[{"M2", ".", 
-           RowBox[{"H2", "[", 
-            RowBox[{"Coef2", ",", "M2", ",", "s", ",", "c1", ",", "e"}], 
-            "]"}]}]}], ";", 
-         RowBox[{
-          RowBox[{
-           RowBox[{"Expand", "[", 
-            RowBox[{"Eigensystem", "[", "#", "]"}], "]"}], "&"}], "/@", 
-          RowBox[{"ListSubSpaces", "[", "poly2", "]"}]}]}], "]"}], "}"}]}], 
-     "}"}]}], "]"}]}], "\[IndentingNewLine]", 
- RowBox[{"DynamicModule", "[", 
-  RowBox[{
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"s", "=", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0"}], "}"}]}], ",", 
-     RowBox[{"c1", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"1", "/", "2"}], ",", 
-        RowBox[{"1", "/", "4"}]}], "}"}]}], ",", 
-     RowBox[{"e", "=", 
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0"}], "}"}]}]}], "}"}], ",", 
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"Dynamic", "[", 
-          RowBox[{"Point", "[", 
-           RowBox[{"arc2", "[", 
-            RowBox[{"Coef2", ",", "M2", ",", "s", ",", "c1", ",", "e"}], 
-            "]"}], "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "s", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c1", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "e", "]"}], "]"}]}], "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
-     RowBox[{"{", 
-      RowBox[{"Dynamic", "[", 
-       RowBox[{
-        RowBox[{"poly3", "=", " ", 
-         RowBox[{"M2", ".", 
-          RowBox[{"H2", "[", 
-           RowBox[{"Coef2", ",", "M2", ",", "s", ",", "c1", ",", "e"}], 
-           "]"}]}]}], ";", 
-        RowBox[{
-         RowBox[{
-          RowBox[{"Expand", "[", 
-           RowBox[{"Eigensystem", "[", "#", "]"}], "]"}], "&"}], "/@", 
-         RowBox[{"ListSubSpaces", "[", "poly3", "]"}]}]}], "]"}], "}"}]}], 
-    "}"}]}], "]"}]}], "Input",
- CellChangeTimes->{{3.7536466190737553`*^9, 3.7536466719614697`*^9}, 
-   3.753646753662656*^9, {3.75364688998379*^9, 3.753646913827547*^9}, {
-   3.753650523944252*^9, 3.75365054370264*^9}, {3.753650594547327*^9, 
-   3.753650642661845*^9}, {3.753650688598794*^9, 3.753650693699232*^9}, {
-   3.754051329285913*^9, 3.7540513443693047`*^9}, {3.754051391925915*^9, 
-   3.754051415646282*^9}, {3.754490772337388*^9, 3.754490781866642*^9}, {
-   3.7544932122532578`*^9, 3.7544932249699297`*^9}, {3.754494334332129*^9, 
-   3.754494334334861*^9}, {3.7562083546348047`*^9, 3.756208370951894*^9}, {
-   3.75620952340477*^9, 3.75620956239399*^9}, {3.75620960545441*^9, 
-   3.756209625139511*^9}, {3.756210129642592*^9, 3.75621013008772*^9}, {
-   3.756210638508424*^9, 3.756210655237959*^9}, {3.7563691814069033`*^9, 
-   3.756369203277392*^9}, {3.756369849317026*^9, 3.756369879674121*^9}},
- CellLabel->"In[63]:=",ExpressionUUID->"5d70f809-3415-4942-baca-6a1b97b567af"],
-
-Cell[BoxData[
- DynamicModuleBox[{$CellContext`s$$ = {0, 0}, $CellContext`c1$$ = {
-   Rational[1, 2], Rational[1, 2] (1 - Cos[Rational[1, 8] Pi]) 
-   Csc[Rational[1, 8] Pi]}, $CellContext`e$$ = {1, 0}}, 
-  RowBox[{"{", 
-   RowBox[{
-    GraphicsBox[{
-      DynamicBox[Typeset`ToBoxes[
-        Point[
-         Spline`arc2[$CellContext`Coef2, $CellContext`M2, $CellContext`s$$, \
-$CellContext`c1$$, $CellContext`e$$]], StandardForm, Graphics],
-       ImageSizeCache->{{88.5, 136.5}, {-8.975528266042307, -1.5}}], 
-      LocatorBox[Dynamic[$CellContext`s$$]], 
-      LocatorBox[Dynamic[$CellContext`c1$$]], 
-      LocatorBox[Dynamic[$CellContext`e$$]]},
-     PlotRange->2], ",", 
-    RowBox[{"{", 
-     DynamicBox[ToBoxes[$CellContext`poly2 = Dot[$CellContext`M2, 
-          
-          Spline`H2[$CellContext`Coef2, $CellContext`M2, $CellContext`s$$, \
-$CellContext`c1$$, $CellContext`e$$]]; Map[Expand[
-          Eigensystem[#]]& , 
-         SubSpaces`ListSubSpaces[$CellContext`poly2]], StandardForm],
-      ImageSizeCache->{706.06875, {12.7, 16.64}}], "}"}]}], "}"}],
-  DynamicModuleValues:>{}]], "Output",
- CellChangeTimes->{{3.7536466613411207`*^9, 3.753646677158074*^9}, {
-   3.75364671610394*^9, 3.753646759576289*^9}, 3.753646929477096*^9, 
-   3.7536478957532797`*^9, {3.753647948139514*^9, 3.753647964525106*^9}, 
-   3.753648058933385*^9, 3.753648164353113*^9, 3.753650661577503*^9, 
-   3.753650704314015*^9, 3.7536511954817953`*^9, 3.7536517596433687`*^9, {
-   3.753702642361375*^9, 3.753702657110214*^9}, 3.753702696914332*^9, 
-   3.753702729022799*^9, 3.753702780082932*^9, 3.7540496423349113`*^9, 
-   3.7540500525514*^9, 3.754050341386805*^9, 3.7540515365047092`*^9, 
-   3.754051867655694*^9, 3.7544839171221323`*^9, 3.7544841182532454`*^9, 
-   3.7544844921096277`*^9, 3.754490861014385*^9, 3.754491754252001*^9, 
-   3.7544924750239677`*^9, 3.754493283455462*^9, 3.754494359620925*^9, 
-   3.756202843881237*^9, 3.756208462983913*^9, 3.7562090973280497`*^9, {
-   3.756209143632738*^9, 3.7562091647950983`*^9}, 3.756209241675664*^9, 
-   3.756209563278982*^9, 3.756209626392316*^9, 3.756209854385294*^9, 
-   3.756209961321871*^9, 3.756210134588293*^9, 3.756210206174315*^9, 
-   3.7562106028127203`*^9, 3.756210656872587*^9, 3.756210720336281*^9, 
-   3.7562109550352592`*^9, 3.756369267999704*^9, {3.756369697433097*^9, 
-   3.7563697460000067`*^9}, 3.7563698303067636`*^9, 3.7563699656263657`*^9, {
-   3.756370012255027*^9, 3.7563700417553*^9}, {3.756370114633926*^9, 
-   3.756370135122261*^9}, 3.7563703541484528`*^9, 3.7563712341145763`*^9},
- CellLabel->"Out[64]=",ExpressionUUID->"0eb06d35-9fbd-45af-bb36-6fdc3ebd68d3"],
-
-Cell[BoxData[
- DynamicModuleBox[{$CellContext`s$$ = {0, 0}, $CellContext`c1$$ = {
-   Rational[1, 2], 
-   Rational[1, 4]}, $CellContext`e$$ = {1, 0}}, 
-  RowBox[{"{", 
-   RowBox[{
-    GraphicsBox[{
-      DynamicBox[Typeset`ToBoxes[
-        Point[
-         Spline`arc2[$CellContext`Coef2, $CellContext`M2, $CellContext`s$$, \
-$CellContext`c1$$, $CellContext`e$$]], StandardForm, Graphics],
-       ImageSizeCache->{{88.5, 136.5}, {-15.75, -1.5}}], 
-      LocatorBox[Dynamic[$CellContext`s$$]], 
-      LocatorBox[Dynamic[$CellContext`c1$$]], 
-      LocatorBox[Dynamic[$CellContext`e$$]]},
-     PlotRange->2], ",", 
-    RowBox[{"{", 
-     DynamicBox[ToBoxes[$CellContext`poly3 = Dot[$CellContext`M2, 
-          
-          Spline`H2[$CellContext`Coef2, $CellContext`M2, $CellContext`s$$, \
-$CellContext`c1$$, $CellContext`e$$]]; Map[Expand[
-          Eigensystem[#]]& , 
-         SubSpaces`ListSubSpaces[$CellContext`poly3]], StandardForm],
-      ImageSizeCache->{557., {4., 9.}}], "}"}]}], "}"}],
-  DynamicModuleValues:>{}]], "Output",
- CellChangeTimes->{{3.7536466613411207`*^9, 3.753646677158074*^9}, {
-   3.75364671610394*^9, 3.753646759576289*^9}, 3.753646929477096*^9, 
-   3.7536478957532797`*^9, {3.753647948139514*^9, 3.753647964525106*^9}, 
-   3.753648058933385*^9, 3.753648164353113*^9, 3.753650661577503*^9, 
-   3.753650704314015*^9, 3.7536511954817953`*^9, 3.7536517596433687`*^9, {
-   3.753702642361375*^9, 3.753702657110214*^9}, 3.753702696914332*^9, 
-   3.753702729022799*^9, 3.753702780082932*^9, 3.7540496423349113`*^9, 
-   3.7540500525514*^9, 3.754050341386805*^9, 3.7540515365047092`*^9, 
-   3.754051867655694*^9, 3.7544839171221323`*^9, 3.7544841182532454`*^9, 
-   3.7544844921096277`*^9, 3.754490861014385*^9, 3.754491754252001*^9, 
-   3.7544924750239677`*^9, 3.754493283455462*^9, 3.754494359620925*^9, 
-   3.756202843881237*^9, 3.756208462983913*^9, 3.7562090973280497`*^9, {
-   3.756209143632738*^9, 3.7562091647950983`*^9}, 3.756209241675664*^9, 
-   3.756209563278982*^9, 3.756209626392316*^9, 3.756209854385294*^9, 
-   3.756209961321871*^9, 3.756210134588293*^9, 3.756210206174315*^9, 
-   3.7562106028127203`*^9, 3.756210656872587*^9, 3.756210720336281*^9, 
-   3.7562109550352592`*^9, 3.756369267999704*^9, {3.756369697433097*^9, 
-   3.7563697460000067`*^9}, 3.7563698303067636`*^9, 3.7563699656263657`*^9, {
-   3.756370012255027*^9, 3.7563700417553*^9}, {3.756370114633926*^9, 
-   3.756370135122261*^9}, 3.7563703541484528`*^9, 3.756371234143474*^9},
- CellLabel->"Out[65]=",ExpressionUUID->"751dd17c-ed1f-45f8-9f2e-0160144bc660"]
-}, Open  ]],
-
-Cell[CellGroupData[{
-
-Cell[BoxData[{
- RowBox[{
-  RowBox[{"MatrixForm", "[", 
-   RowBox[{"Coef3", "=", 
-    RowBox[{"{", 
-     RowBox[{
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0", ",", "0", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"-", "1"}], ",", "1", ",", "0", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", 
-        RowBox[{"-", "1"}], ",", "1", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0", ",", 
-        RowBox[{"-", "1"}], ",", "1"}], "}"}]}], "}"}]}], "]"}], 
-  ";"}], "\[IndentingNewLine]", 
- RowBox[{
-  RowBox[{"MatrixForm", "[", 
-   RowBox[{"M3", "=", 
-    RowBox[{"{", 
-     RowBox[{
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0", ",", "0", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "1", ",", "0", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0", ",", "1", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0", ",", "0", ",", "1"}], "}"}]}], "}"}]}], "]"}], 
-  ";"}], "\[IndentingNewLine]", 
- RowBox[{
-  RowBox[{"l3", "=", 
-   RowBox[{"(", 
-    RowBox[{"2", "*", 
-     RowBox[{"Cos", "[", 
-      RowBox[{"3", "*", 
-       RowBox[{"Pi", "/", "12"}]}], "]"}]}], ")"}]}], 
-  ";"}], "\[IndentingNewLine]", 
- RowBox[{
-  RowBox[{"x3", "=", 
-   RowBox[{
-    RowBox[{"(", 
-     RowBox[{"1", "/", "l3"}], ")"}], "*", 
-    RowBox[{"(", 
-     RowBox[{"Cos", "[", 
-      RowBox[{"Pi", "*", 
-       RowBox[{"5", "/", "12"}]}], "]"}], ")"}]}]}], 
-  ";"}], "\[IndentingNewLine]", 
- RowBox[{
-  RowBox[{"y3", "=", 
-   RowBox[{
-    RowBox[{"(", 
-     RowBox[{"1", "/", "l3"}], ")"}], "*", 
-    RowBox[{"(", 
-     RowBox[{
-      RowBox[{"Sin", "[", 
-       RowBox[{"Pi", "*", 
-        RowBox[{"5", "/", "12"}]}], "]"}], "-", 
-      RowBox[{"Sin", "[", 
-       RowBox[{"3", "*", 
-        RowBox[{"Pi", "/", "12"}]}], "]"}]}], ")"}]}]}], 
-  ";"}], "\[IndentingNewLine]", 
- RowBox[{"DynamicModule", "[", 
-  RowBox[{
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"s", "=", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0"}], "}"}]}], ",", 
-     RowBox[{"c1", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{
-         RowBox[{"1", "/", "2"}], "-", "x3"}], ",", 
-        RowBox[{"0", "+", "y3"}]}], "}"}]}], ",", 
-     RowBox[{"c2", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{
-         RowBox[{"1", "/", "2"}], "+", "x3"}], ",", 
-        RowBox[{"0", "+", "y3"}]}], "}"}]}], ",", 
-     RowBox[{"e", "=", 
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0"}], "}"}]}]}], "}"}], ",", 
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"Dynamic", "[", 
-          RowBox[{"Point", "[", 
-           RowBox[{"arc3", "[", 
-            RowBox[{
-            "Coef3", ",", "M3", ",", "s", ",", "c1", ",", "c2", ",", "e"}], 
-            "]"}], "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "s", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c1", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c2", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "e", "]"}], "]"}]}], "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
-     RowBox[{"{", 
-      RowBox[{"Dynamic", "[", 
-       RowBox[{
-        RowBox[{"poly4", "=", " ", 
-         RowBox[{"M3", ".", 
-          RowBox[{"H3", "[", 
-           RowBox[{
-           "Coef3", ",", "M3", ",", "s", ",", "c1", ",", "c2", ",", "e"}], 
-           "]"}]}]}], ";", 
-        RowBox[{
-         RowBox[{
-          RowBox[{"Expand", "[", 
-           RowBox[{"Eigensystem", "[", "#", "]"}], "]"}], "&"}], "/@", 
-         RowBox[{"ListSubSpaces", "[", "poly4", "]"}]}]}], "]"}], "}"}]}], 
-    "}"}]}], "]"}], "\[IndentingNewLine]", 
- RowBox[{"DynamicModule", "[", 
-  RowBox[{
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"s", "=", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0"}], "}"}]}], ",", 
-     RowBox[{"c1", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"1", "/", "3"}], ",", 
-        RowBox[{"1", "/", "5"}]}], "}"}]}], ",", 
-     RowBox[{"c2", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"2", "/", "3"}], ",", 
-        RowBox[{"1", "/", "5"}]}], "}"}]}], ",", 
-     RowBox[{"e", "=", 
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0"}], "}"}]}]}], "}"}], ",", 
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"Dynamic", "[", 
-          RowBox[{"Point", "[", 
-           RowBox[{"arc3", "[", 
-            RowBox[{
-            "Coef3", ",", "M3", ",", "s", ",", "c1", ",", "c2", ",", "e"}], 
-            "]"}], "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "s", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c1", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c2", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "e", "]"}], "]"}]}], "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
-     RowBox[{"{", 
-      RowBox[{"Dynamic", "[", 
-       RowBox[{
-        RowBox[{"poly5", "=", " ", 
-         RowBox[{"M3", ".", 
-          RowBox[{"H3", "[", 
-           RowBox[{
-           "Coef3", ",", "M3", ",", "s", ",", "c1", ",", "c2", ",", "e"}], 
-           "]"}]}]}], ";", 
-        RowBox[{
-         RowBox[{
-          RowBox[{"Expand", "[", 
-           RowBox[{"Eigensystem", "[", "#", "]"}], "]"}], "&"}], "/@", 
-         RowBox[{"ListSubSpaces", "[", "poly5", "]"}]}]}], "]"}], "}"}]}], 
-    "}"}]}], "]"}]}], "Input",
- CellChangeTimes->{{3.753644201707952*^9, 3.753644247779598*^9}, 
-   3.753644670559819*^9, {3.753645089020927*^9, 3.7536450964825172`*^9}, {
-   3.753645348535717*^9, 3.753645396096363*^9}, {3.753645794819468*^9, 
-   3.75364581708619*^9}, {3.753645861522106*^9, 3.753645876685521*^9}, {
-   3.753646034113797*^9, 3.753646036152173*^9}, 3.753646085664897*^9, {
-   3.7536461558568687`*^9, 3.7536461605726357`*^9}, {3.753646190627133*^9, 
-   3.753646219710943*^9}, {3.7536510078891373`*^9, 3.753651115799756*^9}, {
-   3.7536511496238117`*^9, 3.753651165765967*^9}, {3.754051297108377*^9, 
-   3.7540513111994553`*^9}, {3.754051433471871*^9, 3.754051457348982*^9}, {
-   3.754490793379541*^9, 3.7544908055600853`*^9}, {3.7544918592464657`*^9, 
-   3.754491865911813*^9}, {3.754491905000348*^9, 3.754491944695901*^9}, {
-   3.7544932326272297`*^9, 3.7544932475240993`*^9}, {3.754494334353712*^9, 
-   3.7544943343559427`*^9}, {3.756208383468812*^9, 3.756208397488126*^9}, {
-   3.7562096560408297`*^9, 3.7562097213233957`*^9}, {3.756210677779427*^9, 
-   3.756210690894452*^9}, {3.756369212587738*^9, 3.7563692308510723`*^9}, {
-   3.7563698911340218`*^9, 3.756369921481213*^9}, 3.756370036202383*^9, {
-   3.756370067972197*^9, 3.756370100775226*^9}},
- CellLabel->"In[66]:=",ExpressionUUID->"276d508d-f653-4fc6-9da7-c2489ee10b6e"],
-
-Cell[BoxData[
- DynamicModuleBox[{$CellContext`s$$ = {0, 0}, $CellContext`c1$$ = {
-  Rational[1, 2] + Rational[1, 4] (1 - 3^Rational[1, 2]), 
-   2^Rational[-1, 2] (-2^Rational[-1, 2] + 
-    Rational[1, 2] 
-     2^Rational[-1, 2] (1 + 3^Rational[1, 2]))}, $CellContext`c2$$ = {
-  Rational[1, 2] + Rational[1, 4] (-1 + 3^Rational[1, 2]), 
-   2^Rational[-1, 2] (-2^Rational[-1, 2] + 
-    Rational[1, 2] 
-     2^Rational[-1, 2] (1 + 3^Rational[1, 2]))}, $CellContext`e$$ = {1, 0}}, 
-  RowBox[{"{", 
-   RowBox[{
-    GraphicsBox[{
-      DynamicBox[Typeset`ToBoxes[
-        Point[
-         Spline`arc3[$CellContext`Coef3, $CellContext`M3, $CellContext`s$$, \
-$CellContext`c1$$, $CellContext`c2$$, $CellContext`e$$]], StandardForm, 
-        Graphics],
-       ImageSizeCache->{{88.5, 136.5}, {-13.765018033293602`, -1.5}}], 
-      LocatorBox[Dynamic[$CellContext`s$$]], 
-      LocatorBox[Dynamic[$CellContext`c1$$]], 
-      LocatorBox[Dynamic[$CellContext`c2$$]], 
-      LocatorBox[Dynamic[$CellContext`e$$]]},
-     PlotRange->2], ",", 
-    RowBox[{"{", 
-     DynamicBox[ToBoxes[$CellContext`poly4 = Dot[$CellContext`M3, 
-          
-          Spline`H3[$CellContext`Coef3, $CellContext`M3, $CellContext`s$$, \
-$CellContext`c1$$, $CellContext`c2$$, $CellContext`e$$]]; Map[Expand[
-          Eigensystem[#]]& , 
-         SubSpaces`ListSubSpaces[$CellContext`poly4]], StandardForm],
-      ImageSizeCache->{726.0968750000001, {118.7, 25.265}}], "}"}]}], "}"}],
-  DynamicModuleValues:>{}]], "Output",
- CellChangeTimes->{
-  3.7536442751502028`*^9, 3.7536443112831583`*^9, 3.753644596353655*^9, 
-   3.7536447141186123`*^9, 3.753645137259728*^9, {3.753645199876906*^9, 
-   3.753645215897216*^9}, 3.7536452808665752`*^9, 3.753645408071249*^9, 
-   3.753645533430318*^9, 3.753645830069751*^9, 3.753645903688192*^9, 
-   3.7536461156164837`*^9, 3.753646172393447*^9, 3.75364625376822*^9, {
-   3.753646661629743*^9, 3.753646677295238*^9}, {3.753646716370719*^9, 
-   3.753646759738831*^9}, 3.753646930456806*^9, 3.753647896054028*^9, {
-   3.753647948328643*^9, 3.753647964839595*^9}, 3.753648059534083*^9, 
-   3.753648164957657*^9, 3.753650661862856*^9, 3.7536507046248693`*^9, 
-   3.75365119626262*^9, 3.753651762054998*^9, {3.753702642692883*^9, 
-   3.753702657443885*^9}, 3.753702697996277*^9, 3.753702729673354*^9, 
-   3.7537027817819653`*^9, 3.754049642660638*^9, 3.754050054947687*^9, 
-   3.754050343717188*^9, 3.7540515387538557`*^9, 3.754051868409156*^9, 
-   3.7544839174618273`*^9, 3.754484120319195*^9, 3.7544844926549473`*^9, 
-   3.754490862986189*^9, 3.754491754745071*^9, 3.754491868219825*^9, {
-   3.754491926728978*^9, 3.754491946403955*^9}, 3.754492475947712*^9, 
-   3.754493284496969*^9, 3.754494359929864*^9, 3.7562028441612387`*^9, 
-   3.756208464640965*^9, 3.756209097603735*^9, {3.7562091441199408`*^9, 
-   3.756209165270788*^9}, 3.756209241955143*^9, {3.7562097013213387`*^9, 
-   3.756209722392861*^9}, 3.756209855169066*^9, 3.756209961472846*^9, 
-   3.756210207076954*^9, 3.756210603001677*^9, 3.7562107210343657`*^9, 
-   3.756210955195856*^9, 3.7563692683641033`*^9, {3.756369697578506*^9, 
-   3.756369746147909*^9}, 3.756369830438759*^9, 3.756369965896613*^9, {
-   3.756370012575828*^9, 3.7563700423684883`*^9}, {3.756370114718501*^9, 
-   3.75637013525683*^9}, 3.756370354317325*^9, 3.75637123454996*^9},
- CellLabel->"Out[71]=",ExpressionUUID->"2f9d47a8-410c-4bb7-a444-55e0f8f6d511"],
-
-Cell[BoxData[
- DynamicModuleBox[{$CellContext`s$$ = {0, 0}, $CellContext`c1$$ = {
-   Rational[1, 3], 
-   Rational[1, 5]}, $CellContext`c2$$ = {
-   Rational[2, 3], 
-   Rational[1, 5]}, $CellContext`e$$ = {1, 0}}, 
-  RowBox[{"{", 
-   RowBox[{
-    GraphicsBox[{
-      DynamicBox[Typeset`ToBoxes[
-        Point[
-         Spline`arc3[$CellContext`Coef3, $CellContext`M3, $CellContext`s$$, \
-$CellContext`c1$$, $CellContext`c2$$, $CellContext`e$$]], StandardForm, 
-        Graphics],
-       ImageSizeCache->{{88.5, 136.5}, {-14.625, -1.5}}], 
-      LocatorBox[Dynamic[$CellContext`s$$]], 
-      LocatorBox[Dynamic[$CellContext`c1$$]], 
-      LocatorBox[Dynamic[$CellContext`c2$$]], 
-      LocatorBox[Dynamic[$CellContext`e$$]]},
-     PlotRange->2], ",", 
-    RowBox[{"{", 
-     DynamicBox[ToBoxes[$CellContext`poly5 = Dot[$CellContext`M3, 
-          
-          Spline`H3[$CellContext`Coef3, $CellContext`M3, $CellContext`s$$, \
-$CellContext`c1$$, $CellContext`c2$$, $CellContext`e$$]]; Map[Expand[
-          Eigensystem[#]]& , 
-         SubSpaces`ListSubSpaces[$CellContext`poly5]], StandardForm],
-      ImageSizeCache->{557.890625, {44., 19.64}}], "}"}]}], "}"}],
-  DynamicModuleValues:>{}]], "Output",
- CellChangeTimes->{
-  3.7536442751502028`*^9, 3.7536443112831583`*^9, 3.753644596353655*^9, 
-   3.7536447141186123`*^9, 3.753645137259728*^9, {3.753645199876906*^9, 
-   3.753645215897216*^9}, 3.7536452808665752`*^9, 3.753645408071249*^9, 
-   3.753645533430318*^9, 3.753645830069751*^9, 3.753645903688192*^9, 
-   3.7536461156164837`*^9, 3.753646172393447*^9, 3.75364625376822*^9, {
-   3.753646661629743*^9, 3.753646677295238*^9}, {3.753646716370719*^9, 
-   3.753646759738831*^9}, 3.753646930456806*^9, 3.753647896054028*^9, {
-   3.753647948328643*^9, 3.753647964839595*^9}, 3.753648059534083*^9, 
-   3.753648164957657*^9, 3.753650661862856*^9, 3.7536507046248693`*^9, 
-   3.75365119626262*^9, 3.753651762054998*^9, {3.753702642692883*^9, 
-   3.753702657443885*^9}, 3.753702697996277*^9, 3.753702729673354*^9, 
-   3.7537027817819653`*^9, 3.754049642660638*^9, 3.754050054947687*^9, 
-   3.754050343717188*^9, 3.7540515387538557`*^9, 3.754051868409156*^9, 
-   3.7544839174618273`*^9, 3.754484120319195*^9, 3.7544844926549473`*^9, 
-   3.754490862986189*^9, 3.754491754745071*^9, 3.754491868219825*^9, {
-   3.754491926728978*^9, 3.754491946403955*^9}, 3.754492475947712*^9, 
-   3.754493284496969*^9, 3.754494359929864*^9, 3.7562028441612387`*^9, 
-   3.756208464640965*^9, 3.756209097603735*^9, {3.7562091441199408`*^9, 
-   3.756209165270788*^9}, 3.756209241955143*^9, {3.7562097013213387`*^9, 
-   3.756209722392861*^9}, 3.756209855169066*^9, 3.756209961472846*^9, 
-   3.756210207076954*^9, 3.756210603001677*^9, 3.7562107210343657`*^9, 
-   3.756210955195856*^9, 3.7563692683641033`*^9, {3.756369697578506*^9, 
-   3.756369746147909*^9}, 3.756369830438759*^9, 3.756369965896613*^9, {
-   3.756370012575828*^9, 3.7563700423684883`*^9}, {3.756370114718501*^9, 
-   3.75637013525683*^9}, 3.756370354317325*^9, 3.75637123464032*^9},
- CellLabel->"Out[72]=",ExpressionUUID->"82a10d04-7f79-40da-a446-484e2d2c3afa"]
-}, Open  ]],
-
-Cell[CellGroupData[{
-
-Cell[BoxData[{
- RowBox[{
-  RowBox[{"MatrixForm", "[", 
-   RowBox[{"Coef4", "=", 
-    RowBox[{"{", 
-     RowBox[{
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0", ",", "0", ",", "0", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"-", "1"}], ",", "1", ",", "0", ",", "0", ",", "0"}], "}"}], 
-      ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", 
-        RowBox[{"-", "1"}], ",", "1", ",", "0", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0", ",", 
-        RowBox[{"-", "1"}], ",", "1", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0", ",", "0", ",", 
-        RowBox[{"-", "1"}], ",", "1"}], "}"}]}], "}"}]}], "]"}], 
-  ";"}], "\[IndentingNewLine]", 
- RowBox[{
-  RowBox[{"MatrixForm", "[", 
-   RowBox[{"M4", "=", 
-    RowBox[{"{", 
-     RowBox[{
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0", ",", "0", ",", "0", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "1", ",", "0", ",", "0", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0", ",", "1", ",", "0", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0", ",", "0", ",", "1", ",", "0"}], "}"}], ",", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0", ",", "0", ",", "0", ",", "1"}], "}"}]}], 
-     "}"}]}], "]"}], ";", 
-  RowBox[{"l3", "=", "2"}], ";", 
-  RowBox[{"x3", "=", 
-   RowBox[{
-    RowBox[{"(", 
-     RowBox[{"1", "/", "l3"}], ")"}], "*", 
-    RowBox[{"(", 
-     RowBox[{"Sin", "[", 
-      RowBox[{"1", "*", 
-       RowBox[{"Pi", "/", "4"}]}], "]"}], ")"}]}]}], ";", 
-  RowBox[{"y3", "=", 
-   RowBox[{
-    RowBox[{"(", 
-     RowBox[{"1", "/", "l3"}], ")"}], "*", 
-    RowBox[{"(", 
-     RowBox[{"Cos", "[", 
-      RowBox[{"1", "*", 
-       RowBox[{"Pi", "/", "4"}]}], "]"}], ")"}]}]}], 
-  ";"}], "\[IndentingNewLine]", 
- RowBox[{"DynamicModule", "[", 
-  RowBox[{
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"s", "=", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0"}], "}"}]}], ",", 
-     RowBox[{"c1", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{
-         RowBox[{"1", "/", "2"}], "-", "x3"}], ",", 
-        RowBox[{"0", "+", "y3"}]}], "}"}]}], ",", 
-     RowBox[{"c2", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"2", "/", "4"}], ",", 
-        RowBox[{"1", "/", "2"}]}], "}"}]}], ",", 
-     RowBox[{"c3", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{
-         RowBox[{"1", "/", "2"}], "+", "x3"}], ",", 
-        RowBox[{"0", "+", "y3"}]}], "}"}]}], ",", 
-     RowBox[{"e", "=", 
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0"}], "}"}]}]}], "}"}], ",", 
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"Dynamic", "[", 
-          RowBox[{"Point", "[", 
-           RowBox[{"arc4", "[", 
-            RowBox[{
-            "Coef4", ",", "M4", ",", "s", ",", "c1", ",", "c2", ",", "c3", 
-             ",", "e"}], "]"}], "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "s", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c1", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c2", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c3", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "e", "]"}], "]"}]}], "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
-     RowBox[{"{", 
-      RowBox[{"Dynamic", "[", 
-       RowBox[{
-        RowBox[{"poly6", "=", " ", 
-         RowBox[{"M4", ".", 
-          RowBox[{"H4", "[", 
-           RowBox[{
-           "Coef4", ",", "M4", ",", "s", ",", "c1", ",", "c2", ",", "c3", ",",
-             "e"}], "]"}]}]}], ";", 
-        RowBox[{
-         RowBox[{
-          RowBox[{"Expand", "[", 
-           RowBox[{"Eigensystem", "[", "#", "]"}], "]"}], "&"}], "/@", 
-         RowBox[{"ListSubSpaces", "[", "poly6", "]"}]}]}], "]"}], "}"}]}], 
-    "}"}]}], "]"}], "\[IndentingNewLine]", 
- RowBox[{"DynamicModule", "[", 
-  RowBox[{
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"s", "=", 
-      RowBox[{"{", 
-       RowBox[{"0", ",", "0"}], "}"}]}], ",", 
-     RowBox[{"c1", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"1", "/", "4"}], ",", 
-        RowBox[{"1", "/", "6"}]}], "}"}]}], ",", 
-     RowBox[{"c2", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"2", "/", "4"}], ",", 
-        RowBox[{"2", "/", "9"}]}], "}"}]}], ",", 
-     RowBox[{"c3", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"3", "/", "4"}], ",", 
-        RowBox[{"1", "/", "6"}]}], "}"}]}], ",", 
-     RowBox[{"e", "=", 
-      RowBox[{"{", 
-       RowBox[{"1", ",", "0"}], "}"}]}]}], "}"}], ",", 
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"Dynamic", "[", 
-          RowBox[{"Point", "[", 
-           RowBox[{"arc4", "[", 
-            RowBox[{
-            "Coef4", ",", "M4", ",", "s", ",", "c1", ",", "c2", ",", "c3", 
-             ",", "e"}], "]"}], "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "s", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c1", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c2", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c3", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "e", "]"}], "]"}]}], "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
-     RowBox[{"{", 
-      RowBox[{"Dynamic", "[", 
-       RowBox[{
-        RowBox[{"poly7", "=", " ", 
-         RowBox[{"M4", ".", 
-          RowBox[{"H4", "[", 
-           RowBox[{
-           "Coef4", ",", "M4", ",", "s", ",", "c1", ",", "c2", ",", "c3", ",",
-             "e"}], "]"}]}]}], ";", 
-        RowBox[{
-         RowBox[{
-          RowBox[{"Expand", "[", 
-           RowBox[{"Eigensystem", "[", "#", "]"}], "]"}], "&"}], "/@", 
-         RowBox[{"ListSubSpaces", "[", "poly7", "]"}]}]}], "]"}], "}"}]}], 
-    "}"}]}], "]"}]}], "Input",
- CellChangeTimes->{{3.75352098829558*^9, 3.753520995510291*^9}, {
-   3.753521789440345*^9, 3.753521859756032*^9}, {3.753639519297163*^9, 
-   3.7536395197072678`*^9}, {3.753639628196072*^9, 3.753639638703433*^9}, {
-   3.753639936824381*^9, 3.7536399627449007`*^9}, {3.753644643257105*^9, 
-   3.753644651385893*^9}, {3.753645104637027*^9, 3.753645110320312*^9}, {
-   3.753645422506155*^9, 3.753645498716555*^9}, {3.753651548999468*^9, 
-   3.7536515499214*^9}, {3.753651595373822*^9, 3.75365171341573*^9}, {
-   3.754049968340948*^9, 3.754049984438085*^9}, {3.754050068903783*^9, 
-   3.754050080661563*^9}, {3.7540501111682034`*^9, 3.754050150117704*^9}, {
-   3.754050235374084*^9, 3.75405025338431*^9}, 3.754050387844503*^9, {
-   3.7540511509211273`*^9, 3.754051172655856*^9}, {3.754051478070005*^9, 
-   3.7540515186424637`*^9}, {3.7540515835513477`*^9, 3.754051593086375*^9}, {
-   3.7544908281530437`*^9, 3.7544908462607527`*^9}, {3.754492680121202*^9, 
-   3.754492762740232*^9}, {3.7544932570945787`*^9, 3.75449327337422*^9}, {
-   3.7544943343816957`*^9, 3.754494334383944*^9}, {3.756208412474257*^9, 
-   3.756208425461*^9}, {3.756209739463132*^9, 3.756209793012476*^9}, {
-   3.756210700678748*^9, 3.7562107155569687`*^9}, {3.7563692402218943`*^9, 
-   3.756369259786265*^9}, {3.7563699304855633`*^9, 3.756369959703121*^9}, {
-   3.756370107686658*^9, 3.7563701096109962`*^9}, {3.756370394978895*^9, 
-   3.756370419071844*^9}, {3.7563704541484118`*^9, 3.756370527549518*^9}, {
-   3.7563705675354843`*^9, 3.7563705778798103`*^9}, {3.75637066385946*^9, 
-   3.756370803915923*^9}},
- CellLabel->"In[73]:=",ExpressionUUID->"5aa70448-c70b-4324-8969-c157f8a502cc"],
-
-Cell[BoxData[
- DynamicModuleBox[{$CellContext`s$$ = {0, 0}, $CellContext`c1$$ = {
-  Rational[1, 2] + Rational[-1, 2] 2^Rational[-1, 2], Rational[1, 2] 
-   2^Rational[-1, 2]}, $CellContext`c2$$ = {
-   Rational[1, 2], 
-   Rational[1, 2]}, $CellContext`c3$$ = {
-  Rational[1, 2] + Rational[1, 2] 2^Rational[-1, 2], Rational[1, 2] 
-   2^Rational[-1, 2]}, $CellContext`e$$ = {1, 0}}, 
-  RowBox[{"{", 
-   RowBox[{
-    GraphicsBox[{
-      DynamicBox[Typeset`ToBoxes[
-        Point[
-         Spline`arc4[$CellContext`Coef4, $CellContext`M4, $CellContext`s$$, \
-$CellContext`c1$$, $CellContext`c2$$, $CellContext`c3$$, $CellContext`e$$]], 
-        StandardForm, Graphics],
-       ImageSizeCache->{{88.5, 136.5}, {-26.999999999999996`, -1.5}}], 
-      LocatorBox[Dynamic[$CellContext`s$$]], 
-      LocatorBox[Dynamic[$CellContext`c1$$]], 
-      LocatorBox[Dynamic[$CellContext`c2$$]], 
-      LocatorBox[Dynamic[$CellContext`c3$$]], 
-      LocatorBox[Dynamic[$CellContext`e$$]]},
-     PlotRange->2], ",", 
-    RowBox[{"{", 
-     DynamicBox[ToBoxes[$CellContext`poly6 = Dot[$CellContext`M4, 
-          
-          Spline`H4[$CellContext`Coef4, $CellContext`M4, $CellContext`s$$, \
-$CellContext`c1$$, $CellContext`c2$$, $CellContext`c3$$, $CellContext`e$$]]; 
-       Map[Expand[
-          Eigensystem[#]]& , 
-         SubSpaces`ListSubSpaces[$CellContext`poly6]], StandardForm],
-      ImageSizeCache->{799.13125, {254., 25.265}}], "}"}]}], "}"}],
-  DynamicModuleValues:>{}]], "Output",
- CellChangeTimes->{{3.7535217936252937`*^9, 3.753521830288795*^9}, 
-   3.753521863521718*^9, {3.75363945820516*^9, 3.753639498286676*^9}, 
-   3.753639530435408*^9, 3.7536396476299677`*^9, 3.753639710872081*^9, 
-   3.753639981764551*^9, 3.753640074158125*^9, 3.753644275567021*^9, 
-   3.753644312300482*^9, 3.7536445969520187`*^9, 3.753644714600988*^9, 
-   3.753645137644857*^9, {3.753645203561022*^9, 3.753645220013073*^9}, 
-   3.7536452813060226`*^9, 3.753645408971217*^9, 3.7536455348563023`*^9, 
-   3.753645831311658*^9, 3.753645904527769*^9, 3.753646116969626*^9, 
-   3.75364617386683*^9, 3.753646255147011*^9, {3.753646662793212*^9, 
-   3.753646677960086*^9}, {3.7536467167287903`*^9, 3.753646760309927*^9}, 
-   3.753646931303762*^9, 3.753647896538409*^9, {3.753647948810421*^9, 
-   3.7536479656139717`*^9}, 3.753648059960773*^9, 3.753648165389739*^9, 
-   3.753650662249325*^9, 3.7536507053474903`*^9, 3.753651196848888*^9, 
-   3.753651763641247*^9, {3.753702643509305*^9, 3.7537026582182817`*^9}, 
-   3.7537026992180443`*^9, 3.753702730145419*^9, 3.7537027824410267`*^9, 
-   3.754049643468505*^9, 3.754049986641244*^9, {3.754050056082672*^9, 
-   3.7540500859371367`*^9}, 3.754050160357607*^9, 3.7540502574867573`*^9, 
-   3.754050344849202*^9, 3.754050393007547*^9, 3.754051178464005*^9, 
-   3.754051540231432*^9, 3.75405159803508*^9, 3.754051868854401*^9, 
-   3.75448391828279*^9, 3.754484120981249*^9, 3.754484493452591*^9, 
-   3.754490863694869*^9, 3.754491755559185*^9, 3.754492476399428*^9, {
-   3.754492691685191*^9, 3.7544927192064667`*^9}, {3.754492750228512*^9, 
-   3.75449276520008*^9}, 3.754493285248043*^9, 3.754494360631809*^9, 
-   3.756202844564455*^9, 3.756208465299128*^9, 3.756209098180015*^9, {
-   3.7562091445051107`*^9, 3.756209165665201*^9}, 3.756209242644396*^9, 
-   3.7562097949599648`*^9, 3.756209855390291*^9, 3.7562099618277607`*^9, 
-   3.756210207292482*^9, 3.756210603361829*^9, 3.756210721274468*^9, 
-   3.756210955678162*^9, 3.7563692689857073`*^9, {3.756369697791483*^9, 
-   3.756369746356926*^9}, 3.756369830641162*^9, 3.756369966185974*^9, {
-   3.756370013427857*^9, 3.756370043079008*^9}, {3.756370114812118*^9, 
-   3.756370135490859*^9}, 3.756370354703096*^9, 3.7563704206685534`*^9, 
-   3.75637045694972*^9, 3.7563704977401743`*^9, 3.756370528669601*^9, 
-   3.756370579227922*^9, {3.7563706712476997`*^9, 3.756370805185721*^9}, 
-   3.7563712350271378`*^9},
- CellLabel->"Out[75]=",ExpressionUUID->"8a80e97b-f0f1-4ff5-bb98-2ad037d70452"],
-
-Cell[BoxData[
- DynamicModuleBox[{$CellContext`s$$ = {0, 0}, $CellContext`c1$$ = {
-   Rational[1, 4], 
-   Rational[1, 6]}, $CellContext`c2$$ = {
-   Rational[1, 2], 
-   Rational[2, 9]}, $CellContext`c3$$ = {
-   Rational[3, 4], 
-   Rational[1, 6]}, $CellContext`e$$ = {1, 0}}, 
-  RowBox[{"{", 
-   RowBox[{
-    GraphicsBox[{
-      DynamicBox[Typeset`ToBoxes[
-        Point[
-         Spline`arc4[$CellContext`Coef4, $CellContext`M4, $CellContext`s$$, \
-$CellContext`c1$$, $CellContext`c2$$, $CellContext`c3$$, $CellContext`e$$]], 
-        StandardForm, Graphics],
-       ImageSizeCache->{{88.5, 136.5}, {-14.5, -1.5}}], 
-      LocatorBox[Dynamic[$CellContext`s$$]], 
-      LocatorBox[Dynamic[$CellContext`c1$$]], 
-      LocatorBox[Dynamic[$CellContext`c2$$]], 
-      LocatorBox[Dynamic[$CellContext`c3$$]], 
-      LocatorBox[Dynamic[$CellContext`e$$]]},
-     PlotRange->2], ",", 
-    RowBox[{"{", 
-     DynamicBox[ToBoxes[$CellContext`poly7 = Dot[$CellContext`M4, 
-          
-          Spline`H4[$CellContext`Coef4, $CellContext`M4, $CellContext`s$$, \
-$CellContext`c1$$, $CellContext`c2$$, $CellContext`c3$$, $CellContext`e$$]]; 
-       Map[Expand[
-          Eigensystem[#]]& , 
-         SubSpaces`ListSubSpaces[$CellContext`poly7]], StandardForm],
-      ImageSizeCache->{766.034375, {67., 19.64}}], "}"}]}], "}"}],
-  DynamicModuleValues:>{}]], "Output",
- CellChangeTimes->{{3.7535217936252937`*^9, 3.753521830288795*^9}, 
-   3.753521863521718*^9, {3.75363945820516*^9, 3.753639498286676*^9}, 
-   3.753639530435408*^9, 3.7536396476299677`*^9, 3.753639710872081*^9, 
-   3.753639981764551*^9, 3.753640074158125*^9, 3.753644275567021*^9, 
-   3.753644312300482*^9, 3.7536445969520187`*^9, 3.753644714600988*^9, 
-   3.753645137644857*^9, {3.753645203561022*^9, 3.753645220013073*^9}, 
-   3.7536452813060226`*^9, 3.753645408971217*^9, 3.7536455348563023`*^9, 
-   3.753645831311658*^9, 3.753645904527769*^9, 3.753646116969626*^9, 
-   3.75364617386683*^9, 3.753646255147011*^9, {3.753646662793212*^9, 
-   3.753646677960086*^9}, {3.7536467167287903`*^9, 3.753646760309927*^9}, 
-   3.753646931303762*^9, 3.753647896538409*^9, {3.753647948810421*^9, 
-   3.7536479656139717`*^9}, 3.753648059960773*^9, 3.753648165389739*^9, 
-   3.753650662249325*^9, 3.7536507053474903`*^9, 3.753651196848888*^9, 
-   3.753651763641247*^9, {3.753702643509305*^9, 3.7537026582182817`*^9}, 
-   3.7537026992180443`*^9, 3.753702730145419*^9, 3.7537027824410267`*^9, 
-   3.754049643468505*^9, 3.754049986641244*^9, {3.754050056082672*^9, 
-   3.7540500859371367`*^9}, 3.754050160357607*^9, 3.7540502574867573`*^9, 
-   3.754050344849202*^9, 3.754050393007547*^9, 3.754051178464005*^9, 
-   3.754051540231432*^9, 3.75405159803508*^9, 3.754051868854401*^9, 
-   3.75448391828279*^9, 3.754484120981249*^9, 3.754484493452591*^9, 
-   3.754490863694869*^9, 3.754491755559185*^9, 3.754492476399428*^9, {
-   3.754492691685191*^9, 3.7544927192064667`*^9}, {3.754492750228512*^9, 
-   3.75449276520008*^9}, 3.754493285248043*^9, 3.754494360631809*^9, 
-   3.756202844564455*^9, 3.756208465299128*^9, 3.756209098180015*^9, {
-   3.7562091445051107`*^9, 3.756209165665201*^9}, 3.756209242644396*^9, 
-   3.7562097949599648`*^9, 3.756209855390291*^9, 3.7562099618277607`*^9, 
-   3.756210207292482*^9, 3.756210603361829*^9, 3.756210721274468*^9, 
-   3.756210955678162*^9, 3.7563692689857073`*^9, {3.756369697791483*^9, 
-   3.756369746356926*^9}, 3.756369830641162*^9, 3.756369966185974*^9, {
-   3.756370013427857*^9, 3.756370043079008*^9}, {3.756370114812118*^9, 
-   3.756370135490859*^9}, 3.756370354703096*^9, 3.7563704206685534`*^9, 
-   3.75637045694972*^9, 3.7563704977401743`*^9, 3.756370528669601*^9, 
-   3.756370579227922*^9, {3.7563706712476997`*^9, 3.756370805185721*^9}, 
-   3.756371235119475*^9},
- CellLabel->"Out[76]=",ExpressionUUID->"d3f16378-d030-433d-a9b5-482bda8088ed"]
-}, Open  ]]
-},
-WindowSize->{949, 957},
-WindowMargins->{{Automatic, 78}, {Automatic, 38}},
-FrontEndVersion->"11.3 for Linux x86 (64-bit) (March 6, 2018)",
-StyleDefinitions->"Default.nb"
-]
-(* End of Notebook Content *)
-
-(* Internal cache information *)
-(*CellTagsOutline
-CellTagsIndex->{}
-*)
-(*CellTagsIndex
-CellTagsIndex->{}
-*)
-(*NotebookFileOutline
-Notebook[{
-Cell[558, 20, 241, 6, 31, "Input",ExpressionUUID->"50fcc07e-b04b-4b06-be90-516d39e07f29"],
-Cell[802, 28, 342, 6, 31, "Input",ExpressionUUID->"dc37c5c1-800f-42da-88ac-3d4a585491bb"],
-Cell[CellGroupData[{
-Cell[1169, 38, 3086, 76, 147, "Input",ExpressionUUID->"af07487f-0f3b-4347-96f1-f47706dc5442"],
-Cell[4258, 116, 2606, 46, 199, "Output",ExpressionUUID->"133f418f-7d6a-4567-a8bf-39ccf019329c"]
-}, Open  ]],
-Cell[CellGroupData[{
-Cell[6901, 167, 5556, 152, 308, "Input",ExpressionUUID->"5d70f809-3415-4942-baca-6a1b97b567af"],
-Cell[12460, 321, 2626, 45, 251, "Output",ExpressionUUID->"0eb06d35-9fbd-45af-bb36-6fdc3ebd68d3"],
-Cell[15089, 368, 2550, 45, 199, "Output",ExpressionUUID->"751dd17c-ed1f-45f8-9f2e-0160144bc660"]
-}, Open  ]],
-Cell[CellGroupData[{
-Cell[17676, 418, 7087, 195, 354, "Input",ExpressionUUID->"276d508d-f653-4fc6-9da7-c2489ee10b6e"],
-Cell[24766, 615, 3383, 59, 380, "Output",ExpressionUUID->"2f9d47a8-410c-4bb7-a444-55e0f8f6d511"],
-Cell[28152, 676, 3095, 55, 199, "Output",ExpressionUUID->"82a10d04-7f79-40da-a446-484e2d2c3afa"]
-}, Open  ]],
-Cell[CellGroupData[{
-Cell[31284, 736, 7892, 206, 354, "Input",ExpressionUUID->"5aa70448-c70b-4324-8969-c157f8a502cc"],
-Cell[39179, 944, 3948, 67, 560, "Output",ExpressionUUID->"8a80e97b-f0f1-4ff5-bb98-2ad037d70452"],
-Cell[43130, 1013, 3825, 67, 348, "Output",ExpressionUUID->"d3f16378-d030-433d-a9b5-482bda8088ed"]
-}, Open  ]]
-}
-]
-*)
-
+(* Content-type: application/vnd.wolfram.mathematica *)
+
+(*** Wolfram Notebook File ***)
+(* http://www.wolfram.com/nb *)
+
+(* CreatedBy='Mathematica 11.3' *)
+
+(*CacheID: 234*)
+(* Internal cache information:
+NotebookFileLineBreakTest
+NotebookFileLineBreakTest
+NotebookDataPosition[       158,          7]
+NotebookDataLength[     49144,       1117]
+NotebookOptionsPosition[     47506,       1083]
+NotebookOutlinePosition[     47897,       1099]
+CellTagsIndexPosition[     47854,       1096]
+WindowFrame->Normal*)
+
+(* Beginning of Notebook Content *)
+Notebook[{
+Cell[BoxData[
+ RowBox[{"ClearAll", "[", 
+  RowBox[{"Evaluate", "[", 
+   RowBox[{
+    RowBox[{"Context", "[", "]"}], "<>", "\"\<*\>\""}], "]"}], "]"}]], "Input",
+ CellLabel->"In[65]:=",ExpressionUUID->"50fcc07e-b04b-4b06-be90-516d39e07f29"],
+
+Cell[BoxData[
+ RowBox[{
+  RowBox[{"Needs", "[", "\"\<Spline`\>\"", "]"}], ";", 
+  RowBox[{"Needs", "[", "\"\<SubSpaces`\>\"", "]"}]}]], "Input",
+ CellChangeTimes->{{3.753702624847374*^9, 3.753702651682048*^9}, {
+  3.7562091338207912`*^9, 3.7562091398916073`*^9}},
+ CellLabel->"In[66]:=",ExpressionUUID->"dc37c5c1-800f-42da-88ac-3d4a585491bb"],
+
+Cell[CellGroupData[{
+
+Cell[BoxData[
+ RowBox[{"DynamicModule", "[", 
+  RowBox[{
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"s", "=", 
+      RowBox[{"{", 
+       RowBox[{"0", ",", "0"}], "}"}]}], ",", 
+     RowBox[{"e", "=", 
+      RowBox[{"{", 
+       RowBox[{"1", ",", "0"}], "}"}]}]}], "}"}], ",", 
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"Dynamic", "[", 
+          RowBox[{"Point", "[", 
+           RowBox[{"arc1", "[", 
+            RowBox[{"s", ",", "e"}], "]"}], "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "s", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "e", "]"}], "]"}]}], "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
+     RowBox[{"{", 
+      RowBox[{"Dynamic", "[", 
+       RowBox[{
+        RowBox[{"poly1", "=", " ", 
+         RowBox[{"H1", "[", 
+          RowBox[{
+           RowBox[{"pascalMatrix", "[", "2", "]"}], ",", 
+           RowBox[{"IdentityMatrix", "[", "2", "]"}], ",", "s", ",", "e"}], 
+          "]"}]}], ";", 
+        RowBox[{"cps1", "=", 
+         RowBox[{"Map", "[", 
+          RowBox[{
+           RowBox[{"Function", "[", 
+            RowBox[{"sub1", ",", 
+             RowBox[{"CharacteristicPolynomial", "[", 
+              RowBox[{"sub1", ",", "t"}], "]"}]}], "]"}], ",", 
+           RowBox[{"ListSubSpaces", "[", "poly1", "]"}]}], "]"}]}], ";", 
+        RowBox[{"Map", "[", 
+         RowBox[{
+          RowBox[{"Function", "[", 
+           RowBox[{"cp1", ",", 
+            RowBox[{"{", 
+             RowBox[{"cp1", ",", 
+              RowBox[{"Plot", "[", 
+               RowBox[{"cp1", ",", 
+                RowBox[{"{", 
+                 RowBox[{"t", ",", "0", ",", "1"}], "}"}]}], "]"}]}], "}"}]}],
+            "]"}], ",", "cps1"}], "]"}]}], "]"}], "}"}]}], "}"}]}], 
+  "]"}]], "Input",
+ CellChangeTimes->{{3.753647826762274*^9, 3.753647880150669*^9}, 
+   3.753647910990225*^9, 3.753647956047772*^9, {3.754051357194474*^9, 
+   3.754051375763378*^9}, {3.7544907583082743`*^9, 3.754490759418449*^9}, {
+   3.754493202534712*^9, 3.754493207290389*^9}, 3.754494334324523*^9, {
+   3.756202908250494*^9, 3.756202940289824*^9}, {3.756208614257291*^9, 
+   3.75620861729255*^9}, {3.7562086919980917`*^9, 3.7562087164388943`*^9}, {
+   3.7562087575876904`*^9, 3.7562087600865498`*^9}, {3.756208807900044*^9, 
+   3.7562088316229753`*^9}, {3.756208913210165*^9, 3.756208934547175*^9}, {
+   3.756209115618925*^9, 3.7562091293772583`*^9}, {3.756209177255796*^9, 
+   3.756209190652864*^9}, {3.756209236601375*^9, 3.756209255119244*^9}, {
+   3.756209317142363*^9, 3.756209327001225*^9}, 3.7562093704289722`*^9, {
+   3.756209493111932*^9, 3.7562094937007008`*^9}, {3.756210616723448*^9, 
+   3.756210621768497*^9}, {3.756381355066736*^9, 3.756381373600576*^9}, {
+   3.7563814290786037`*^9, 3.756381524328334*^9}, {3.75638155440003*^9, 
+   3.75638162335189*^9}, {3.756381669005908*^9, 3.7563816751182756`*^9}, {
+   3.756381752314064*^9, 3.756381796610859*^9}, {3.75638187953824*^9, 
+   3.756381953387698*^9}, {3.756382034335*^9, 3.75638203853331*^9}, {
+   3.7563821836493263`*^9, 3.756382258646069*^9}, {3.8062498279054832`*^9, 
+   3.8062498310154653`*^9}, 3.806249903493571*^9, 3.806298636732834*^9, {
+   3.8062994968304873`*^9, 3.806299506902216*^9}, {3.8063005876794996`*^9, 
+   3.8063005924562907`*^9}},
+ CellLabel->"In[67]:=",ExpressionUUID->"af07487f-0f3b-4347-96f1-f47706dc5442"],
+
+Cell[BoxData[
+ DynamicModuleBox[{$CellContext`s$$ = {0, 0}, $CellContext`e$$ = {1, 0}}, 
+  RowBox[{"{", 
+   RowBox[{
+    GraphicsBox[{
+      DynamicBox[Typeset`ToBoxes[
+        Point[
+         Spline`arc1[$CellContext`s$$, $CellContext`e$$]], StandardForm, 
+        Graphics],
+       ImageSizeCache->{{88.5, 136.5}, {-3.5, -0.5}}], 
+      LocatorBox[Dynamic[$CellContext`s$$]], 
+      LocatorBox[Dynamic[$CellContext`e$$]]},
+     PlotRange->2], ",", 
+    RowBox[{"{", 
+     DynamicBox[ToBoxes[$CellContext`poly1 = Spline`H1[
+          Spline`pascalMatrix[2], 
+          IdentityMatrix[
+          2], $CellContext`s$$, $CellContext`e$$]; $CellContext`cps1 = Map[
+          Function[$CellContext`sub1, 
+           CharacteristicPolynomial[$CellContext`sub1, $CellContext`t]], 
+          SubSpaces`ListSubSpaces[$CellContext`poly1]]; Map[
+         Function[$CellContext`cp1, {$CellContext`cp1, 
+           
+           Plot[$CellContext`cp1, {$CellContext`t, 0, 
+             1}]}], $CellContext`cps1], StandardForm],
+      ImageSizeCache->{239., {54., 58.}}], "}"}]}], "}"}],
+  DynamicModuleValues:>{}]], "Output",
+ CellChangeTimes->{
+  3.7536478955333557`*^9, {3.7536479475604362`*^9, 3.7536479639347963`*^9}, 
+   3.7536480588698683`*^9, 3.753648164285756*^9, 3.7536506614158916`*^9, 
+   3.753650703490481*^9, 3.753651192986566*^9, 3.7536517557303047`*^9, {
+   3.753702641710807*^9, 3.753702656534095*^9}, 3.7537026966354303`*^9, 
+   3.7537027278789377`*^9, 3.753702778008477*^9, 3.754049641728168*^9, 
+   3.754050050324438*^9, 3.754050339675961*^9, 3.754051534404728*^9, 
+   3.75405186595748*^9, 3.754483916397828*^9, 3.754484116973093*^9, 
+   3.75448449135192*^9, 3.754490858022478*^9, 3.754491753600704*^9, 
+   3.754492473818857*^9, 3.754493282404735*^9, 3.754494358860622*^9, 
+   3.756202843518077*^9, {3.756202918843285*^9, 3.7562029528363743`*^9}, 
+   3.756208460972535*^9, 3.756208630279348*^9, {3.756208693339801*^9, 
+   3.7562087176436367`*^9}, 3.756208767744597*^9, {3.756208821188278*^9, 
+   3.7562088325570374`*^9}, {3.756208914204125*^9, 3.756208935373376*^9}, {
+   3.75620909715893*^9, 3.756209192781035*^9}, {3.756209241563202*^9, 
+   3.756209255863587*^9}, 3.756209332348178*^9, 3.756209371418935*^9, {
+   3.7562094829009027`*^9, 3.7562094956286173`*^9}, 3.756209854129446*^9, 
+   3.7562099612191677`*^9, 3.756210205871806*^9, {3.756210602711171*^9, 
+   3.756210623211475*^9}, 3.7562107200259733`*^9, 3.756210954868672*^9, 
+   3.7563809931145477`*^9, 3.756381359996889*^9, 3.756381525377219*^9, {
+   3.7563817892929907`*^9, 3.75638181694016*^9}, 3.756381880628499*^9, {
+   3.75638192343869*^9, 3.756381955592681*^9}, {3.756382014044818*^9, 
+   3.756382039467905*^9}, {3.756382197689049*^9, 3.756382225275826*^9}, 
+   3.7563822596913633`*^9, 3.756383387862844*^9, 3.806249796071463*^9, 
+   3.806249909223608*^9, 3.8062518552876167`*^9, 3.8062987473102894`*^9, 
+   3.8062996127618165`*^9, 3.806300673778653*^9, {3.8063007753694496`*^9, 
+   3.8063007869911823`*^9}, 3.807187402471902*^9},
+ CellLabel->"Out[67]=",ExpressionUUID->"d33083ee-e84c-4867-9b1a-322eed42e341"]
+}, Open  ]],
+
+Cell[CellGroupData[{
+
+Cell[BoxData[{
+ RowBox[{
+  RowBox[{"l2", "=", 
+   RowBox[{"(", 
+    RowBox[{"2", "*", 
+     RowBox[{"Cos", "[", 
+      RowBox[{"3", "*", 
+       RowBox[{"Pi", "/", "8"}]}], "]"}]}], ")"}]}], ";", 
+  RowBox[{"x2", "=", 
+   RowBox[{
+    RowBox[{"(", 
+     RowBox[{"1", "/", "l2"}], ")"}], "*", "0"}]}], ";", 
+  RowBox[{"y2", "=", 
+   RowBox[{
+    RowBox[{"(", 
+     RowBox[{"1", "/", "l2"}], ")"}], "*", 
+    RowBox[{"(", 
+     RowBox[{"1", "-", 
+      RowBox[{"Sin", "[", 
+       RowBox[{"3", "*", 
+        RowBox[{"Pi", "/", "8"}]}], "]"}]}], ")"}]}]}], ";", 
+  RowBox[{"DynamicModule", "[", 
+   RowBox[{
+    RowBox[{"{", 
+     RowBox[{
+      RowBox[{"s", "=", 
+       RowBox[{"{", 
+        RowBox[{"0", ",", "0"}], "}"}]}], ",", 
+      RowBox[{"c1", "=", 
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{
+          RowBox[{"1", "/", "2"}], "+", "x2"}], ",", 
+         RowBox[{"0", "+", "y2"}]}], "}"}]}], ",", 
+      RowBox[{"e", "=", 
+       RowBox[{"{", 
+        RowBox[{"1", ",", "0"}], "}"}]}]}], "}"}], ",", 
+    RowBox[{"{", 
+     RowBox[{
+      RowBox[{"Graphics", "[", 
+       RowBox[{
+        RowBox[{"{", 
+         RowBox[{
+          RowBox[{"Dynamic", "[", 
+           RowBox[{"Point", "[", 
+            RowBox[{"arc2", "[", 
+             RowBox[{"s", ",", "c1", ",", "e"}], "]"}], "]"}], "]"}], ",", 
+          RowBox[{"Locator", "[", 
+           RowBox[{"Dynamic", "[", "s", "]"}], "]"}], ",", 
+          RowBox[{"Locator", "[", 
+           RowBox[{"Dynamic", "[", "c1", "]"}], "]"}], ",", 
+          RowBox[{"Locator", "[", 
+           RowBox[{"Dynamic", "[", "e", "]"}], "]"}]}], "}"}], ",", 
+        RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
+      RowBox[{"{", 
+       RowBox[{"Dynamic", "[", 
+        RowBox[{
+         RowBox[{"poly2", "=", " ", 
+          RowBox[{"H2", "[", 
+           RowBox[{
+            RowBox[{"pascalMatrix", "[", "3", "]"}], ",", 
+            RowBox[{"IdentityMatrix", "[", "3", "]"}], ",", "s", ",", "c1", 
+            ",", "e"}], "]"}]}], ";", 
+         RowBox[{"cps2", "=", 
+          RowBox[{"Map", "[", 
+           RowBox[{
+            RowBox[{"Function", "[", 
+             RowBox[{"sub2", ",", 
+              RowBox[{"CharacteristicPolynomial", "[", 
+               RowBox[{"sub2", ",", "t"}], "]"}]}], "]"}], ",", 
+            RowBox[{"ListSubSpaces", "[", "poly2", "]"}]}], "]"}]}], ";", 
+         RowBox[{"Map", "[", 
+          RowBox[{
+           RowBox[{"Function", "[", 
+            RowBox[{"cp2", ",", 
+             RowBox[{"{", 
+              RowBox[{"cp2", ",", 
+               RowBox[{"Plot", "[", 
+                RowBox[{"cp2", ",", 
+                 RowBox[{"{", 
+                  RowBox[{"t", ",", "0", ",", "1"}], "}"}]}], "]"}]}], 
+              "}"}]}], "]"}], ",", "cps2"}], "]"}]}], "]"}], "}"}]}], "}"}]}],
+    "]"}]}], "\[IndentingNewLine]", 
+ RowBox[{"DynamicModule", "[", 
+  RowBox[{
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"s", "=", 
+      RowBox[{"{", 
+       RowBox[{"0", ",", "0"}], "}"}]}], ",", 
+     RowBox[{"c1", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{"1", "/", "2"}], ",", 
+        RowBox[{"1", "/", "4"}]}], "}"}]}], ",", 
+     RowBox[{"e", "=", 
+      RowBox[{"{", 
+       RowBox[{"1", ",", "0"}], "}"}]}]}], "}"}], ",", 
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"Dynamic", "[", 
+          RowBox[{"Point", "[", 
+           RowBox[{"arc2", "[", 
+            RowBox[{"s", ",", "c1", ",", "e"}], "]"}], "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "s", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c1", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "e", "]"}], "]"}]}], "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
+     RowBox[{"{", 
+      RowBox[{"Dynamic", "[", 
+       RowBox[{
+        RowBox[{"poly3", "=", " ", 
+         RowBox[{"H2", "[", 
+          RowBox[{
+           RowBox[{"pascalMatrix", "[", "3", "]"}], ",", 
+           RowBox[{"IdentityMatrix", "[", "3", "]"}], ",", "s", ",", "c1", 
+           ",", "e"}], "]"}]}], ";", 
+        RowBox[{"cps3", "=", 
+         RowBox[{"Map", "[", 
+          RowBox[{
+           RowBox[{"Function", "[", 
+            RowBox[{"sub3", ",", 
+             RowBox[{"CharacteristicPolynomial", "[", 
+              RowBox[{"sub3", ",", "t"}], "]"}]}], "]"}], ",", 
+           RowBox[{"ListSubSpaces", "[", "poly3", "]"}]}], "]"}]}], ";", 
+        RowBox[{"Map", "[", 
+         RowBox[{
+          RowBox[{"Function", "[", 
+           RowBox[{"cp3", ",", 
+            RowBox[{"{", 
+             RowBox[{"cp3", ",", 
+              RowBox[{"Plot", "[", 
+               RowBox[{"cp3", ",", 
+                RowBox[{"{", 
+                 RowBox[{"t", ",", "0", ",", "1"}], "}"}]}], "]"}]}], "}"}]}],
+            "]"}], ",", "cps3"}], "]"}]}], "]"}], "}"}]}], "}"}]}], 
+  "]"}]}], "Input",
+ CellChangeTimes->{{3.7536466190737553`*^9, 3.7536466719614697`*^9}, 
+   3.753646753662656*^9, {3.75364688998379*^9, 3.753646913827547*^9}, {
+   3.753650523944252*^9, 3.75365054370264*^9}, {3.753650594547327*^9, 
+   3.753650642661845*^9}, {3.753650688598794*^9, 3.753650693699232*^9}, {
+   3.754051329285913*^9, 3.7540513443693047`*^9}, {3.754051391925915*^9, 
+   3.754051415646282*^9}, {3.754490772337388*^9, 3.754490781866642*^9}, {
+   3.7544932122532578`*^9, 3.7544932249699297`*^9}, {3.754494334332129*^9, 
+   3.754494334334861*^9}, {3.7562083546348047`*^9, 3.756208370951894*^9}, {
+   3.75620952340477*^9, 3.75620956239399*^9}, {3.75620960545441*^9, 
+   3.756209625139511*^9}, {3.756210129642592*^9, 3.75621013008772*^9}, {
+   3.756210638508424*^9, 3.756210655237959*^9}, {3.756382299824771*^9, 
+   3.756382314004757*^9}, {3.756382380962267*^9, 3.756382424986185*^9}, {
+   3.7563824864538813`*^9, 3.756382533445814*^9}, {3.806249847198207*^9, 
+   3.8062498545565977`*^9}, 3.806249895740744*^9, {3.806298650815097*^9, 
+   3.806298657663802*^9}, {3.806299511740763*^9, 3.806299534443925*^9}, {
+   3.806300602408326*^9, 3.806300608329013*^9}},
+ CellLabel->"In[68]:=",ExpressionUUID->"5d70f809-3415-4942-baca-6a1b97b567af"],
+
+Cell[BoxData[
+ DynamicModuleBox[{$CellContext`s$$ = {0, 0}, $CellContext`c1$$ = {
+   Rational[1, 2], Rational[1, 2] (1 - Cos[Rational[1, 8] Pi]) 
+   Csc[Rational[1, 8] Pi]}, $CellContext`e$$ = {1, 0}}, 
+  RowBox[{"{", 
+   RowBox[{
+    GraphicsBox[{
+      DynamicBox[Typeset`ToBoxes[
+        Point[
+         Spline`arc2[$CellContext`s$$, $CellContext`c1$$, $CellContext`e$$]], 
+        StandardForm, Graphics],
+       ImageSizeCache->{{88.5, 136.5}, {-7.975528266042306, -0.5}}], 
+      LocatorBox[Dynamic[$CellContext`s$$]], 
+      LocatorBox[Dynamic[$CellContext`c1$$]], 
+      LocatorBox[Dynamic[$CellContext`e$$]]},
+     PlotRange->2], ",", 
+    RowBox[{"{", 
+     DynamicBox[ToBoxes[$CellContext`poly2 = Spline`H2[
+          Spline`pascalMatrix[3], 
+          IdentityMatrix[
+          3], $CellContext`s$$, $CellContext`c1$$, $CellContext`e$$]; \
+$CellContext`cps2 = Map[
+          Function[$CellContext`sub2, 
+           CharacteristicPolynomial[$CellContext`sub2, $CellContext`t]], 
+          SubSpaces`ListSubSpaces[$CellContext`poly2]]; Map[
+         Function[$CellContext`cp2, {$CellContext`cp2, 
+           
+           Plot[$CellContext`cp2, {$CellContext`t, 0, 
+             1}]}], $CellContext`cps2], StandardForm],
+      ImageSizeCache->{702.35625, {46., 51.}}], "}"}]}], "}"}],
+  DynamicModuleValues:>{}]], "Output",
+ CellChangeTimes->{
+  3.756382426411004*^9, 3.756382535302038*^9, 3.756383389292183*^9, 
+   3.806249796110092*^9, 3.8062499098938074`*^9, 3.806251855325732*^9, 
+   3.8062987474901805`*^9, 3.8062996138548555`*^9, 3.8063006738136215`*^9, {
+   3.8063007754141636`*^9, 3.806300787030478*^9}, 3.807187402547944*^9},
+ CellLabel->"Out[68]=",ExpressionUUID->"115a9f53-2625-4b34-a005-487d1430b3db"],
+
+Cell[BoxData[
+ DynamicModuleBox[{$CellContext`s$$ = {0, 0}, $CellContext`c1$$ = {
+   Rational[1, 2], 
+   Rational[1, 4]}, $CellContext`e$$ = {1, 0}}, 
+  RowBox[{"{", 
+   RowBox[{
+    GraphicsBox[{
+      DynamicBox[Typeset`ToBoxes[
+        Point[
+         Spline`arc2[$CellContext`s$$, $CellContext`c1$$, $CellContext`e$$]], 
+        StandardForm, Graphics],
+       ImageSizeCache->{{88.5, 136.5}, {-14.75, -0.5}}], 
+      LocatorBox[Dynamic[$CellContext`s$$]], 
+      LocatorBox[Dynamic[$CellContext`c1$$]], 
+      LocatorBox[Dynamic[$CellContext`e$$]]},
+     PlotRange->2], ",", 
+    RowBox[{"{", 
+     DynamicBox[ToBoxes[$CellContext`poly3 = Spline`H2[
+          Spline`pascalMatrix[3], 
+          IdentityMatrix[
+          3], $CellContext`s$$, $CellContext`c1$$, $CellContext`e$$]; \
+$CellContext`cps3 = Map[
+          Function[$CellContext`sub3, 
+           CharacteristicPolynomial[$CellContext`sub3, $CellContext`t]], 
+          SubSpaces`ListSubSpaces[$CellContext`poly3]]; Map[
+         Function[$CellContext`cp3, {$CellContext`cp3, 
+           
+           Plot[$CellContext`cp3, {$CellContext`t, 0, 
+             1}]}], $CellContext`cps3], StandardForm],
+      ImageSizeCache->{534., {52., 57.}}], "}"}]}], "}"}],
+  DynamicModuleValues:>{}]], "Output",
+ CellChangeTimes->{
+  3.756382426411004*^9, 3.756382535302038*^9, 3.756383389292183*^9, 
+   3.806249796110092*^9, 3.8062499098938074`*^9, 3.806251855325732*^9, 
+   3.8062987474901805`*^9, 3.8062996138548555`*^9, 3.8063006738136215`*^9, {
+   3.8063007754141636`*^9, 3.806300787030478*^9}, 3.807187402609372*^9},
+ CellLabel->"Out[69]=",ExpressionUUID->"66f8c139-1c14-43b8-8ef9-f6030caa6bbb"]
+}, Open  ]],
+
+Cell[CellGroupData[{
+
+Cell[BoxData[{
+ RowBox[{
+  RowBox[{"l3", "=", 
+   RowBox[{"(", 
+    RowBox[{"2", "*", 
+     RowBox[{"Cos", "[", 
+      RowBox[{"3", "*", 
+       RowBox[{"Pi", "/", "12"}]}], "]"}]}], ")"}]}], 
+  ";"}], "\[IndentingNewLine]", 
+ RowBox[{
+  RowBox[{"x3", "=", 
+   RowBox[{
+    RowBox[{"(", 
+     RowBox[{"1", "/", "l3"}], ")"}], "*", 
+    RowBox[{"(", 
+     RowBox[{"Cos", "[", 
+      RowBox[{"Pi", "*", 
+       RowBox[{"5", "/", "12"}]}], "]"}], ")"}]}]}], 
+  ";"}], "\[IndentingNewLine]", 
+ RowBox[{
+  RowBox[{"y3", "=", 
+   RowBox[{
+    RowBox[{"(", 
+     RowBox[{"1", "/", "l3"}], ")"}], "*", 
+    RowBox[{"(", 
+     RowBox[{
+      RowBox[{"Sin", "[", 
+       RowBox[{"Pi", "*", 
+        RowBox[{"5", "/", "12"}]}], "]"}], "-", 
+      RowBox[{"Sin", "[", 
+       RowBox[{"3", "*", 
+        RowBox[{"Pi", "/", "12"}]}], "]"}]}], ")"}]}]}], 
+  ";"}], "\[IndentingNewLine]", 
+ RowBox[{"DynamicModule", "[", 
+  RowBox[{
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"s", "=", 
+      RowBox[{"{", 
+       RowBox[{"0", ",", "0"}], "}"}]}], ",", 
+     RowBox[{"c1", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{
+         RowBox[{"1", "/", "2"}], "-", "x3"}], ",", 
+        RowBox[{"0", "+", "y3"}]}], "}"}]}], ",", 
+     RowBox[{"c2", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{
+         RowBox[{"1", "/", "2"}], "+", "x3"}], ",", 
+        RowBox[{"0", "+", "y3"}]}], "}"}]}], ",", 
+     RowBox[{"e", "=", 
+      RowBox[{"{", 
+       RowBox[{"1", ",", "0"}], "}"}]}]}], "}"}], ",", 
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"Dynamic", "[", 
+          RowBox[{"Point", "[", 
+           RowBox[{"arc3", "[", 
+            RowBox[{"s", ",", "c1", ",", "c2", ",", "e"}], "]"}], "]"}], 
+          "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "s", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c1", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c2", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "e", "]"}], "]"}]}], "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
+     RowBox[{"{", 
+      RowBox[{"Dynamic", "[", 
+       RowBox[{
+        RowBox[{"poly4", "=", " ", 
+         RowBox[{"H3", "[", 
+          RowBox[{
+           RowBox[{"pascalMatrix", "[", "4", "]"}], ",", 
+           RowBox[{"IdentityMatrix", "[", "4", "]"}], ",", "s", ",", "c1", 
+           ",", "c2", ",", "e"}], "]"}]}], ";", 
+        RowBox[{"cps4", "=", 
+         RowBox[{"Map", "[", 
+          RowBox[{
+           RowBox[{"Function", "[", 
+            RowBox[{"sub4", ",", 
+             RowBox[{"CharacteristicPolynomial", "[", 
+              RowBox[{"sub4", ",", "t"}], "]"}]}], "]"}], ",", 
+           RowBox[{"ListSubSpaces", "[", "poly4", "]"}]}], "]"}]}], ";", 
+        RowBox[{"Map", "[", 
+         RowBox[{
+          RowBox[{"Function", "[", 
+           RowBox[{"cp4", ",", 
+            RowBox[{"{", 
+             RowBox[{"cp4", ",", 
+              RowBox[{"Plot", "[", 
+               RowBox[{"cp4", ",", 
+                RowBox[{"{", 
+                 RowBox[{"t", ",", "0", ",", "1"}], "}"}]}], "]"}]}], "}"}]}],
+            "]"}], ",", "cps4"}], "]"}]}], "]"}], "}"}]}], "}"}]}], 
+  "]"}], "\[IndentingNewLine]", 
+ RowBox[{"DynamicModule", "[", 
+  RowBox[{
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"s", "=", 
+      RowBox[{"{", 
+       RowBox[{"0", ",", "0"}], "}"}]}], ",", 
+     RowBox[{"c1", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{"1", "/", "3"}], ",", 
+        RowBox[{"1", "/", "5"}]}], "}"}]}], ",", 
+     RowBox[{"c2", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{"2", "/", "3"}], ",", 
+        RowBox[{"1", "/", "5"}]}], "}"}]}], ",", 
+     RowBox[{"e", "=", 
+      RowBox[{"{", 
+       RowBox[{"1", ",", "0"}], "}"}]}]}], "}"}], ",", 
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"Dynamic", "[", 
+          RowBox[{"Point", "[", 
+           RowBox[{"arc3", "[", 
+            RowBox[{"s", ",", "c1", ",", "c2", ",", "e"}], "]"}], "]"}], 
+          "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "s", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c1", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c2", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "e", "]"}], "]"}]}], "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
+     RowBox[{"{", 
+      RowBox[{"Dynamic", "[", 
+       RowBox[{
+        RowBox[{"poly5", "=", " ", 
+         RowBox[{"H3", "[", 
+          RowBox[{
+           RowBox[{"pascalMatrix", "[", "4", "]"}], ",", 
+           RowBox[{"IdentityMatrix", "[", "4", "]"}], ",", "s", ",", "c1", 
+           ",", "c2", ",", "e"}], "]"}]}], ";", 
+        RowBox[{"cps5", "=", 
+         RowBox[{"Map", "[", 
+          RowBox[{
+           RowBox[{"Function", "[", 
+            RowBox[{"sub5", ",", 
+             RowBox[{"CharacteristicPolynomial", "[", 
+              RowBox[{"sub5", ",", "t"}], "]"}]}], "]"}], ",", 
+           RowBox[{"ListSubSpaces", "[", "poly5", "]"}]}], "]"}]}], ";", 
+        RowBox[{"Map", "[", 
+         RowBox[{
+          RowBox[{"Function", "[", 
+           RowBox[{"cp5", ",", 
+            RowBox[{"{", 
+             RowBox[{"cp5", ",", 
+              RowBox[{"Plot", "[", 
+               RowBox[{"cp5", ",", 
+                RowBox[{"{", 
+                 RowBox[{"t", ",", "0", ",", "1"}], "}"}]}], "]"}]}], "}"}]}],
+            "]"}], ",", "cps5"}], "]"}]}], "]"}], "}"}]}], "}"}]}], 
+  "]"}]}], "Input",
+ CellChangeTimes->{{3.753644201707952*^9, 3.753644247779598*^9}, 
+   3.753644670559819*^9, {3.753645089020927*^9, 3.7536450964825172`*^9}, {
+   3.753645348535717*^9, 3.753645396096363*^9}, {3.753645794819468*^9, 
+   3.75364581708619*^9}, {3.753645861522106*^9, 3.753645876685521*^9}, {
+   3.753646034113797*^9, 3.753646036152173*^9}, 3.753646085664897*^9, {
+   3.7536461558568687`*^9, 3.7536461605726357`*^9}, {3.753646190627133*^9, 
+   3.753646219710943*^9}, {3.7536510078891373`*^9, 3.753651115799756*^9}, {
+   3.7536511496238117`*^9, 3.753651165765967*^9}, {3.754051297108377*^9, 
+   3.7540513111994553`*^9}, {3.754051433471871*^9, 3.754051457348982*^9}, {
+   3.754490793379541*^9, 3.7544908055600853`*^9}, {3.7544918592464657`*^9, 
+   3.754491865911813*^9}, {3.754491905000348*^9, 3.754491944695901*^9}, {
+   3.7544932326272297`*^9, 3.7544932475240993`*^9}, {3.754494334353712*^9, 
+   3.7544943343559427`*^9}, {3.756208383468812*^9, 3.756208397488126*^9}, {
+   3.7562096560408297`*^9, 3.7562097213233957`*^9}, {3.756210677779427*^9, 
+   3.756210690894452*^9}, {3.756382627360982*^9, 3.75638264802183*^9}, {
+   3.756382692026477*^9, 3.756382738389123*^9}, {3.756382837552002*^9, 
+   3.756382889284719*^9}, {3.8062498686209726`*^9, 3.80624988701854*^9}, {
+   3.8062986644309444`*^9, 3.8062986726458545`*^9}, {3.806299542674655*^9, 
+   3.8062995673458443`*^9}, {3.8063006223130937`*^9, 3.806300627616762*^9}},
+ CellLabel->"In[70]:=",ExpressionUUID->"276d508d-f653-4fc6-9da7-c2489ee10b6e"],
+
+Cell[BoxData[
+ DynamicModuleBox[{$CellContext`s$$ = {0, 0}, $CellContext`c1$$ = {
+  Rational[1, 2] + Rational[1, 4] (1 - 3^Rational[1, 2]), 
+   2^Rational[-1, 2] (-2^Rational[-1, 2] + 
+    Rational[1, 2] 
+     2^Rational[-1, 2] (1 + 3^Rational[1, 2]))}, $CellContext`c2$$ = {
+  Rational[1, 2] + Rational[1, 4] (-1 + 3^Rational[1, 2]), 
+   2^Rational[-1, 2] (-2^Rational[-1, 2] + 
+    Rational[1, 2] 
+     2^Rational[-1, 2] (1 + 3^Rational[1, 2]))}, $CellContext`e$$ = {1, 0}}, 
+  RowBox[{"{", 
+   RowBox[{
+    GraphicsBox[{
+      DynamicBox[Typeset`ToBoxes[
+        Point[
+         Spline`arc3[$CellContext`s$$, $CellContext`c1$$, $CellContext`c2$$, \
+$CellContext`e$$]], StandardForm, Graphics],
+       ImageSizeCache->{{88.5, 136.5}, {-12.765018033293602`, -0.5}}], 
+      LocatorBox[Dynamic[$CellContext`s$$]], 
+      LocatorBox[Dynamic[$CellContext`c1$$]], 
+      LocatorBox[Dynamic[$CellContext`c2$$]], 
+      LocatorBox[Dynamic[$CellContext`e$$]]},
+     PlotRange->2], ",", 
+    RowBox[{"{", 
+     DynamicBox[ToBoxes[$CellContext`poly4 = Spline`H3[
+          Spline`pascalMatrix[4], 
+          IdentityMatrix[
+          4], $CellContext`s$$, $CellContext`c1$$, $CellContext`c2$$, \
+$CellContext`e$$]; $CellContext`cps4 = Map[
+          Function[$CellContext`sub4, 
+           CharacteristicPolynomial[$CellContext`sub4, $CellContext`t]], 
+          SubSpaces`ListSubSpaces[$CellContext`poly4]]; Map[
+         Function[$CellContext`cp4, {$CellContext`cp4, 
+           
+           Plot[$CellContext`cp4, {$CellContext`t, 0, 
+             1}]}], $CellContext`cps4], StandardForm],
+      ImageSizeCache->{720.641625, {165., 48.}}], "}"}]}], "}"}],
+  DynamicModuleValues:>{}]], "Output",
+ CellChangeTimes->{
+  3.7536442751502028`*^9, 3.7536443112831583`*^9, 3.753644596353655*^9, 
+   3.7536447141186123`*^9, 3.753645137259728*^9, {3.753645199876906*^9, 
+   3.753645215897216*^9}, 3.7536452808665752`*^9, 3.753645408071249*^9, 
+   3.753645533430318*^9, 3.753645830069751*^9, 3.753645903688192*^9, 
+   3.7536461156164837`*^9, 3.753646172393447*^9, 3.75364625376822*^9, {
+   3.753646661629743*^9, 3.753646677295238*^9}, {3.753646716370719*^9, 
+   3.753646759738831*^9}, 3.753646930456806*^9, 3.753647896054028*^9, {
+   3.753647948328643*^9, 3.753647964839595*^9}, 3.753648059534083*^9, 
+   3.753648164957657*^9, 3.753650661862856*^9, 3.7536507046248693`*^9, 
+   3.75365119626262*^9, 3.753651762054998*^9, {3.753702642692883*^9, 
+   3.753702657443885*^9}, 3.753702697996277*^9, 3.753702729673354*^9, 
+   3.7537027817819653`*^9, 3.754049642660638*^9, 3.754050054947687*^9, 
+   3.754050343717188*^9, 3.7540515387538557`*^9, 3.754051868409156*^9, 
+   3.7544839174618273`*^9, 3.754484120319195*^9, 3.7544844926549473`*^9, 
+   3.754490862986189*^9, 3.754491754745071*^9, 3.754491868219825*^9, {
+   3.754491926728978*^9, 3.754491946403955*^9}, 3.754492475947712*^9, 
+   3.754493284496969*^9, 3.754494359929864*^9, 3.7562028441612387`*^9, 
+   3.756208464640965*^9, 3.756209097603735*^9, {3.7562091441199408`*^9, 
+   3.756209165270788*^9}, 3.756209241955143*^9, {3.7562097013213387`*^9, 
+   3.756209722392861*^9}, 3.756209855169066*^9, 3.756209961472846*^9, 
+   3.756210207076954*^9, 3.756210603001677*^9, 3.7562107210343657`*^9, 
+   3.756210955195856*^9, 3.756380993363947*^9, 3.756381817184799*^9, 
+   3.756382739913807*^9, 3.7563828911636877`*^9, 3.756383390430666*^9, 
+   3.8062497963112693`*^9, 3.8062499101614857`*^9, 3.8062518555803285`*^9, 
+   3.8062987477302065`*^9, 3.806299615099784*^9, 3.8063006739927216`*^9, {
+   3.806300775459035*^9, 3.8063007872215924`*^9}, 3.807187402758004*^9},
+ CellLabel->"Out[73]=",ExpressionUUID->"570606f4-0dae-4654-a307-40bd62265751"],
+
+Cell[BoxData[
+ DynamicModuleBox[{$CellContext`s$$ = {0, 0}, $CellContext`c1$$ = {
+   Rational[1, 3], 
+   Rational[1, 5]}, $CellContext`c2$$ = {
+   Rational[2, 3], 
+   Rational[1, 5]}, $CellContext`e$$ = {1, 0}}, 
+  RowBox[{"{", 
+   RowBox[{
+    GraphicsBox[{
+      DynamicBox[Typeset`ToBoxes[
+        Point[
+         Spline`arc3[$CellContext`s$$, $CellContext`c1$$, $CellContext`c2$$, \
+$CellContext`e$$]], StandardForm, Graphics],
+       ImageSizeCache->{{88.5, 136.5}, {-13.625, -0.5}}], 
+      LocatorBox[Dynamic[$CellContext`s$$]], 
+      LocatorBox[Dynamic[$CellContext`c1$$]], 
+      LocatorBox[Dynamic[$CellContext`c2$$]], 
+      LocatorBox[Dynamic[$CellContext`e$$]]},
+     PlotRange->2], ",", 
+    RowBox[{"{", 
+     DynamicBox[ToBoxes[$CellContext`poly5 = Spline`H3[
+          Spline`pascalMatrix[4], 
+          IdentityMatrix[
+          4], $CellContext`s$$, $CellContext`c1$$, $CellContext`c2$$, \
+$CellContext`e$$]; $CellContext`cps5 = Map[
+          Function[$CellContext`sub5, 
+           CharacteristicPolynomial[$CellContext`sub5, $CellContext`t]], 
+          SubSpaces`ListSubSpaces[$CellContext`poly5]]; Map[
+         Function[$CellContext`cp5, {$CellContext`cp5, 
+           
+           Plot[$CellContext`cp5, {$CellContext`t, 0, 
+             1}]}], $CellContext`cps5], StandardForm],
+      ImageSizeCache->{534.296875, {180., 49.}}], "}"}]}], "}"}],
+  DynamicModuleValues:>{}]], "Output",
+ CellChangeTimes->{
+  3.7536442751502028`*^9, 3.7536443112831583`*^9, 3.753644596353655*^9, 
+   3.7536447141186123`*^9, 3.753645137259728*^9, {3.753645199876906*^9, 
+   3.753645215897216*^9}, 3.7536452808665752`*^9, 3.753645408071249*^9, 
+   3.753645533430318*^9, 3.753645830069751*^9, 3.753645903688192*^9, 
+   3.7536461156164837`*^9, 3.753646172393447*^9, 3.75364625376822*^9, {
+   3.753646661629743*^9, 3.753646677295238*^9}, {3.753646716370719*^9, 
+   3.753646759738831*^9}, 3.753646930456806*^9, 3.753647896054028*^9, {
+   3.753647948328643*^9, 3.753647964839595*^9}, 3.753648059534083*^9, 
+   3.753648164957657*^9, 3.753650661862856*^9, 3.7536507046248693`*^9, 
+   3.75365119626262*^9, 3.753651762054998*^9, {3.753702642692883*^9, 
+   3.753702657443885*^9}, 3.753702697996277*^9, 3.753702729673354*^9, 
+   3.7537027817819653`*^9, 3.754049642660638*^9, 3.754050054947687*^9, 
+   3.754050343717188*^9, 3.7540515387538557`*^9, 3.754051868409156*^9, 
+   3.7544839174618273`*^9, 3.754484120319195*^9, 3.7544844926549473`*^9, 
+   3.754490862986189*^9, 3.754491754745071*^9, 3.754491868219825*^9, {
+   3.754491926728978*^9, 3.754491946403955*^9}, 3.754492475947712*^9, 
+   3.754493284496969*^9, 3.754494359929864*^9, 3.7562028441612387`*^9, 
+   3.756208464640965*^9, 3.756209097603735*^9, {3.7562091441199408`*^9, 
+   3.756209165270788*^9}, 3.756209241955143*^9, {3.7562097013213387`*^9, 
+   3.756209722392861*^9}, 3.756209855169066*^9, 3.756209961472846*^9, 
+   3.756210207076954*^9, 3.756210603001677*^9, 3.7562107210343657`*^9, 
+   3.756210955195856*^9, 3.756380993363947*^9, 3.756381817184799*^9, 
+   3.756382739913807*^9, 3.7563828911636877`*^9, 3.756383390430666*^9, 
+   3.8062497963112693`*^9, 3.8062499101614857`*^9, 3.8062518555803285`*^9, 
+   3.8062987477302065`*^9, 3.806299615099784*^9, 3.8063006739927216`*^9, {
+   3.806300775459035*^9, 3.8063007872215924`*^9}, 3.8071874028548737`*^9},
+ CellLabel->"Out[74]=",ExpressionUUID->"00692cc8-253a-4edf-8277-60a8e1d8a667"]
+}, Open  ]],
+
+Cell[CellGroupData[{
+
+Cell[BoxData[{
+ RowBox[{
+  RowBox[{"l3", "=", "2"}], ";", 
+  RowBox[{"x3", "=", 
+   RowBox[{
+    RowBox[{"(", 
+     RowBox[{"1", "/", "l3"}], ")"}], "*", 
+    RowBox[{"(", 
+     RowBox[{"Sin", "[", 
+      RowBox[{"1", "*", 
+       RowBox[{"Pi", "/", "4"}]}], "]"}], ")"}]}]}], ";", 
+  RowBox[{"y3", "=", 
+   RowBox[{
+    RowBox[{"(", 
+     RowBox[{"1", "/", "l3"}], ")"}], "*", 
+    RowBox[{"(", 
+     RowBox[{"Cos", "[", 
+      RowBox[{"1", "*", 
+       RowBox[{"Pi", "/", "4"}]}], "]"}], ")"}]}]}], 
+  ";"}], "\[IndentingNewLine]", 
+ RowBox[{"DynamicModule", "[", 
+  RowBox[{
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"s", "=", 
+      RowBox[{"{", 
+       RowBox[{"0", ",", "0"}], "}"}]}], ",", 
+     RowBox[{"c1", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{
+         RowBox[{"1", "/", "2"}], "-", "x3"}], ",", 
+        RowBox[{"0", "+", "y3"}]}], "}"}]}], ",", 
+     RowBox[{"c2", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{"2", "/", "4"}], ",", 
+        RowBox[{"1", "/", "2"}]}], "}"}]}], ",", 
+     RowBox[{"c3", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{
+         RowBox[{"1", "/", "2"}], "+", "x3"}], ",", 
+        RowBox[{"0", "+", "y3"}]}], "}"}]}], ",", 
+     RowBox[{"e", "=", 
+      RowBox[{"{", 
+       RowBox[{"1", ",", "0"}], "}"}]}]}], "}"}], ",", 
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"Dynamic", "[", 
+          RowBox[{"Point", "[", 
+           RowBox[{"arc4", "[", 
+            RowBox[{"s", ",", "c1", ",", "c2", ",", "c3", ",", "e"}], "]"}], 
+           "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "s", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c1", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c2", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c3", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "e", "]"}], "]"}]}], "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
+     RowBox[{"{", 
+      RowBox[{"Dynamic", "[", 
+       RowBox[{
+        RowBox[{"poly6", "=", " ", 
+         RowBox[{"H4", "[", 
+          RowBox[{
+           RowBox[{"pascalMatrix", "[", "5", "]"}], ",", 
+           RowBox[{"IdentityMatrix", "[", "5", "]"}], ",", "s", ",", "c1", 
+           ",", "c2", ",", "c3", ",", "e"}], "]"}]}], ";", 
+        RowBox[{"cps6", "=", 
+         RowBox[{"Map", "[", 
+          RowBox[{
+           RowBox[{"Function", "[", 
+            RowBox[{"sub6", ",", 
+             RowBox[{"CharacteristicPolynomial", "[", 
+              RowBox[{"sub6", ",", "t"}], "]"}]}], "]"}], ",", 
+           RowBox[{"ListSubSpaces", "[", "poly6", "]"}]}], "]"}]}], ";", 
+        RowBox[{"Map", "[", 
+         RowBox[{
+          RowBox[{"Function", "[", 
+           RowBox[{"cp6", ",", 
+            RowBox[{"{", 
+             RowBox[{"cp6", ",", 
+              RowBox[{"Plot", "[", 
+               RowBox[{"cp6", ",", 
+                RowBox[{"{", 
+                 RowBox[{"t", ",", "0", ",", "1"}], "}"}]}], "]"}]}], "}"}]}],
+            "]"}], ",", "cps6"}], "]"}]}], "]"}], "}"}]}], "}"}]}], 
+  "]"}], "\[IndentingNewLine]", 
+ RowBox[{"DynamicModule", "[", 
+  RowBox[{
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"s", "=", 
+      RowBox[{"{", 
+       RowBox[{"0", ",", "0"}], "}"}]}], ",", 
+     RowBox[{"c1", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{"1", "/", "4"}], ",", 
+        RowBox[{"1", "/", "6"}]}], "}"}]}], ",", 
+     RowBox[{"c2", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{"2", "/", "4"}], ",", 
+        RowBox[{"1", "/", "5"}]}], "}"}]}], ",", 
+     RowBox[{"c3", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{"3", "/", "4"}], ",", 
+        RowBox[{"1", "/", "6"}]}], "}"}]}], ",", 
+     RowBox[{"e", "=", 
+      RowBox[{"{", 
+       RowBox[{"1", ",", "0"}], "}"}]}]}], "}"}], ",", 
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"Dynamic", "[", 
+          RowBox[{"Point", "[", 
+           RowBox[{"arc4", "[", 
+            RowBox[{"s", ",", "c1", ",", "c2", ",", "c3", ",", "e"}], "]"}], 
+           "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "s", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c1", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c2", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c3", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "e", "]"}], "]"}]}], "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
+     RowBox[{"{", 
+      RowBox[{"Dynamic", "[", 
+       RowBox[{
+        RowBox[{"poly7", "=", " ", 
+         RowBox[{"H4", "[", 
+          RowBox[{
+           RowBox[{"pascalMatrix", "[", "5", "]"}], ",", 
+           RowBox[{"IdentityMatrix", "[", "5", "]"}], ",", "s", ",", "c1", 
+           ",", "c2", ",", "c3", ",", "e"}], "]"}]}], ";", 
+        RowBox[{"cps7", "=", 
+         RowBox[{"Map", "[", 
+          RowBox[{
+           RowBox[{"Function", "[", 
+            RowBox[{"sub7", ",", 
+             RowBox[{"CharacteristicPolynomial", "[", 
+              RowBox[{"sub7", ",", "t"}], "]"}]}], "]"}], ",", 
+           RowBox[{"ListSubSpaces", "[", "poly7", "]"}]}], "]"}]}], ";", 
+        RowBox[{"Map", "[", 
+         RowBox[{
+          RowBox[{"Function", "[", 
+           RowBox[{"cp7", ",", 
+            RowBox[{"{", 
+             RowBox[{"cp7", ",", 
+              RowBox[{"Plot", "[", 
+               RowBox[{"cp7", ",", 
+                RowBox[{"{", 
+                 RowBox[{"t", ",", "0", ",", "1"}], "}"}]}], "]"}]}], "}"}]}],
+            "]"}], ",", "cps7"}], "]"}]}], "]"}], "}"}]}], "}"}]}], 
+  "]"}]}], "Input",
+ CellChangeTimes->{{3.75352098829558*^9, 3.753520995510291*^9}, {
+   3.753521789440345*^9, 3.753521859756032*^9}, {3.753639519297163*^9, 
+   3.7536395197072678`*^9}, {3.753639628196072*^9, 3.753639638703433*^9}, {
+   3.753639936824381*^9, 3.7536399627449007`*^9}, {3.753644643257105*^9, 
+   3.753644651385893*^9}, {3.753645104637027*^9, 3.753645110320312*^9}, {
+   3.753645422506155*^9, 3.753645498716555*^9}, {3.753651548999468*^9, 
+   3.7536515499214*^9}, {3.753651595373822*^9, 3.75365171341573*^9}, {
+   3.754049968340948*^9, 3.754049984438085*^9}, {3.754050068903783*^9, 
+   3.754050080661563*^9}, {3.7540501111682034`*^9, 3.754050150117704*^9}, {
+   3.754050235374084*^9, 3.75405025338431*^9}, 3.754050387844503*^9, {
+   3.7540511509211273`*^9, 3.754051172655856*^9}, {3.754051478070005*^9, 
+   3.7540515186424637`*^9}, {3.7540515835513477`*^9, 3.754051593086375*^9}, {
+   3.7544908281530437`*^9, 3.7544908462607527`*^9}, {3.754492680121202*^9, 
+   3.754492762740232*^9}, {3.7544932570945787`*^9, 3.75449327337422*^9}, {
+   3.7544943343816957`*^9, 3.754494334383944*^9}, {3.756208412474257*^9, 
+   3.756208425461*^9}, {3.756209739463132*^9, 3.756209793012476*^9}, {
+   3.756210700678748*^9, 3.7562107155569687`*^9}, {3.756382915397595*^9, 
+   3.756382926534843*^9}, {3.756383023413638*^9, 3.756383076497923*^9}, {
+   3.7563831659931993`*^9, 3.756383242995501*^9}, {3.8062986913746305`*^9, 
+   3.806298696853572*^9}, {3.8062995766457148`*^9, 3.806299601062857*^9}, {
+   3.8063006387677884`*^9, 3.8063006437691483`*^9}, {3.80630071515961*^9, 
+   3.8063007718073425`*^9}},
+ CellLabel->"In[75]:=",ExpressionUUID->"5aa70448-c70b-4324-8969-c157f8a502cc"],
+
+Cell[BoxData[
+ DynamicModuleBox[{$CellContext`s$$ = {0, 0}, $CellContext`c1$$ = {
+  Rational[1, 2] + Rational[-1, 2] 2^Rational[-1, 2], Rational[1, 2] 
+   2^Rational[-1, 2]}, $CellContext`c2$$ = {
+   Rational[1, 2], 
+   Rational[1, 2]}, $CellContext`c3$$ = {
+  Rational[1, 2] + Rational[1, 2] 2^Rational[-1, 2], Rational[1, 2] 
+   2^Rational[-1, 2]}, $CellContext`e$$ = {1, 0}}, 
+  RowBox[{"{", 
+   RowBox[{
+    GraphicsBox[{
+      DynamicBox[Typeset`ToBoxes[
+        Point[
+         Spline`arc4[$CellContext`s$$, $CellContext`c1$$, $CellContext`c2$$, \
+$CellContext`c3$$, $CellContext`e$$]], StandardForm, Graphics],
+       ImageSizeCache->{{88.5, 136.5}, {-25.999999999999996`, -0.5}}], 
+      LocatorBox[Dynamic[$CellContext`s$$]], 
+      LocatorBox[Dynamic[$CellContext`c1$$]], 
+      LocatorBox[Dynamic[$CellContext`c2$$]], 
+      LocatorBox[Dynamic[$CellContext`c3$$]], 
+      LocatorBox[Dynamic[$CellContext`e$$]]},
+     PlotRange->2], ",", 
+    RowBox[{"{", 
+     DynamicBox[ToBoxes[$CellContext`poly6 = Spline`H4[
+          Spline`pascalMatrix[5], 
+          IdentityMatrix[
+          5], $CellContext`s$$, $CellContext`c1$$, $CellContext`c2$$, \
+$CellContext`c3$$, $CellContext`e$$]; $CellContext`cps6 = Map[
+          Function[$CellContext`sub6, 
+           CharacteristicPolynomial[$CellContext`sub6, $CellContext`t]], 
+          SubSpaces`ListSubSpaces[$CellContext`poly6]]; Map[
+         Function[$CellContext`cp6, {$CellContext`cp6, 
+           
+           Plot[$CellContext`cp6, {$CellContext`t, 0, 
+             1}]}], $CellContext`cps6], StandardForm],
+      ImageSizeCache->{797.641625, {320., 57.}}], "}"}]}], "}"}],
+  DynamicModuleValues:>{}]], "Output",
+ CellChangeTimes->{{3.7535217936252937`*^9, 3.753521830288795*^9}, 
+   3.753521863521718*^9, {3.75363945820516*^9, 3.753639498286676*^9}, 
+   3.753639530435408*^9, 3.7536396476299677`*^9, 3.753639710872081*^9, 
+   3.753639981764551*^9, 3.753640074158125*^9, 3.753644275567021*^9, 
+   3.753644312300482*^9, 3.7536445969520187`*^9, 3.753644714600988*^9, 
+   3.753645137644857*^9, {3.753645203561022*^9, 3.753645220013073*^9}, 
+   3.7536452813060226`*^9, 3.753645408971217*^9, 3.7536455348563023`*^9, 
+   3.753645831311658*^9, 3.753645904527769*^9, 3.753646116969626*^9, 
+   3.75364617386683*^9, 3.753646255147011*^9, {3.753646662793212*^9, 
+   3.753646677960086*^9}, {3.7536467167287903`*^9, 3.753646760309927*^9}, 
+   3.753646931303762*^9, 3.753647896538409*^9, {3.753647948810421*^9, 
+   3.7536479656139717`*^9}, 3.753648059960773*^9, 3.753648165389739*^9, 
+   3.753650662249325*^9, 3.7536507053474903`*^9, 3.753651196848888*^9, 
+   3.753651763641247*^9, {3.753702643509305*^9, 3.7537026582182817`*^9}, 
+   3.7537026992180443`*^9, 3.753702730145419*^9, 3.7537027824410267`*^9, 
+   3.754049643468505*^9, 3.754049986641244*^9, {3.754050056082672*^9, 
+   3.7540500859371367`*^9}, 3.754050160357607*^9, 3.7540502574867573`*^9, 
+   3.754050344849202*^9, 3.754050393007547*^9, 3.754051178464005*^9, 
+   3.754051540231432*^9, 3.75405159803508*^9, 3.754051868854401*^9, 
+   3.75448391828279*^9, 3.754484120981249*^9, 3.754484493452591*^9, 
+   3.754490863694869*^9, 3.754491755559185*^9, 3.754492476399428*^9, {
+   3.754492691685191*^9, 3.7544927192064667`*^9}, {3.754492750228512*^9, 
+   3.75449276520008*^9}, 3.754493285248043*^9, 3.754494360631809*^9, 
+   3.756202844564455*^9, 3.756208465299128*^9, 3.756209098180015*^9, {
+   3.7562091445051107`*^9, 3.756209165665201*^9}, 3.756209242644396*^9, 
+   3.7562097949599648`*^9, 3.756209855390291*^9, 3.7562099618277607`*^9, 
+   3.756210207292482*^9, 3.756210603361829*^9, 3.756210721274468*^9, 
+   3.756210955678162*^9, 3.7563809938616257`*^9, 3.756381817421007*^9, 
+   3.756383081420892*^9, 3.756383245551059*^9, 3.7563833918805037`*^9, 
+   3.8062497970440965`*^9, 3.806249910809891*^9, 3.8062518558740067`*^9, 
+   3.806298748035448*^9, 3.806299616129783*^9, 3.8063006742576513`*^9, {
+   3.80630077552337*^9, 3.806300787501957*^9}, 3.807187403080887*^9},
+ CellLabel->"Out[76]=",ExpressionUUID->"d0ab7a90-f523-489c-939d-5cfc7ef278e5"],
+
+Cell[BoxData[
+ DynamicModuleBox[{$CellContext`s$$ = {0, 0}, $CellContext`c1$$ = {
+   Rational[1, 4], 
+   Rational[1, 6]}, $CellContext`c2$$ = {
+   Rational[1, 2], 
+   Rational[1, 5]}, $CellContext`c3$$ = {
+   Rational[3, 4], 
+   Rational[1, 6]}, $CellContext`e$$ = {1, 0}}, 
+  RowBox[{"{", 
+   RowBox[{
+    GraphicsBox[{
+      DynamicBox[Typeset`ToBoxes[
+        Point[
+         Spline`arc4[$CellContext`s$$, $CellContext`c1$$, $CellContext`c2$$, \
+$CellContext`c3$$, $CellContext`e$$]], StandardForm, Graphics],
+       ImageSizeCache->{{88.5, 136.5}, {-12.5, -0.5}}], 
+      LocatorBox[Dynamic[$CellContext`s$$]], 
+      LocatorBox[Dynamic[$CellContext`c1$$]], 
+      LocatorBox[Dynamic[$CellContext`c2$$]], 
+      LocatorBox[Dynamic[$CellContext`c3$$]], 
+      LocatorBox[Dynamic[$CellContext`e$$]]},
+     PlotRange->2], ",", 
+    RowBox[{"{", 
+     DynamicBox[ToBoxes[$CellContext`poly7 = Spline`H4[
+          Spline`pascalMatrix[5], 
+          IdentityMatrix[
+          5], $CellContext`s$$, $CellContext`c1$$, $CellContext`c2$$, \
+$CellContext`c3$$, $CellContext`e$$]; $CellContext`cps7 = Map[
+          Function[$CellContext`sub7, 
+           CharacteristicPolynomial[$CellContext`sub7, $CellContext`t]], 
+          SubSpaces`ListSubSpaces[$CellContext`poly7]]; Map[
+         Function[$CellContext`cp7, {$CellContext`cp7, 
+           
+           Plot[$CellContext`cp7, {$CellContext`t, 0, 
+             1}]}], $CellContext`cps7], StandardForm],
+      ImageSizeCache->{639.034375, {174., 56.}}], "}"}]}], "}"}],
+  DynamicModuleValues:>{}]], "Output",
+ CellChangeTimes->{{3.7535217936252937`*^9, 3.753521830288795*^9}, 
+   3.753521863521718*^9, {3.75363945820516*^9, 3.753639498286676*^9}, 
+   3.753639530435408*^9, 3.7536396476299677`*^9, 3.753639710872081*^9, 
+   3.753639981764551*^9, 3.753640074158125*^9, 3.753644275567021*^9, 
+   3.753644312300482*^9, 3.7536445969520187`*^9, 3.753644714600988*^9, 
+   3.753645137644857*^9, {3.753645203561022*^9, 3.753645220013073*^9}, 
+   3.7536452813060226`*^9, 3.753645408971217*^9, 3.7536455348563023`*^9, 
+   3.753645831311658*^9, 3.753645904527769*^9, 3.753646116969626*^9, 
+   3.75364617386683*^9, 3.753646255147011*^9, {3.753646662793212*^9, 
+   3.753646677960086*^9}, {3.7536467167287903`*^9, 3.753646760309927*^9}, 
+   3.753646931303762*^9, 3.753647896538409*^9, {3.753647948810421*^9, 
+   3.7536479656139717`*^9}, 3.753648059960773*^9, 3.753648165389739*^9, 
+   3.753650662249325*^9, 3.7536507053474903`*^9, 3.753651196848888*^9, 
+   3.753651763641247*^9, {3.753702643509305*^9, 3.7537026582182817`*^9}, 
+   3.7537026992180443`*^9, 3.753702730145419*^9, 3.7537027824410267`*^9, 
+   3.754049643468505*^9, 3.754049986641244*^9, {3.754050056082672*^9, 
+   3.7540500859371367`*^9}, 3.754050160357607*^9, 3.7540502574867573`*^9, 
+   3.754050344849202*^9, 3.754050393007547*^9, 3.754051178464005*^9, 
+   3.754051540231432*^9, 3.75405159803508*^9, 3.754051868854401*^9, 
+   3.75448391828279*^9, 3.754484120981249*^9, 3.754484493452591*^9, 
+   3.754490863694869*^9, 3.754491755559185*^9, 3.754492476399428*^9, {
+   3.754492691685191*^9, 3.7544927192064667`*^9}, {3.754492750228512*^9, 
+   3.75449276520008*^9}, 3.754493285248043*^9, 3.754494360631809*^9, 
+   3.756202844564455*^9, 3.756208465299128*^9, 3.756209098180015*^9, {
+   3.7562091445051107`*^9, 3.756209165665201*^9}, 3.756209242644396*^9, 
+   3.7562097949599648`*^9, 3.756209855390291*^9, 3.7562099618277607`*^9, 
+   3.756210207292482*^9, 3.756210603361829*^9, 3.756210721274468*^9, 
+   3.756210955678162*^9, 3.7563809938616257`*^9, 3.756381817421007*^9, 
+   3.756383081420892*^9, 3.756383245551059*^9, 3.7563833918805037`*^9, 
+   3.8062497970440965`*^9, 3.806249910809891*^9, 3.8062518558740067`*^9, 
+   3.806298748035448*^9, 3.806299616129783*^9, 3.8063006742576513`*^9, {
+   3.80630077552337*^9, 3.806300787501957*^9}, 3.807187403198061*^9},
+ CellLabel->"Out[77]=",ExpressionUUID->"355a9970-21cb-46d1-889c-7a5c45e6f99e"]
+}, Open  ]]
+},
+WindowSize->{927, 1016},
+WindowMargins->{{Automatic, 202}, {0, Automatic}},
+FrontEndVersion->"12.1 for Linux x86 (64-bit) (June 19, 2020)",
+StyleDefinitions->"Default.nb",
+ExpressionUUID->"3b47e9e7-b900-4a30-b1a3-98ff8e8b66df"
+]
+(* End of Notebook Content *)
+
+(* Internal cache information *)
+(*CellTagsOutline
+CellTagsIndex->{}
+*)
+(*CellTagsIndex
+CellTagsIndex->{}
+*)
+(*NotebookFileOutline
+Notebook[{
+Cell[558, 20, 239, 5, 30, "Input",ExpressionUUID->"50fcc07e-b04b-4b06-be90-516d39e07f29"],
+Cell[800, 27, 342, 6, 30, "Input",ExpressionUUID->"dc37c5c1-800f-42da-88ac-3d4a585491bb"],
+Cell[CellGroupData[{
+Cell[1167, 37, 3487, 76, 119, "Input",ExpressionUUID->"af07487f-0f3b-4347-96f1-f47706dc5442"],
+Cell[4657, 115, 3078, 54, 199, "Output",ExpressionUUID->"d33083ee-e84c-4867-9b1a-322eed42e341"]
+}, Open  ]],
+Cell[CellGroupData[{
+Cell[7772, 174, 6221, 160, 339, "Input",ExpressionUUID->"5d70f809-3415-4942-baca-6a1b97b567af"],
+Cell[13996, 336, 1721, 36, 326, "Output",ExpressionUUID->"115a9f53-2625-4b34-a005-487d1430b3db"],
+Cell[15720, 374, 1652, 36, 199, "Output",ExpressionUUID->"66f8c139-1c14-43b8-8ef9-f6030caa6bbb"]
+}, Open  ]],
+Cell[CellGroupData[{
+Cell[17409, 415, 7320, 192, 339, "Input",ExpressionUUID->"276d508d-f653-4fc6-9da7-c2489ee10b6e"],
+Cell[24732, 609, 3664, 65, 446, "Output",ExpressionUUID->"570606f4-0dae-4654-a307-40bd62265751"],
+Cell[28399, 676, 3388, 61, 291, "Output",ExpressionUUID->"00692cc8-253a-4edf-8277-60a8e1d8a667"]
+}, Open  ]],
+Cell[CellGroupData[{
+Cell[31824, 742, 7680, 196, 295, "Input",ExpressionUUID->"5aa70448-c70b-4324-8969-c157f8a502cc"],
+Cell[39507, 940, 4050, 69, 431, "Output",ExpressionUUID->"d0ab7a90-f523-489c-939d-5cfc7ef278e5"],
+Cell[43560, 1011, 3930, 69, 486, "Output",ExpressionUUID->"355a9970-21cb-46d1-889c-7a5c45e6f99e"]
+}, Open  ]]
+}
+]
+*)
+
```

### Comparing `stopeight-0.3.14/doc/mathematica/Spline_Generative.nb` & `stopeight-0.3.22/doc/mathematica/Spline_Generative.nb`

 * *Files 14% similar despite different names*

```diff
@@ -1,750 +1,773 @@
-(* Content-type: application/vnd.wolfram.mathematica *)
-
-(*** Wolfram Notebook File ***)
-(* http://www.wolfram.com/nb *)
-
-(* CreatedBy='Mathematica 11.3' *)
-
-(*CacheID: 234*)
-(* Internal cache information:
-NotebookFileLineBreakTest
-NotebookFileLineBreakTest
-NotebookDataPosition[       158,          7]
-NotebookDataLength[     31084,        742]
-NotebookOptionsPosition[     29252,        703]
-NotebookOutlinePosition[     29587,        718]
-CellTagsIndexPosition[     29544,        715]
-WindowFrame->Normal*)
-
-(* Beginning of Notebook Content *)
-Notebook[{
-Cell[BoxData[
- RowBox[{"ClearAll", "[", 
-  RowBox[{"Evaluate", "[", 
-   RowBox[{
-    RowBox[{"Context", "[", "]"}], "<>", "\"\<*\>\""}], "]"}], "]"}]], "Input",\
-
- CellLabel->"In[64]:=",ExpressionUUID->"2e7c28c4-94b6-4f0a-b06a-4128b32d2ac4"],
-
-Cell[BoxData[
- RowBox[{"Needs", "[", "\"\<Spline`\>\"", "]"}]], "Input",
- CellChangeTimes->{{3.753703047291655*^9, 3.753703055136489*^9}},
- CellLabel->"In[65]:=",ExpressionUUID->"5778195a-5bf6-4b92-9642-c2f2bd572a9d"],
-
-Cell["\<\
-we define it bernstein AND a circular
-we plot every height of control point y, that results in a bernstein charpol
-we insert y in spline and set x half condition\
-\>", "Text",
- CellChangeTimes->{{3.754482064436014*^9, 3.754482075565927*^9}, {
-  3.754483241295146*^9, 3.7544832886860857`*^9}, {3.754483379201844*^9, 
-  3.754483394036672*^9}, {3.7544835417408333`*^9, 
-  3.754483555887239*^9}},ExpressionUUID->"6ea8292c-4b09-4e06-a3d1-\
-0027de311060"],
-
-Cell[CellGroupData[{
-
-Cell[BoxData[
- RowBox[{
-  RowBox[{"(*", 
-   RowBox[{
-    RowBox[{"Clear", "[", "y", "]"}], ";", 
-    RowBox[{"xin", "=", 
-     RowBox[{"1", "/", "2"}]}], ";", 
-    RowBox[{"n", "=", "3"}], ";", 
-    RowBox[{"i", "=", "3"}], ";"}], "*)"}], "\[IndentingNewLine]", 
-  RowBox[{"DynamicModule", "[", 
-   RowBox[{
-    RowBox[{"{", 
-     RowBox[{"x", "=", 
-      RowBox[{"1", "/", "2"}]}], "}"}], ",", 
-    RowBox[{"{", 
-     RowBox[{
-      RowBox[{"Slider", "[", 
-       RowBox[{
-        RowBox[{"Dynamic", "[", "x", "]"}], ",", 
-        RowBox[{"{", 
-         RowBox[{
-          RowBox[{"-", "5"}], ",", "5"}], "}"}]}], "]"}], ",", 
-      RowBox[{"Graphics", "[", 
-       RowBox[{
-        RowBox[{"Point", "[", 
-         RowBox[{"Dynamic", "[", 
-          RowBox[{"BS2gen", "[", 
-           RowBox[{"x", ",", "2"}], "]"}], "]"}], "]"}], ",", 
-        RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
-      RowBox[{"Graphics", "[", 
-       RowBox[{
-        RowBox[{"Point", "[", 
-         RowBox[{"Dynamic", "[", 
-          RowBox[{"BS2gen", "[", 
-           RowBox[{"x", ",", "3"}], "]"}], "]"}], "]"}], ",", 
-        RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
-      RowBox[{"Dynamic", "[", "x", "]"}]}], "}"}]}], "]"}]}]], "Input",
- CellChangeTimes->{{3.754481401060038*^9, 3.754481401140205*^9}, {
-   3.754481432540495*^9, 3.7544814497057667`*^9}, {3.7544815445051928`*^9, 
-   3.754481555217092*^9}, {3.754483684703184*^9, 3.754483688656671*^9}, {
-   3.754502530505373*^9, 3.75450255108272*^9}, {3.754502676827174*^9, 
-   3.754502710406823*^9}, {3.75450277711789*^9, 3.754502810499543*^9}, {
-   3.754502863207444*^9, 3.7545029555092688`*^9}, {3.754502985665998*^9, 
-   3.75450298866074*^9}, 3.754503063529188*^9, {3.7545033614302073`*^9, 
-   3.7545033960931587`*^9}, {3.7545034363075*^9, 3.7545034392802477`*^9}, {
-   3.75450392191022*^9, 3.754503974735487*^9}, {3.7545040204983664`*^9, 
-   3.754504159662684*^9}, {3.7545041941952457`*^9, 3.7545042844185038`*^9}, {
-   3.754504346800758*^9, 3.754504359258341*^9}, {3.7545044428743134`*^9, 
-   3.754504484213958*^9}, {3.754504585320714*^9, 3.754504585501659*^9}, {
-   3.754504638659412*^9, 3.7545046590473957`*^9}, {3.754504704169757*^9, 
-   3.75450475832257*^9}, {3.754504797136759*^9, 3.754504805979965*^9}, {
-   3.754545851514345*^9, 3.754545851942646*^9}, {3.754545897672845*^9, 
-   3.75454590524221*^9}, {3.754546014374165*^9, 3.754546035375721*^9}, {
-   3.754546195580285*^9, 3.754546202246608*^9}, {3.754546297134654*^9, 
-   3.754546310095613*^9}, {3.7545463511705008`*^9, 3.754546364285737*^9}, {
-   3.754546395235423*^9, 3.754546404153283*^9}, {3.754547306795676*^9, 
-   3.7545473111961193`*^9}, {3.754547342162428*^9, 3.754547342526368*^9}, {
-   3.754547379617714*^9, 3.754547387150385*^9}, {3.754547445751247*^9, 
-   3.754547456250901*^9}, {3.754547503850618*^9, 3.754547519738544*^9}, {
-   3.7545475817289333`*^9, 3.7545475833511343`*^9}, {3.754547640831354*^9, 
-   3.754547651971673*^9}, {3.7545477000233927`*^9, 3.7545477220249767`*^9}, {
-   3.75454789514637*^9, 3.754547917089939*^9}, {3.7545479858514843`*^9, 
-   3.754547990744977*^9}, {3.754548081869421*^9, 3.754548082195418*^9}, {
-   3.754548114863475*^9, 3.754548116422688*^9}, {3.754548182576198*^9, 
-   3.754548230981401*^9}, {3.754548267148219*^9, 3.754548437004656*^9}, {
-   3.754548539938387*^9, 3.754548579659973*^9}, 3.75454862283095*^9, {
-   3.754548660405346*^9, 3.7545487090964127`*^9}, 3.754548871486515*^9, {
-   3.754548911714615*^9, 3.754548914294018*^9}, {3.754548948800377*^9, 
-   3.7545489640380383`*^9}, {3.7545490075791283`*^9, 3.754549025349691*^9}, {
-   3.754549089575644*^9, 3.75454909712577*^9}, {3.75454915945127*^9, 
-   3.754549187726894*^9}, {3.754549241639045*^9, 3.754549292804276*^9}, {
-   3.7545493351768007`*^9, 3.754549335571546*^9}, {3.7545493886852827`*^9, 
-   3.754549422720606*^9}, {3.754549468408227*^9, 3.754549477247114*^9}, {
-   3.754549539577738*^9, 3.754549543332945*^9}, 3.754549659249805*^9, {
-   3.754550056800836*^9, 3.7545500847937107`*^9}, {3.754550117193722*^9, 
-   3.7545501271695023`*^9}, 3.754550227127472*^9, {3.7545503457588987`*^9, 
-   3.754550369720083*^9}, {3.754550454773521*^9, 3.75455047828636*^9}, {
-   3.754550520456238*^9, 3.754550520701301*^9}, {3.754550609468131*^9, 
-   3.754550614315284*^9}, {3.754550655662147*^9, 3.754550788879006*^9}, {
-   3.754550857241721*^9, 3.754550866477723*^9}, {3.754550943004135*^9, 
-   3.754550944443205*^9}, {3.7545510670945253`*^9, 3.7545510825967607`*^9}, {
-   3.754551115214447*^9, 3.7545511212415857`*^9}, {3.754551160374297*^9, 
-   3.754551271645986*^9}, {3.754551320092498*^9, 3.754551332889049*^9}, {
-   3.7545513873375587`*^9, 3.754551430550577*^9}, {3.754551593212818*^9, 
-   3.754551593655097*^9}, {3.7545516435548286`*^9, 3.754551686669298*^9}, {
-   3.7545517316198483`*^9, 3.754551803949479*^9}, {3.754551852451798*^9, 
-   3.75455185608421*^9}, {3.754551892456603*^9, 3.754551896295888*^9}, {
-   3.75455196047121*^9, 3.7545520348863697`*^9}, {3.754552116908382*^9, 
-   3.7545521280396547`*^9}, {3.7545522568772163`*^9, 3.754552293840027*^9}, {
-   3.7545523350049677`*^9, 3.754552365424374*^9}, {3.754552432285963*^9, 
-   3.754552438807078*^9}, {3.7545524996793413`*^9, 3.754552508501493*^9}, {
-   3.75455257103905*^9, 3.7545525772209377`*^9}, {3.7545526199452667`*^9, 
-   3.7545526211082687`*^9}, {3.754552714180459*^9, 3.754552721274948*^9}, {
-   3.754552813150271*^9, 3.7545528569802713`*^9}, {3.754552893522524*^9, 
-   3.754552897407818*^9}, {3.7545529769717712`*^9, 3.75455298518187*^9}, {
-   3.7545531820663767`*^9, 3.754553219123618*^9}, {3.754553260819439*^9, 
-   3.754553264133251*^9}, {3.754575607642419*^9, 3.754575611415551*^9}, {
-   3.75457567878144*^9, 3.754575681900704*^9}, {3.754575763291666*^9, 
-   3.754575801084743*^9}, {3.754575870831799*^9, 3.754575911688849*^9}, {
-   3.754576037027563*^9, 3.754576044123067*^9}},
- CellLabel->"In[66]:=",ExpressionUUID->"f2dab5d6-5b18-46f7-969d-ffb46b193fbe"],
-
-Cell[BoxData[
- DynamicModuleBox[{$CellContext`x$$ = Rational[1, 2]}, 
-  RowBox[{"{", 
-   RowBox[{
-    SliderBox[Dynamic[$CellContext`x$$], {-5, 5}], ",", 
-    GraphicsBox[PointBox[Dynamic[Spline`BS2gen[$CellContext`x$$, 2]]],
-     PlotRange->2], ",", 
-    GraphicsBox[PointBox[Dynamic[Spline`BS2gen[$CellContext`x$$, 3]]],
-     PlotRange->2], ",", 
-    DynamicBox[ToBoxes[$CellContext`x$$, StandardForm],
-     ImageSizeCache->{13.034375, {12.7, 19.64}}]}], "}"}],
-  DynamicModuleValues:>{}]], "Output",
- CellChangeTimes->{{3.7545523184355*^9, 3.754552385297419*^9}, 
-   3.754552510428897*^9, 3.754552549308012*^9, {3.754552721911942*^9, 
-   3.754552737441704*^9}, 3.754552820697933*^9, {3.75455287014841*^9, 
-   3.754552918061511*^9}, 3.754552985683519*^9, 3.754553124814145*^9, {
-   3.754553210849905*^9, 3.754553220316258*^9}, {3.754553256814178*^9, 
-   3.754553278140131*^9}, 3.75457561214885*^9, 3.754575770694427*^9, 
-   3.754575831188046*^9, 3.7545758929062357`*^9, 3.7545759475135813`*^9, 
-   3.754576044915017*^9, 3.754630840095292*^9, 3.754630907353002*^9, 
-   3.754630999689699*^9, 3.754631099158774*^9, 3.7558478839025373`*^9, 
-   3.755848561121381*^9, 3.755848641704172*^9, 3.7558487017084703`*^9, 
-   3.755848740892652*^9, 3.755849532801832*^9, 3.75584978539473*^9, 
-   3.755850959411364*^9, 3.755851053599023*^9, 3.755851223954143*^9, 
-   3.756042640759983*^9, 3.756045450593169*^9, 3.756046349872642*^9, 
-   3.756046392837072*^9, 3.75604645128439*^9, 3.756046546748673*^9, 
-   3.756047100992629*^9, 3.7560471629016857`*^9, 3.756047380387445*^9, 
-   3.756111472509004*^9, {3.7561115303382387`*^9, 3.7561115712929983`*^9}},
- CellLabel->"Out[66]=",ExpressionUUID->"c0eba782-b79e-4db0-9ad9-198c8e0c1bdf"]
-}, Open  ]],
-
-Cell[CellGroupData[{
-
-Cell[BoxData[
- RowBox[{"DynamicModule", "[", 
-  RowBox[{
-   RowBox[{"{", 
-    RowBox[{"w", ",", 
-     RowBox[{"c2", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"1", "/", "2"}], ",", 
-        RowBox[{"1", "/", "5"}]}], "}"}]}]}], "}"}], ",", 
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"Slider", "[", 
-      RowBox[{
-       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", "\[IndentingNewLine]", 
-        RowBox[{
-         RowBox[{"Dynamic", "[", 
-          RowBox[{"Point", "[", 
-           RowBox[{"BS3gen", "[", 
-            RowBox[{"w", ",", 
-             RowBox[{"c2", "[", 
-              RowBox[{"[", "1", "]"}], "]"}], ",", 
-             RowBox[{"c2", "[", 
-              RowBox[{"[", "2", "]"}], "]"}], ",", "3"}], "]"}], "]"}], "]"}],
-          "\[IndentingNewLine]", ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c2", "]"}], "]"}]}], "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", "\[IndentingNewLine]", 
-        RowBox[{"Dynamic", "[", 
-         RowBox[{"Point", "[", 
-          RowBox[{"BS3gen", "[", 
-           RowBox[{"w", ",", 
-            RowBox[{"c2", "[", 
-             RowBox[{"[", "1", "]"}], "]"}], ",", 
-            RowBox[{"c2", "[", 
-             RowBox[{"[", "2", "]"}], "]"}], ",", "4"}], "]"}], "]"}], "]"}], 
-        "\[IndentingNewLine]", "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
-     RowBox[{"{", 
-      RowBox[{
-       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
-       RowBox[{"Dynamic", "[", "c2", "]"}]}], "}"}]}], "}"}]}], 
-  "]"}]], "Input",
- CellChangeTimes->{{3.754630808700841*^9, 3.754630821900537*^9}, {
-   3.754631044956431*^9, 3.754631049702402*^9}, 3.754631122405455*^9, {
-   3.754631238821062*^9, 3.754631262240226*^9}},
- CellLabel->"In[67]:=",ExpressionUUID->"06c76740-37fc-423b-9161-58680057b9fc"],
-
-Cell[BoxData[
- DynamicModuleBox[{$CellContext`w$$ = -5., $CellContext`c2$$ = {
-   Rational[1, 2], 
-   Rational[1, 5]}}, 
-  RowBox[{"{", 
-   RowBox[{
-    SliderBox[Dynamic[$CellContext`w$$], {-5, 7}], ",", 
-    GraphicsBox[{
-      DynamicBox[Typeset`ToBoxes[
-        Point[
-         Spline`BS3gen[$CellContext`w$$, 
-          Part[$CellContext`c2$$, 1], 
-          Part[$CellContext`c2$$, 2], 3]], StandardForm, Graphics],
-       ImageSizeCache->{{56.625, 121.5}, {-5.888888888888891, 
-        13.611111111111109`}}], LocatorBox[Dynamic[$CellContext`c2$$]]},
-     PlotRange->3], ",", 
-    GraphicsBox[
-     DynamicBox[Typeset`ToBoxes[
-       Point[
-        Spline`BS3gen[$CellContext`w$$, 
-         Part[$CellContext`c2$$, 1], 
-         Part[$CellContext`c2$$, 2], 4]], StandardForm, Graphics],
-      ImageSizeCache->{{56.625, 121.5}, {-5.388888888888889, -1.5}}],
-     PlotRange->3], ",", 
-    RowBox[{"{", 
-     RowBox[{
-      DynamicBox[ToBoxes[$CellContext`w$$, StandardForm],
-       ImageSizeCache->{26., {0., 9.}}], ",", 
-      DynamicBox[ToBoxes[$CellContext`c2$$, StandardForm],
-       ImageSizeCache->{55.06875, {12.7, 19.64}}]}], "}"}]}], "}"}],
-  DynamicModuleValues:>{}]], "Output",
- CellChangeTimes->{
-  3.7546308401414223`*^9, 3.754630907416758*^9, 3.754630999758555*^9, 
-   3.754631050553028*^9, 3.7546310992410717`*^9, 3.754631132895803*^9, 
-   3.754631263944324*^9, 3.755847883984211*^9, 3.7558485612009287`*^9, 
-   3.755848641759547*^9, 3.755848701767982*^9, 3.755848740961814*^9, 
-   3.7558495329250803`*^9, 3.755849785474485*^9, 3.755850959531917*^9, 
-   3.7558510536860857`*^9, 3.755851224044331*^9, 3.756042641003858*^9, 
-   3.756045450871378*^9, 3.756046349990569*^9, 3.756046393001194*^9, 
-   3.756046451438821*^9, 3.7560465468848543`*^9, 3.756047101095661*^9, 
-   3.756047163216895*^9, 3.756047380499137*^9, 3.756111472626083*^9, {
-   3.7561115305271378`*^9, 3.756111571458623*^9}},
- CellLabel->"Out[67]=",ExpressionUUID->"c6c250af-8ce8-4f9d-8825-668d17b8efe0"]
-}, Open  ]],
-
-Cell[CellGroupData[{
-
-Cell[BoxData[
- RowBox[{"DynamicModule", "[", 
-  RowBox[{
-   RowBox[{"{", 
-    RowBox[{"w", ",", 
-     RowBox[{"y", "=", 
-      RowBox[{"1", "/", "2"}]}]}], "}"}], ",", 
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"Slider", "[", 
-      RowBox[{
-       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
-     RowBox[{"Slider", "[", 
-      RowBox[{
-       RowBox[{"Dynamic", "[", "y", "]"}], ",", 
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", "\[IndentingNewLine]", 
-        RowBox[{"Dynamic", "[", 
-         RowBox[{"Point", "[", 
-          RowBox[{"BS3gen2", "[", 
-           RowBox[{"w", ",", "y", ",", "3"}], "]"}], "]"}], "]"}], "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", "\[IndentingNewLine]", 
-        RowBox[{"Dynamic", "[", 
-         RowBox[{"Point", "[", 
-          RowBox[{"BS3gen2", "[", 
-           RowBox[{"w", ",", "y", ",", "4"}], "]"}], "]"}], "]"}], 
-        "\[IndentingNewLine]", "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
-     RowBox[{"{", 
-      RowBox[{
-       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
-       RowBox[{"Dynamic", "[", "y", "]"}]}], "}"}]}], "}"}]}], "]"}]], "Input",\
-
- CellLabel->"In[68]:=",ExpressionUUID->"7467c43d-5991-4df3-aa93-d696bb7aafee"],
-
-Cell[BoxData[
- DynamicModuleBox[{$CellContext`w$$ = -5., $CellContext`y$$ = Rational[1, 2]}, 
-  RowBox[{"{", 
-   RowBox[{
-    SliderBox[Dynamic[$CellContext`w$$], {-5, 7}], ",", 
-    SliderBox[Dynamic[$CellContext`y$$], {-5, 7}], ",", 
-    GraphicsBox[
-     DynamicBox[Typeset`ToBoxes[
-       Point[
-        Spline`BS3gen2[$CellContext`w$$, $CellContext`y$$, 3]], StandardForm, 
-       Graphics],
-      ImageSizeCache->{{56.625, 121.5}, {-4.5, 14.478835978835978`}}],
-     PlotRange->3], ",", 
-    GraphicsBox[
-     DynamicBox[Typeset`ToBoxes[
-       Point[
-        Spline`BS3gen2[$CellContext`w$$, $CellContext`y$$, 4]], StandardForm, 
-       Graphics],
-      ImageSizeCache->{{56.625, 121.5}, {-4.5, 1.007122507122507}}],
-     PlotRange->3], ",", 
-    RowBox[{"{", 
-     RowBox[{
-      DynamicBox[ToBoxes[$CellContext`w$$, StandardForm],
-       ImageSizeCache->{26., {0., 9.}}], ",", 
-      DynamicBox[ToBoxes[$CellContext`y$$, StandardForm],
-       ImageSizeCache->{13.034375, {12.7, 19.64}}]}], "}"}]}], "}"}],
-  DynamicModuleValues:>{}]], "Output",
- CellChangeTimes->{
-  3.756042641249498*^9, 3.756045451120718*^9, 3.756046350128297*^9, 
-   3.756046393183093*^9, 3.756046451615221*^9, 3.756046547040237*^9, 
-   3.7560471012312098`*^9, 3.7560471638762608`*^9, 3.756047380640504*^9, 
-   3.756111472774693*^9, {3.756111530743854*^9, 3.7561115716670523`*^9}},
- CellLabel->"Out[68]=",ExpressionUUID->"fb1d0b5a-9077-430b-9cbf-2023113170a0"]
-}, Open  ]],
-
-Cell[CellGroupData[{
-
-Cell[BoxData[
- RowBox[{"DynamicModule", "[", 
-  RowBox[{
-   RowBox[{"{", 
-    RowBox[{"u", ",", 
-     RowBox[{"c2", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"2", "/", "4"}], ",", 
-        RowBox[{"1", "/", "2"}]}], "}"}]}], ",", 
-     RowBox[{"c3", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"3", "/", "4"}], ",", 
-        RowBox[{"1", "/", "3"}]}], "}"}]}]}], "}"}], ",", 
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"Slider", "[", 
-      RowBox[{
-       RowBox[{"Dynamic", "[", "u", "]"}], ",", 
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", "\[IndentingNewLine]", 
-        RowBox[{
-         RowBox[{"Dynamic", "[", 
-          RowBox[{"Point", "[", 
-           RowBox[{"BS4gen", "[", 
-            RowBox[{"u", ",", 
-             RowBox[{"c2", "[", 
-              RowBox[{"[", "1", "]"}], "]"}], ",", 
-             RowBox[{"c2", "[", 
-              RowBox[{"[", "2", "]"}], "]"}], ",", 
-             RowBox[{"c3", "[", 
-              RowBox[{"[", "1", "]"}], "]"}], ",", 
-             RowBox[{"c3", "[", 
-              RowBox[{"[", "2", "]"}], "]"}], ",", "5"}], "]"}], "]"}], "]"}],
-          "\[IndentingNewLine]", ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c2", "]"}], "]"}], ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c3", "]"}], "]"}]}], "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", "\[IndentingNewLine]", 
-        RowBox[{"Dynamic", "[", 
-         RowBox[{"Point", "[", 
-          RowBox[{"BS4gen", "[", 
-           RowBox[{"u", ",", 
-            RowBox[{"c2", "[", 
-             RowBox[{"[", "1", "]"}], "]"}], ",", 
-            RowBox[{"c2", "[", 
-             RowBox[{"[", "2", "]"}], "]"}], ",", 
-            RowBox[{"c3", "[", 
-             RowBox[{"[", "1", "]"}], "]"}], ",", 
-            RowBox[{"c3", "[", 
-             RowBox[{"[", "2", "]"}], "]"}], ",", "5"}], "]"}], "]"}], "]"}], 
-        "\[IndentingNewLine]", "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
-     RowBox[{"{", 
-      RowBox[{
-       RowBox[{"Dynamic", "[", "u", "]"}], ",", 
-       RowBox[{"Dynamic", "[", "c2", "]"}], ",", 
-       RowBox[{"Dynamic", "[", "c3", "]"}]}], "}"}]}], "}"}]}], 
-  "]"}]], "Input",
- CellChangeTimes->{{3.755847922533783*^9, 3.755848201106485*^9}, {
-  3.755848314428364*^9, 3.7558484440183496`*^9}, {3.755848492559167*^9, 
-  3.755848537912438*^9}, {3.755848575650786*^9, 3.755848620998769*^9}, {
-  3.755848684115793*^9, 3.755848687322914*^9}, {3.755848721514666*^9, 
-  3.755848724546261*^9}, {3.7558494841302013`*^9, 3.755849511265504*^9}, {
-  3.755850994239834*^9, 3.755851031938135*^9}, {3.755851107646626*^9, 
-  3.755851125031191*^9}},
- CellLabel->"In[69]:=",ExpressionUUID->"d6cd1c85-8f1b-47eb-8441-d636acd8448f"],
-
-Cell[BoxData[
- DynamicModuleBox[{$CellContext`u$$ = -5., $CellContext`c2$$ = {
-   Rational[1, 2], 
-   Rational[1, 2]}, $CellContext`c3$$ = {
-   Rational[3, 4], 
-   Rational[1, 3]}}, 
-  RowBox[{"{", 
-   RowBox[{
-    SliderBox[Dynamic[$CellContext`u$$], {-5, 7}], ",", 
-    GraphicsBox[{
-      DynamicBox[Typeset`ToBoxes[
-        Point[
-         Spline`BS4gen[$CellContext`u$$, 
-          Part[$CellContext`c2$$, 1], 
-          Part[$CellContext`c2$$, 2], 
-          Part[$CellContext`c3$$, 1], 
-          Part[$CellContext`c3$$, 2], 5]], StandardForm, Graphics],
-       ImageSizeCache->{{55.9969482421875, 121.5}, {-16.40185546875, -1.5}}], 
-      LocatorBox[Dynamic[$CellContext`c2$$]], 
-      LocatorBox[Dynamic[$CellContext`c3$$]]},
-     PlotRange->3], ",", 
-    GraphicsBox[
-     DynamicBox[Typeset`ToBoxes[
-       Point[
-        Spline`BS4gen[$CellContext`u$$, 
-         Part[$CellContext`c2$$, 1], 
-         Part[$CellContext`c2$$, 2], 
-         Part[$CellContext`c3$$, 1], 
-         Part[$CellContext`c3$$, 2], 5]], StandardForm, Graphics],
-      ImageSizeCache->{{55.9969482421875, 121.5}, {-16.40185546875, -1.5}}],
-     PlotRange->3], ",", 
-    RowBox[{"{", 
-     RowBox[{
-      DynamicBox[ToBoxes[$CellContext`u$$, StandardForm],
-       ImageSizeCache->{26., {0., 9.}}], ",", 
-      DynamicBox[ToBoxes[$CellContext`c2$$, StandardForm],
-       ImageSizeCache->{55.06875, {12.7, 19.64}}], ",", 
-      DynamicBox[ToBoxes[$CellContext`c3$$, StandardForm],
-       ImageSizeCache->{55.06875, {12.7, 19.64}}]}], "}"}]}], "}"}],
-  DynamicModuleValues:>{}]], "Output",
- CellChangeTimes->{
-  3.7558481929568233`*^9, 3.755848469436883*^9, {3.755848539110973*^9, 
-   3.755848580196279*^9}, 3.755848610809396*^9, 3.7558486418637466`*^9, {
-   3.7558486882883863`*^9, 3.755848701879325*^9}, 3.7558487410985937`*^9, 
-   3.755849532999156*^9, 3.755849785560637*^9, 3.755850959618453*^9, 
-   3.7558510537941732`*^9, 3.755851110918347*^9, 3.75585122417805*^9, 
-   3.75604264170506*^9, 3.756045451619948*^9, 3.7560463503107147`*^9, 
-   3.756046393471244*^9, 3.756046451829566*^9, 3.756046547235259*^9, 
-   3.756047101390596*^9, 3.756047164225634*^9, 3.7560473807989597`*^9, 
-   3.756111472954855*^9, {3.756111530974468*^9, 3.7561115718848352`*^9}},
- CellLabel->"Out[69]=",ExpressionUUID->"5088b2de-cfd7-47ed-bbf1-3e8ebb4b6352"]
-}, Open  ]],
-
-Cell[CellGroupData[{
-
-Cell[BoxData[
- RowBox[{"DynamicModule", "[", 
-  RowBox[{
-   RowBox[{"{", 
-    RowBox[{"u", ",", 
-     RowBox[{"w", "=", 
-      RowBox[{"2", "/", "4"}]}], ",", 
-     RowBox[{"c3", "=", 
-      RowBox[{"{", 
-       RowBox[{
-        RowBox[{"3", "/", "4"}], ",", 
-        RowBox[{"1", "/", "3"}]}], "}"}]}]}], "}"}], ",", 
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"Slider", "[", 
-      RowBox[{
-       RowBox[{"Dynamic", "[", "u", "]"}], ",", 
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
-     RowBox[{"Slider", "[", 
-      RowBox[{
-       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", "\[IndentingNewLine]", 
-        RowBox[{
-         RowBox[{"Dynamic", "[", 
-          RowBox[{"Point", "[", 
-           RowBox[{"BS4gen2", "[", 
-            RowBox[{"u", ",", "w", ",", 
-             RowBox[{"c3", "[", 
-              RowBox[{"[", "1", "]"}], "]"}], ",", 
-             RowBox[{"c3", "[", 
-              RowBox[{"[", "2", "]"}], "]"}], ",", "5"}], "]"}], "]"}], "]"}],
-          ",", 
-         RowBox[{"Locator", "[", 
-          RowBox[{"Dynamic", "[", "c3", "]"}], "]"}]}], "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", "\[IndentingNewLine]", 
-        RowBox[{"Dynamic", "[", 
-         RowBox[{"Point", "[", 
-          RowBox[{"BS4gen2", "[", 
-           RowBox[{"u", ",", "w", ",", 
-            RowBox[{"c3", "[", 
-             RowBox[{"[", "1", "]"}], "]"}], ",", 
-            RowBox[{"c3", "[", 
-             RowBox[{"[", "2", "]"}], "]"}], ",", "5"}], "]"}], "]"}], "]"}], 
-        "\[IndentingNewLine]", "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
-     RowBox[{"{", 
-      RowBox[{
-       RowBox[{"Dynamic", "[", "u", "]"}], ",", 
-       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
-       RowBox[{"Dynamic", "[", "c3", "]"}]}], "}"}]}], "}"}]}], 
-  "]"}]], "Input",
- CellChangeTimes->{{3.756046259490569*^9, 3.756046333778741*^9}, {
-  3.7560463694590683`*^9, 3.756046370845158*^9}},
- CellLabel->"In[70]:=",ExpressionUUID->"13281535-0874-469c-9673-5469dd452985"],
-
-Cell[BoxData[
- DynamicModuleBox[{$CellContext`u$$ = -5., $CellContext`w$$ = Rational[
-  1, 2], $CellContext`c3$$ = {
-   Rational[3, 4], 
-   Rational[1, 3]}}, 
-  RowBox[{"{", 
-   RowBox[{
-    SliderBox[Dynamic[$CellContext`u$$], {-5, 7}], ",", 
-    SliderBox[Dynamic[$CellContext`w$$], {-5, 7}], ",", 
-    GraphicsBox[{
-      DynamicBox[Typeset`ToBoxes[
-        Point[
-         Spline`BS4gen2[$CellContext`u$$, $CellContext`w$$, 
-          Part[$CellContext`c3$$, 1], 
-          Part[$CellContext`c3$$, 2], 5]], StandardForm, Graphics],
-       ImageSizeCache->{{55.9969482421875, 
-        121.5}, {-11.065638950892858`, -1.5}}], 
-      LocatorBox[Dynamic[$CellContext`c3$$]]},
-     PlotRange->3], ",", 
-    GraphicsBox[
-     DynamicBox[Typeset`ToBoxes[
-       Point[
-        Spline`BS4gen2[$CellContext`u$$, $CellContext`w$$, 
-         Part[$CellContext`c3$$, 1], 
-         Part[$CellContext`c3$$, 2], 5]], StandardForm, Graphics],
-      ImageSizeCache->{{55.9969482421875, 
-       121.5}, {-11.065638950892858`, -1.5}}],
-     PlotRange->3], ",", 
-    RowBox[{"{", 
-     RowBox[{
-      DynamicBox[ToBoxes[$CellContext`u$$, StandardForm],
-       ImageSizeCache->{26., {0., 9.}}], ",", 
-      DynamicBox[ToBoxes[$CellContext`w$$, StandardForm],
-       ImageSizeCache->{13.034375, {12.7, 19.64}}], ",", 
-      DynamicBox[ToBoxes[$CellContext`c3$$, StandardForm],
-       ImageSizeCache->{55.06875, {12.7, 19.64}}]}], "}"}]}], "}"}],
-  DynamicModuleValues:>{}]], "Output",
- CellChangeTimes->{{3.756046350491942*^9, 3.75604639381249*^9}, {
-   3.75604644512803*^9, 3.756046452180924*^9}, 3.756046547419788*^9, 
-   3.7560471015596*^9, 3.756047164933318*^9, 3.756047380951084*^9, 
-   3.756111473175436*^9, {3.756111531503964*^9, 3.756111572317801*^9}},
- CellLabel->"Out[70]=",ExpressionUUID->"f870b8b4-82f8-4352-807e-8d4827e28bcd"]
-}, Open  ]],
-
-Cell[CellGroupData[{
-
-Cell[BoxData[
- RowBox[{"DynamicModule", "[", 
-  RowBox[{
-   RowBox[{"{", 
-    RowBox[{"u", ",", 
-     RowBox[{"w", "=", 
-      RowBox[{"2", "/", "4"}]}], ",", 
-     RowBox[{"y", "=", 
-      RowBox[{"3", "/", "4"}]}]}], "}"}], ",", 
-   RowBox[{"{", 
-    RowBox[{
-     RowBox[{"Slider", "[", 
-      RowBox[{
-       RowBox[{"Dynamic", "[", "u", "]"}], ",", 
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
-     RowBox[{"Slider", "[", 
-      RowBox[{
-       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
-     RowBox[{"Slider", "[", 
-      RowBox[{
-       RowBox[{"Dynamic", "[", "y", "]"}], ",", 
-       RowBox[{"{", 
-        RowBox[{
-         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", "\[IndentingNewLine]", 
-        RowBox[{"Dynamic", "[", 
-         RowBox[{"Point", "[", 
-          RowBox[{"BS4gen3", "[", 
-           RowBox[{"u", ",", "w", ",", "y", ",", "5"}], "]"}], "]"}], "]"}], 
-        "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
-     RowBox[{"Graphics", "[", 
-      RowBox[{
-       RowBox[{"{", "\[IndentingNewLine]", 
-        RowBox[{"Dynamic", "[", 
-         RowBox[{"Point", "[", 
-          RowBox[{"BS4gen3", "[", 
-           RowBox[{"u", ",", "w", ",", "y", ",", "5"}], "]"}], "]"}], "]"}], 
-        "\[IndentingNewLine]", "}"}], ",", 
-       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
-     RowBox[{"{", 
-      RowBox[{
-       RowBox[{"Dynamic", "[", "u", "]"}], ",", 
-       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
-       RowBox[{"Dynamic", "[", "y", "]"}]}], "}"}]}], "}"}]}], "]"}]], "Input",\
-
- CellChangeTimes->{{3.7561113658004427`*^9, 3.756111427418873*^9}, {
-  3.756111489670693*^9, 3.75611149321799*^9}},
- CellLabel->"In[71]:=",ExpressionUUID->"5445dab5-8e96-4d99-9f40-43b620bd846e"],
-
-Cell[BoxData[
- DynamicModuleBox[{$CellContext`u$$ = -5., $CellContext`w$$ = Rational[
-  1, 2], $CellContext`y$$ = Rational[3, 4]}, 
-  RowBox[{"{", 
-   RowBox[{
-    SliderBox[Dynamic[$CellContext`u$$], {-5, 7}], ",", 
-    SliderBox[Dynamic[$CellContext`w$$], {-5, 7}], ",", 
-    SliderBox[Dynamic[$CellContext`y$$], {-5, 7}], ",", 
-    GraphicsBox[
-     DynamicBox[Typeset`ToBoxes[
-       Point[
-        Spline`BS4gen3[$CellContext`u$$, $CellContext`w$$, $CellContext`y$$, 
-         5]], StandardForm, Graphics],
-      ImageSizeCache->{{0., 0.}, {0., 0.}}],
-     PlotRange->3], ",", 
-    GraphicsBox[
-     DynamicBox[Typeset`ToBoxes[
-       Point[
-        Spline`BS4gen3[$CellContext`u$$, $CellContext`w$$, $CellContext`y$$, 
-         5]], StandardForm, Graphics],
-      ImageSizeCache->{{0., 0.}, {0., 0.}}],
-     PlotRange->3], ",", 
-    RowBox[{"{", 
-     RowBox[{
-      DynamicBox[ToBoxes[$CellContext`u$$, StandardForm],
-       ImageSizeCache->{26., {0., 9.}}], ",", 
-      DynamicBox[ToBoxes[$CellContext`w$$, StandardForm],
-       ImageSizeCache->{13.034375, {12.7, 19.64}}], ",", 
-      DynamicBox[ToBoxes[$CellContext`y$$, StandardForm],
-       ImageSizeCache->{13.034375, {12.7, 19.64}}]}], "}"}]}], "}"}],
-  DynamicModuleValues:>{}]], "Output",
- CellChangeTimes->{{3.7561114732924013`*^9, 3.7561114947720623`*^9}, {
-  3.756111531681285*^9, 3.756111572485814*^9}},
- CellLabel->"Out[71]=",ExpressionUUID->"3af4803a-eeb7-4713-a5dd-7d330fc9fb91"]
-}, Open  ]]
-},
-WindowSize->{878, 963},
-WindowMargins->{{Automatic, 294}, {21, Automatic}},
-FrontEndVersion->"11.3 for Linux x86 (64-bit) (March 6, 2018)",
-StyleDefinitions->"Default.nb"
-]
-(* End of Notebook Content *)
-
-(* Internal cache information *)
-(*CellTagsOutline
-CellTagsIndex->{}
-*)
-(*CellTagsIndex
-CellTagsIndex->{}
-*)
-(*NotebookFileOutline
-Notebook[{
-Cell[558, 20, 241, 6, 31, "Input",ExpressionUUID->"2e7c28c4-94b6-4f0a-b06a-4128b32d2ac4"],
-Cell[802, 28, 217, 3, 31, "Input",ExpressionUUID->"5778195a-5bf6-4b92-9642-c2f2bd572a9d"],
-Cell[1022, 33, 459, 9, 81, "Text",ExpressionUUID->"6ea8292c-4b09-4e06-a3d1-0027de311060"],
-Cell[CellGroupData[{
-Cell[1506, 46, 5954, 100, 101, "Input",ExpressionUUID->"f2dab5d6-5b18-46f7-969d-ffb46b193fbe"],
-Cell[7463, 148, 1715, 28, 199, "Output",ExpressionUUID->"c0eba782-b79e-4db0-9ad9-198c8e0c1bdf"]
-}, Open  ]],
-Cell[CellGroupData[{
-Cell[9215, 181, 2071, 55, 124, "Input",ExpressionUUID->"06c76740-37fc-423b-9161-58680057b9fc"],
-Cell[11289, 238, 1985, 42, 199, "Output",ExpressionUUID->"c6c250af-8ce8-4f9d-8825-668d17b8efe0"]
-}, Open  ]],
-Cell[CellGroupData[{
-Cell[13311, 285, 1524, 43, 124, "Input",ExpressionUUID->"7467c43d-5991-4df3-aa93-d696bb7aafee"],
-Cell[14838, 330, 1439, 32, 244, "Output",ExpressionUUID->"fb1d0b5a-9077-430b-9cbf-2023113170a0"]
-}, Open  ]],
-Cell[CellGroupData[{
-Cell[16314, 367, 2969, 75, 124, "Input",ExpressionUUID->"d6cd1c85-8f1b-47eb-8441-d636acd8448f"],
-Cell[19286, 444, 2317, 50, 415, "Output",ExpressionUUID->"5088b2de-cfd7-47ed-bbf1-3e8ebb4b6352"]
-}, Open  ]],
-Cell[CellGroupData[{
-Cell[21640, 499, 2305, 63, 147, "Input",ExpressionUUID->"13281535-0874-469c-9673-5469dd452985"],
-Cell[23948, 564, 1821, 41, 244, "Output",ExpressionUUID->"f870b8b4-82f8-4352-807e-8d4827e28bcd"]
-}, Open  ]],
-Cell[CellGroupData[{
-Cell[25806, 610, 1975, 55, 147, "Input",ExpressionUUID->"5445dab5-8e96-4d99-9f40-43b620bd846e"],
-Cell[27784, 667, 1452, 33, 277, "Output",ExpressionUUID->"3af4803a-eeb7-4713-a5dd-7d330fc9fb91"]
-}, Open  ]]
-}
-]
-*)
-
+(* Content-type: application/vnd.wolfram.mathematica *)
+
+(*** Wolfram Notebook File ***)
+(* http://www.wolfram.com/nb *)
+
+(* CreatedBy='Mathematica 11.3' *)
+
+(*CacheID: 234*)
+(* Internal cache information:
+NotebookFileLineBreakTest
+NotebookFileLineBreakTest
+NotebookDataPosition[       158,          7]
+NotebookDataLength[     32243,        765]
+NotebookOptionsPosition[     30359,        725]
+NotebookOutlinePosition[     30748,        741]
+CellTagsIndexPosition[     30705,        738]
+WindowFrame->Normal*)
+
+(* Beginning of Notebook Content *)
+Notebook[{
+Cell[BoxData[
+ RowBox[{"ClearAll", "[", 
+  RowBox[{"Evaluate", "[", 
+   RowBox[{
+    RowBox[{"Context", "[", "]"}], "<>", "\"\<*\>\""}], "]"}], "]"}]], "Input",
+ CellLabel->"In[54]:=",ExpressionUUID->"2e7c28c4-94b6-4f0a-b06a-4128b32d2ac4"],
+
+Cell[BoxData[
+ RowBox[{"Needs", "[", "\"\<Spline`\>\"", "]"}]], "Input",
+ CellChangeTimes->{{3.753703047291655*^9, 3.753703055136489*^9}, {
+  3.8099611545849333`*^9, 3.8099611564059277`*^9}, {3.809961440640325*^9, 
+  3.809961441609899*^9}},
+ CellLabel->"In[55]:=",ExpressionUUID->"5778195a-5bf6-4b92-9642-c2f2bd572a9d"],
+
+Cell["\<\
+we define it bernstein AND a circular
+we plot every height of control point y, that results in a bernstein charpol
+we insert y in spline and set x half condition\
+\>", "Text",
+ CellChangeTimes->{{3.754482064436014*^9, 3.754482075565927*^9}, {
+  3.754483241295146*^9, 3.7544832886860857`*^9}, {3.754483379201844*^9, 
+  3.754483394036672*^9}, {3.7544835417408333`*^9, 
+  3.754483555887239*^9}},ExpressionUUID->"6ea8292c-4b09-4e06-a3d1-\
+0027de311060"],
+
+Cell[CellGroupData[{
+
+Cell[BoxData[
+ RowBox[{
+  RowBox[{"(*", 
+   RowBox[{
+    RowBox[{"Clear", "[", "y", "]"}], ";", 
+    RowBox[{"xin", "=", 
+     RowBox[{"1", "/", "2"}]}], ";", 
+    RowBox[{"n", "=", "3"}], ";", 
+    RowBox[{"i", "=", "3"}], ";"}], "*)"}], "\[IndentingNewLine]", 
+  RowBox[{"DynamicModule", "[", 
+   RowBox[{
+    RowBox[{"{", 
+     RowBox[{"x", "=", 
+      RowBox[{"1", "/", "2"}]}], "}"}], ",", 
+    RowBox[{"{", 
+     RowBox[{
+      RowBox[{"Slider", "[", 
+       RowBox[{
+        RowBox[{"Dynamic", "[", "x", "]"}], ",", 
+        RowBox[{"{", 
+         RowBox[{
+          RowBox[{"-", "5"}], ",", "5"}], "}"}]}], "]"}], ",", 
+      RowBox[{"Graphics", "[", 
+       RowBox[{
+        RowBox[{"Point", "[", 
+         RowBox[{"Dynamic", "[", 
+          RowBox[{"BS2gen", "[", 
+           RowBox[{"x", ",", "2"}], "]"}], "]"}], "]"}], ",", 
+        RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
+      RowBox[{"Graphics", "[", 
+       RowBox[{
+        RowBox[{"Point", "[", 
+         RowBox[{"Dynamic", "[", 
+          RowBox[{"BS2gen", "[", 
+           RowBox[{"x", ",", "3"}], "]"}], "]"}], "]"}], ",", 
+        RowBox[{"PlotRange", "\[Rule]", "2"}]}], "]"}], ",", 
+      RowBox[{"Dynamic", "[", "x", "]"}]}], "}"}]}], "]"}]}]], "Input",
+ CellChangeTimes->{{3.754481401060038*^9, 3.754481401140205*^9}, {
+   3.754481432540495*^9, 3.7544814497057667`*^9}, {3.7544815445051928`*^9, 
+   3.754481555217092*^9}, {3.754483684703184*^9, 3.754483688656671*^9}, {
+   3.754502530505373*^9, 3.75450255108272*^9}, {3.754502676827174*^9, 
+   3.754502710406823*^9}, {3.75450277711789*^9, 3.754502810499543*^9}, {
+   3.754502863207444*^9, 3.7545029555092688`*^9}, {3.754502985665998*^9, 
+   3.75450298866074*^9}, 3.754503063529188*^9, {3.7545033614302073`*^9, 
+   3.7545033960931587`*^9}, {3.7545034363075*^9, 3.7545034392802477`*^9}, {
+   3.75450392191022*^9, 3.754503974735487*^9}, {3.7545040204983664`*^9, 
+   3.754504159662684*^9}, {3.7545041941952457`*^9, 3.7545042844185038`*^9}, {
+   3.754504346800758*^9, 3.754504359258341*^9}, {3.7545044428743134`*^9, 
+   3.754504484213958*^9}, {3.754504585320714*^9, 3.754504585501659*^9}, {
+   3.754504638659412*^9, 3.7545046590473957`*^9}, {3.754504704169757*^9, 
+   3.75450475832257*^9}, {3.754504797136759*^9, 3.754504805979965*^9}, {
+   3.754545851514345*^9, 3.754545851942646*^9}, {3.754545897672845*^9, 
+   3.75454590524221*^9}, {3.754546014374165*^9, 3.754546035375721*^9}, {
+   3.754546195580285*^9, 3.754546202246608*^9}, {3.754546297134654*^9, 
+   3.754546310095613*^9}, {3.7545463511705008`*^9, 3.754546364285737*^9}, {
+   3.754546395235423*^9, 3.754546404153283*^9}, {3.754547306795676*^9, 
+   3.7545473111961193`*^9}, {3.754547342162428*^9, 3.754547342526368*^9}, {
+   3.754547379617714*^9, 3.754547387150385*^9}, {3.754547445751247*^9, 
+   3.754547456250901*^9}, {3.754547503850618*^9, 3.754547519738544*^9}, {
+   3.7545475817289333`*^9, 3.7545475833511343`*^9}, {3.754547640831354*^9, 
+   3.754547651971673*^9}, {3.7545477000233927`*^9, 3.7545477220249767`*^9}, {
+   3.75454789514637*^9, 3.754547917089939*^9}, {3.7545479858514843`*^9, 
+   3.754547990744977*^9}, {3.754548081869421*^9, 3.754548082195418*^9}, {
+   3.754548114863475*^9, 3.754548116422688*^9}, {3.754548182576198*^9, 
+   3.754548230981401*^9}, {3.754548267148219*^9, 3.754548437004656*^9}, {
+   3.754548539938387*^9, 3.754548579659973*^9}, 3.75454862283095*^9, {
+   3.754548660405346*^9, 3.7545487090964127`*^9}, 3.754548871486515*^9, {
+   3.754548911714615*^9, 3.754548914294018*^9}, {3.754548948800377*^9, 
+   3.7545489640380383`*^9}, {3.7545490075791283`*^9, 3.754549025349691*^9}, {
+   3.754549089575644*^9, 3.75454909712577*^9}, {3.75454915945127*^9, 
+   3.754549187726894*^9}, {3.754549241639045*^9, 3.754549292804276*^9}, {
+   3.7545493351768007`*^9, 3.754549335571546*^9}, {3.7545493886852827`*^9, 
+   3.754549422720606*^9}, {3.754549468408227*^9, 3.754549477247114*^9}, {
+   3.754549539577738*^9, 3.754549543332945*^9}, 3.754549659249805*^9, {
+   3.754550056800836*^9, 3.7545500847937107`*^9}, {3.754550117193722*^9, 
+   3.7545501271695023`*^9}, 3.754550227127472*^9, {3.7545503457588987`*^9, 
+   3.754550369720083*^9}, {3.754550454773521*^9, 3.75455047828636*^9}, {
+   3.754550520456238*^9, 3.754550520701301*^9}, {3.754550609468131*^9, 
+   3.754550614315284*^9}, {3.754550655662147*^9, 3.754550788879006*^9}, {
+   3.754550857241721*^9, 3.754550866477723*^9}, {3.754550943004135*^9, 
+   3.754550944443205*^9}, {3.7545510670945253`*^9, 3.7545510825967607`*^9}, {
+   3.754551115214447*^9, 3.7545511212415857`*^9}, {3.754551160374297*^9, 
+   3.754551271645986*^9}, {3.754551320092498*^9, 3.754551332889049*^9}, {
+   3.7545513873375587`*^9, 3.754551430550577*^9}, {3.754551593212818*^9, 
+   3.754551593655097*^9}, {3.7545516435548286`*^9, 3.754551686669298*^9}, {
+   3.7545517316198483`*^9, 3.754551803949479*^9}, {3.754551852451798*^9, 
+   3.75455185608421*^9}, {3.754551892456603*^9, 3.754551896295888*^9}, {
+   3.75455196047121*^9, 3.7545520348863697`*^9}, {3.754552116908382*^9, 
+   3.7545521280396547`*^9}, {3.7545522568772163`*^9, 3.754552293840027*^9}, {
+   3.7545523350049677`*^9, 3.754552365424374*^9}, {3.754552432285963*^9, 
+   3.754552438807078*^9}, {3.7545524996793413`*^9, 3.754552508501493*^9}, {
+   3.75455257103905*^9, 3.7545525772209377`*^9}, {3.7545526199452667`*^9, 
+   3.7545526211082687`*^9}, {3.754552714180459*^9, 3.754552721274948*^9}, {
+   3.754552813150271*^9, 3.7545528569802713`*^9}, {3.754552893522524*^9, 
+   3.754552897407818*^9}, {3.7545529769717712`*^9, 3.75455298518187*^9}, {
+   3.7545531820663767`*^9, 3.754553219123618*^9}, {3.754553260819439*^9, 
+   3.754553264133251*^9}, {3.754575607642419*^9, 3.754575611415551*^9}, {
+   3.75457567878144*^9, 3.754575681900704*^9}, {3.754575763291666*^9, 
+   3.754575801084743*^9}, {3.754575870831799*^9, 3.754575911688849*^9}, {
+   3.754576037027563*^9, 3.754576044123067*^9}},
+ CellLabel->"In[56]:=",ExpressionUUID->"f2dab5d6-5b18-46f7-969d-ffb46b193fbe"],
+
+Cell[BoxData[
+ DynamicModuleBox[{$CellContext`x$$ = Rational[1, 2]}, 
+  RowBox[{"{", 
+   RowBox[{
+    SliderBox[Dynamic[$CellContext`x$$], {-5, 5}], ",", 
+    GraphicsBox[PointBox[Dynamic[Spline`BS2gen[$CellContext`x$$, 2]]],
+     PlotRange->2], ",", 
+    GraphicsBox[PointBox[Dynamic[Spline`BS2gen[$CellContext`x$$, 3]]],
+     PlotRange->2], ",", 
+    DynamicBox[ToBoxes[$CellContext`x$$, StandardForm],
+     ImageSizeCache->{
+      12.678125000000001`, {10.6703125, 18.807499999999997`}}]}], "}"}],
+  DynamicModuleValues:>{}]], "Output",
+ CellChangeTimes->{{3.7545523184355*^9, 3.754552385297419*^9}, 
+   3.754552510428897*^9, 3.754552549308012*^9, {3.754552721911942*^9, 
+   3.754552737441704*^9}, 3.754552820697933*^9, {3.75455287014841*^9, 
+   3.754552918061511*^9}, 3.754552985683519*^9, 3.754553124814145*^9, {
+   3.754553210849905*^9, 3.754553220316258*^9}, {3.754553256814178*^9, 
+   3.754553278140131*^9}, 3.75457561214885*^9, 3.754575770694427*^9, 
+   3.754575831188046*^9, 3.7545758929062357`*^9, 3.7545759475135813`*^9, 
+   3.754576044915017*^9, 3.754630840095292*^9, 3.754630907353002*^9, 
+   3.754630999689699*^9, 3.754631099158774*^9, 3.7558478839025373`*^9, 
+   3.755848561121381*^9, 3.755848641704172*^9, 3.7558487017084703`*^9, 
+   3.755848740892652*^9, 3.755849532801832*^9, 3.75584978539473*^9, 
+   3.755850959411364*^9, 3.755851053599023*^9, 3.755851223954143*^9, 
+   3.756042640759983*^9, 3.756045450593169*^9, 3.756046349872642*^9, 
+   3.756046392837072*^9, 3.75604645128439*^9, 3.756046546748673*^9, 
+   3.756047100992629*^9, 3.7560471629016857`*^9, 3.756047380387445*^9, 
+   3.756111472509004*^9, {3.7561115303382387`*^9, 3.7561115712929983`*^9}, 
+   3.8063032249809165`*^9, 3.807187691058337*^9, 3.809961131479926*^9, {
+   3.8099614778308992`*^9, 3.809961483718093*^9}},
+ CellLabel->"Out[56]=",ExpressionUUID->"e6cd772c-5192-41b1-8ba4-384a183c98ce"]
+}, Open  ]],
+
+Cell[CellGroupData[{
+
+Cell[BoxData[
+ RowBox[{"DynamicModule", "[", 
+  RowBox[{
+   RowBox[{"{", 
+    RowBox[{"w", ",", 
+     RowBox[{"c2", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{"1", "/", "2"}], ",", 
+        RowBox[{"1", "/", "5"}]}], "}"}]}]}], "}"}], ",", 
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"Slider", "[", 
+      RowBox[{
+       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", "\[IndentingNewLine]", 
+        RowBox[{
+         RowBox[{"Dynamic", "[", 
+          RowBox[{"Point", "[", 
+           RowBox[{"BS3gen", "[", 
+            RowBox[{"w", ",", 
+             RowBox[{"c2", "[", 
+              RowBox[{"[", "1", "]"}], "]"}], ",", 
+             RowBox[{"c2", "[", 
+              RowBox[{"[", "2", "]"}], "]"}], ",", "3"}], "]"}], "]"}], "]"}],
+          "\[IndentingNewLine]", ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c2", "]"}], "]"}]}], "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", "\[IndentingNewLine]", 
+        RowBox[{"Dynamic", "[", 
+         RowBox[{"Point", "[", 
+          RowBox[{"BS3gen", "[", 
+           RowBox[{"w", ",", 
+            RowBox[{"c2", "[", 
+             RowBox[{"[", "1", "]"}], "]"}], ",", 
+            RowBox[{"c2", "[", 
+             RowBox[{"[", "2", "]"}], "]"}], ",", "4"}], "]"}], "]"}], "]"}], 
+        "\[IndentingNewLine]", "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
+     RowBox[{"{", 
+      RowBox[{
+       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
+       RowBox[{"Dynamic", "[", "c2", "]"}]}], "}"}]}], "}"}]}], 
+  "]"}]], "Input",
+ CellChangeTimes->{{3.754630808700841*^9, 3.754630821900537*^9}, {
+   3.754631044956431*^9, 3.754631049702402*^9}, 3.754631122405455*^9, {
+   3.754631238821062*^9, 3.754631262240226*^9}},
+ CellLabel->"In[57]:=",ExpressionUUID->"06c76740-37fc-423b-9161-58680057b9fc"],
+
+Cell[BoxData[
+ DynamicModuleBox[{$CellContext`w$$ = -5., $CellContext`c2$$ = {
+   Rational[1, 2], 
+   Rational[1, 5]}}, 
+  RowBox[{"{", 
+   RowBox[{
+    SliderBox[Dynamic[$CellContext`w$$], {-5, 7}], ",", 
+    GraphicsBox[{
+      DynamicBox[Typeset`ToBoxes[
+        Point[
+         Spline`BS3gen[$CellContext`w$$, 
+          Part[$CellContext`c2$$, 1], 
+          Part[$CellContext`c2$$, 2], 3]], StandardForm, Graphics],
+       ImageSizeCache->{{88.5, 196.5}, {-27.5, 23.5}}], 
+      LocatorBox[Dynamic[$CellContext`c2$$]]},
+     PlotRange->3], ",", 
+    GraphicsBox[
+     DynamicBox[Typeset`ToBoxes[
+       Point[
+        Spline`BS3gen[$CellContext`w$$, 
+         Part[$CellContext`c2$$, 1], 
+         Part[$CellContext`c2$$, 2], 4]], StandardForm, Graphics],
+      ImageSizeCache->{{88.5, 196.5}, {-3.5, 5.5}}],
+     PlotRange->3], ",", 
+    RowBox[{"{", 
+     RowBox[{
+      DynamicBox[ToBoxes[$CellContext`w$$, StandardForm],
+       ImageSizeCache->{25., {1., 9.}}], ",", 
+      DynamicBox[ToBoxes[$CellContext`c2$$, StandardForm],
+       ImageSizeCache->{54.35625, {11.6703125, 18.807499999999997`}}]}], 
+     "}"}]}], "}"}],
+  DynamicModuleValues:>{}]], "Output",
+ CellChangeTimes->{
+  3.7546308401414223`*^9, 3.754630907416758*^9, 3.754630999758555*^9, 
+   3.754631050553028*^9, 3.7546310992410717`*^9, 3.754631132895803*^9, 
+   3.754631263944324*^9, 3.755847883984211*^9, 3.7558485612009287`*^9, 
+   3.755848641759547*^9, 3.755848701767982*^9, 3.755848740961814*^9, 
+   3.7558495329250803`*^9, 3.755849785474485*^9, 3.755850959531917*^9, 
+   3.7558510536860857`*^9, 3.755851224044331*^9, 3.756042641003858*^9, 
+   3.756045450871378*^9, 3.756046349990569*^9, 3.756046393001194*^9, 
+   3.756046451438821*^9, 3.7560465468848543`*^9, 3.756047101095661*^9, 
+   3.756047163216895*^9, 3.756047380499137*^9, 3.756111472626083*^9, {
+   3.7561115305271378`*^9, 3.756111571458623*^9}, 3.806303225061867*^9, 
+   3.807187691228697*^9, 3.8099611315656147`*^9, {3.809961477894141*^9, 
+   3.809961483808947*^9}},
+ CellLabel->"Out[57]=",ExpressionUUID->"fcfe3b42-8d99-4fcd-8c07-3e794b546f06"]
+}, Open  ]],
+
+Cell[CellGroupData[{
+
+Cell[BoxData[
+ RowBox[{"DynamicModule", "[", 
+  RowBox[{
+   RowBox[{"{", 
+    RowBox[{"w", ",", 
+     RowBox[{"y", "=", 
+      RowBox[{"1", "/", "2"}]}]}], "}"}], ",", 
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"Slider", "[", 
+      RowBox[{
+       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
+     RowBox[{"Slider", "[", 
+      RowBox[{
+       RowBox[{"Dynamic", "[", "y", "]"}], ",", 
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", "\[IndentingNewLine]", 
+        RowBox[{"Dynamic", "[", 
+         RowBox[{"Point", "[", 
+          RowBox[{"BS3gen2", "[", 
+           RowBox[{"w", ",", "y", ",", "3"}], "]"}], "]"}], "]"}], "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", "\[IndentingNewLine]", 
+        RowBox[{"Dynamic", "[", 
+         RowBox[{"Point", "[", 
+          RowBox[{"BS3gen2", "[", 
+           RowBox[{"w", ",", "y", ",", "4"}], "]"}], "]"}], "]"}], 
+        "\[IndentingNewLine]", "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
+     RowBox[{"{", 
+      RowBox[{
+       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
+       RowBox[{"Dynamic", "[", "y", "]"}]}], "}"}]}], "}"}]}], "]"}]], "Input",
+ CellLabel->"In[58]:=",ExpressionUUID->"7467c43d-5991-4df3-aa93-d696bb7aafee"],
+
+Cell[BoxData[
+ DynamicModuleBox[{$CellContext`w$$ = -5., $CellContext`y$$ = Rational[1, 2]}, 
+  RowBox[{"{", 
+   RowBox[{
+    SliderBox[Dynamic[$CellContext`w$$], {-5, 7}], ",", 
+    SliderBox[Dynamic[$CellContext`y$$], {-5, 7}], ",", 
+    GraphicsBox[
+     DynamicBox[Typeset`ToBoxes[
+       Point[
+        Spline`BS3gen2[$CellContext`w$$, $CellContext`y$$, 3]], StandardForm, 
+       Graphics],
+      ImageSizeCache->{{88.5, 196.5}, {-3.5, 26.772727272727273`}}],
+     PlotRange->3], ",", 
+    GraphicsBox[
+     DynamicBox[Typeset`ToBoxes[
+       Point[
+        Spline`BS3gen2[$CellContext`w$$, $CellContext`y$$, 4]], StandardForm, 
+       Graphics],
+      ImageSizeCache->{{88.5, 196.5}, {-3.5, 34.49999999999999}}],
+     PlotRange->3], ",", 
+    RowBox[{"{", 
+     RowBox[{
+      DynamicBox[ToBoxes[$CellContext`w$$, StandardForm],
+       ImageSizeCache->{25., {1., 9.}}], ",", 
+      DynamicBox[ToBoxes[$CellContext`y$$, StandardForm],
+       ImageSizeCache->{
+        12.678125000000001`, {10.6703125, 18.807499999999997`}}]}], "}"}]}], 
+   "}"}],
+  DynamicModuleValues:>{}]], "Output",
+ CellChangeTimes->{
+  3.756042641249498*^9, 3.756045451120718*^9, 3.756046350128297*^9, 
+   3.756046393183093*^9, 3.756046451615221*^9, 3.756046547040237*^9, 
+   3.7560471012312098`*^9, 3.7560471638762608`*^9, 3.756047380640504*^9, 
+   3.756111472774693*^9, {3.756111530743854*^9, 3.7561115716670523`*^9}, 
+   3.806303225097844*^9, 3.807187691411377*^9, 3.809961131654141*^9, {
+   3.809961477969429*^9, 3.8099614839124002`*^9}},
+ CellLabel->"Out[58]=",ExpressionUUID->"6d219e22-0d77-4ef7-92fb-c9cb7bc5975a"]
+}, Open  ]],
+
+Cell[CellGroupData[{
+
+Cell[BoxData[
+ RowBox[{"DynamicModule", "[", 
+  RowBox[{
+   RowBox[{"{", 
+    RowBox[{"u", ",", 
+     RowBox[{"c2", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{"2", "/", "4"}], ",", 
+        RowBox[{"1", "/", "2"}]}], "}"}]}], ",", 
+     RowBox[{"c3", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{"3", "/", "4"}], ",", 
+        RowBox[{"1", "/", "3"}]}], "}"}]}]}], "}"}], ",", 
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"Slider", "[", 
+      RowBox[{
+       RowBox[{"Dynamic", "[", "u", "]"}], ",", 
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", "\[IndentingNewLine]", 
+        RowBox[{
+         RowBox[{"Dynamic", "[", 
+          RowBox[{"Point", "[", 
+           RowBox[{"BS4gen", "[", 
+            RowBox[{"u", ",", 
+             RowBox[{"c2", "[", 
+              RowBox[{"[", "1", "]"}], "]"}], ",", 
+             RowBox[{"c2", "[", 
+              RowBox[{"[", "2", "]"}], "]"}], ",", 
+             RowBox[{"c3", "[", 
+              RowBox[{"[", "1", "]"}], "]"}], ",", 
+             RowBox[{"c3", "[", 
+              RowBox[{"[", "2", "]"}], "]"}], ",", "5"}], "]"}], "]"}], "]"}],
+          "\[IndentingNewLine]", ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c2", "]"}], "]"}], ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c3", "]"}], "]"}]}], "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", "\[IndentingNewLine]", 
+        RowBox[{"Dynamic", "[", 
+         RowBox[{"Point", "[", 
+          RowBox[{"BS4gen", "[", 
+           RowBox[{"u", ",", 
+            RowBox[{"c2", "[", 
+             RowBox[{"[", "1", "]"}], "]"}], ",", 
+            RowBox[{"c2", "[", 
+             RowBox[{"[", "2", "]"}], "]"}], ",", 
+            RowBox[{"c3", "[", 
+             RowBox[{"[", "1", "]"}], "]"}], ",", 
+            RowBox[{"c3", "[", 
+             RowBox[{"[", "2", "]"}], "]"}], ",", "5"}], "]"}], "]"}], "]"}], 
+        "\[IndentingNewLine]", "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
+     RowBox[{"{", 
+      RowBox[{
+       RowBox[{"Dynamic", "[", "u", "]"}], ",", 
+       RowBox[{"Dynamic", "[", "c2", "]"}], ",", 
+       RowBox[{"Dynamic", "[", "c3", "]"}]}], "}"}]}], "}"}]}], 
+  "]"}]], "Input",
+ CellChangeTimes->{{3.755847922533783*^9, 3.755848201106485*^9}, {
+  3.755848314428364*^9, 3.7558484440183496`*^9}, {3.755848492559167*^9, 
+  3.755848537912438*^9}, {3.755848575650786*^9, 3.755848620998769*^9}, {
+  3.755848684115793*^9, 3.755848687322914*^9}, {3.755848721514666*^9, 
+  3.755848724546261*^9}, {3.7558494841302013`*^9, 3.755849511265504*^9}, {
+  3.755850994239834*^9, 3.755851031938135*^9}, {3.755851107646626*^9, 
+  3.755851125031191*^9}},
+ CellLabel->"In[59]:=",ExpressionUUID->"d6cd1c85-8f1b-47eb-8441-d636acd8448f"],
+
+Cell[BoxData[
+ DynamicModuleBox[{$CellContext`u$$ = -5., $CellContext`c2$$ = {
+   Rational[1, 2], 
+   Rational[1, 2]}, $CellContext`c3$$ = {
+   Rational[3, 4], 
+   Rational[1, 3]}}, 
+  RowBox[{"{", 
+   RowBox[{
+    SliderBox[Dynamic[$CellContext`u$$], {-5, 7}], ",", 
+    GraphicsBox[{
+      DynamicBox[Typeset`ToBoxes[
+        Point[
+         Spline`BS4gen[$CellContext`u$$, 
+          Part[$CellContext`c2$$, 1], 
+          Part[$CellContext`c2$$, 2], 
+          Part[$CellContext`c3$$, 1], 
+          Part[$CellContext`c3$$, 2], 5]], StandardForm, Graphics],
+       ImageSizeCache->{{55.9969482421875, 121.5}, {-15.40185546875, -0.5}}], 
+      LocatorBox[Dynamic[$CellContext`c2$$]], 
+      LocatorBox[Dynamic[$CellContext`c3$$]]},
+     PlotRange->3], ",", 
+    GraphicsBox[
+     DynamicBox[Typeset`ToBoxes[
+       Point[
+        Spline`BS4gen[$CellContext`u$$, 
+         Part[$CellContext`c2$$, 1], 
+         Part[$CellContext`c2$$, 2], 
+         Part[$CellContext`c3$$, 1], 
+         Part[$CellContext`c3$$, 2], 5]], StandardForm, Graphics],
+      ImageSizeCache->{{55.9969482421875, 121.5}, {-15.40185546875, -0.5}}],
+     PlotRange->3], ",", 
+    RowBox[{"{", 
+     RowBox[{
+      DynamicBox[ToBoxes[$CellContext`u$$, StandardForm],
+       ImageSizeCache->{25., {1., 9.}}], ",", 
+      DynamicBox[ToBoxes[$CellContext`c2$$, StandardForm],
+       ImageSizeCache->{54.35625, {10.6703125, 18.807499999999997`}}], ",", 
+      DynamicBox[ToBoxes[$CellContext`c3$$, StandardForm],
+       ImageSizeCache->{54.35625, {11.6703125, 18.807499999999997`}}]}], 
+     "}"}]}], "}"}],
+  DynamicModuleValues:>{}]], "Output",
+ CellChangeTimes->{
+  3.7558481929568233`*^9, 3.755848469436883*^9, {3.755848539110973*^9, 
+   3.755848580196279*^9}, 3.755848610809396*^9, 3.7558486418637466`*^9, {
+   3.7558486882883863`*^9, 3.755848701879325*^9}, 3.7558487410985937`*^9, 
+   3.755849532999156*^9, 3.755849785560637*^9, 3.755850959618453*^9, 
+   3.7558510537941732`*^9, 3.755851110918347*^9, 3.75585122417805*^9, 
+   3.75604264170506*^9, 3.756045451619948*^9, 3.7560463503107147`*^9, 
+   3.756046393471244*^9, 3.756046451829566*^9, 3.756046547235259*^9, 
+   3.756047101390596*^9, 3.756047164225634*^9, 3.7560473807989597`*^9, 
+   3.756111472954855*^9, {3.756111530974468*^9, 3.7561115718848352`*^9}, 
+   3.8063032251731606`*^9, 3.807187691574519*^9, 3.809961131756735*^9, {
+   3.8099614780550957`*^9, 3.80996148402265*^9}},
+ CellLabel->"Out[59]=",ExpressionUUID->"e87dd6c5-c2b5-4955-a002-9f6abbae0361"]
+}, Open  ]],
+
+Cell[CellGroupData[{
+
+Cell[BoxData[
+ RowBox[{"DynamicModule", "[", 
+  RowBox[{
+   RowBox[{"{", 
+    RowBox[{"u", ",", 
+     RowBox[{"w", "=", 
+      RowBox[{"2", "/", "4"}]}], ",", 
+     RowBox[{"c3", "=", 
+      RowBox[{"{", 
+       RowBox[{
+        RowBox[{"3", "/", "4"}], ",", 
+        RowBox[{"1", "/", "3"}]}], "}"}]}]}], "}"}], ",", 
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"Slider", "[", 
+      RowBox[{
+       RowBox[{"Dynamic", "[", "u", "]"}], ",", 
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
+     RowBox[{"Slider", "[", 
+      RowBox[{
+       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", "\[IndentingNewLine]", 
+        RowBox[{
+         RowBox[{"Dynamic", "[", 
+          RowBox[{"Point", "[", 
+           RowBox[{"BS4gen2", "[", 
+            RowBox[{"u", ",", "w", ",", 
+             RowBox[{"c3", "[", 
+              RowBox[{"[", "1", "]"}], "]"}], ",", 
+             RowBox[{"c3", "[", 
+              RowBox[{"[", "2", "]"}], "]"}], ",", "5"}], "]"}], "]"}], "]"}],
+          ",", 
+         RowBox[{"Locator", "[", 
+          RowBox[{"Dynamic", "[", "c3", "]"}], "]"}]}], "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", "\[IndentingNewLine]", 
+        RowBox[{"Dynamic", "[", 
+         RowBox[{"Point", "[", 
+          RowBox[{"BS4gen2", "[", 
+           RowBox[{"u", ",", "w", ",", 
+            RowBox[{"c3", "[", 
+             RowBox[{"[", "1", "]"}], "]"}], ",", 
+            RowBox[{"c3", "[", 
+             RowBox[{"[", "2", "]"}], "]"}], ",", "5"}], "]"}], "]"}], "]"}], 
+        "\[IndentingNewLine]", "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
+     RowBox[{"{", 
+      RowBox[{
+       RowBox[{"Dynamic", "[", "u", "]"}], ",", 
+       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
+       RowBox[{"Dynamic", "[", "c3", "]"}]}], "}"}]}], "}"}]}], 
+  "]"}]], "Input",
+ CellChangeTimes->{{3.756046259490569*^9, 3.756046333778741*^9}, {
+  3.7560463694590683`*^9, 3.756046370845158*^9}},
+ CellLabel->"In[60]:=",ExpressionUUID->"13281535-0874-469c-9673-5469dd452985"],
+
+Cell[BoxData[
+ DynamicModuleBox[{$CellContext`u$$ = -5., $CellContext`w$$ = Rational[
+  1, 2], $CellContext`c3$$ = {
+   Rational[3, 4], 
+   Rational[1, 3]}}, 
+  RowBox[{"{", 
+   RowBox[{
+    SliderBox[Dynamic[$CellContext`u$$], {-5, 7}], ",", 
+    SliderBox[Dynamic[$CellContext`w$$], {-5, 7}], ",", 
+    GraphicsBox[{
+      DynamicBox[Typeset`ToBoxes[
+        Point[
+         Spline`BS4gen2[$CellContext`u$$, $CellContext`w$$, 
+          Part[$CellContext`c3$$, 1], 
+          Part[$CellContext`c3$$, 2], 5]], StandardForm, Graphics],
+       ImageSizeCache->{{55.9969482421875, 
+        121.5}, {-10.065638950892858`, -0.5}}], 
+      LocatorBox[Dynamic[$CellContext`c3$$]]},
+     PlotRange->3], ",", 
+    GraphicsBox[
+     DynamicBox[Typeset`ToBoxes[
+       Point[
+        Spline`BS4gen2[$CellContext`u$$, $CellContext`w$$, 
+         Part[$CellContext`c3$$, 1], 
+         Part[$CellContext`c3$$, 2], 5]], StandardForm, Graphics],
+      ImageSizeCache->{{55.9969482421875, 
+       121.5}, {-10.065638950892858`, -0.5}}],
+     PlotRange->3], ",", 
+    RowBox[{"{", 
+     RowBox[{
+      DynamicBox[ToBoxes[$CellContext`u$$, StandardForm],
+       ImageSizeCache->{25., {1., 9.}}], ",", 
+      DynamicBox[ToBoxes[$CellContext`w$$, StandardForm],
+       ImageSizeCache->{
+        12.678125000000001`, {10.6703125, 18.807499999999997`}}], ",", 
+      DynamicBox[ToBoxes[$CellContext`c3$$, StandardForm],
+       ImageSizeCache->{54.35625, {11.6703125, 18.807499999999997`}}]}], 
+     "}"}]}], "}"}],
+  DynamicModuleValues:>{}]], "Output",
+ CellChangeTimes->{{3.756046350491942*^9, 3.75604639381249*^9}, {
+   3.75604644512803*^9, 3.756046452180924*^9}, 3.756046547419788*^9, 
+   3.7560471015596*^9, 3.756047164933318*^9, 3.756047380951084*^9, 
+   3.756111473175436*^9, {3.756111531503964*^9, 3.756111572317801*^9}, 
+   3.806303225249501*^9, 3.807187691832913*^9, 3.809961131856559*^9, {
+   3.8099614781598186`*^9, 3.8099614841302233`*^9}},
+ CellLabel->"Out[60]=",ExpressionUUID->"8a77dd48-38aa-4b21-9f02-b3248e2a098e"]
+}, Open  ]],
+
+Cell[CellGroupData[{
+
+Cell[BoxData[
+ RowBox[{"DynamicModule", "[", 
+  RowBox[{
+   RowBox[{"{", 
+    RowBox[{"u", ",", 
+     RowBox[{"w", "=", 
+      RowBox[{"2", "/", "4"}]}], ",", 
+     RowBox[{"y", "=", 
+      RowBox[{"3", "/", "4"}]}]}], "}"}], ",", 
+   RowBox[{"{", 
+    RowBox[{
+     RowBox[{"Slider", "[", 
+      RowBox[{
+       RowBox[{"Dynamic", "[", "u", "]"}], ",", 
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
+     RowBox[{"Slider", "[", 
+      RowBox[{
+       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
+     RowBox[{"Slider", "[", 
+      RowBox[{
+       RowBox[{"Dynamic", "[", "y", "]"}], ",", 
+       RowBox[{"{", 
+        RowBox[{
+         RowBox[{"-", "5"}], ",", "7"}], "}"}]}], "]"}], ",", 
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", "\[IndentingNewLine]", 
+        RowBox[{"Dynamic", "[", 
+         RowBox[{"Point", "[", 
+          RowBox[{"BS4gen3", "[", 
+           RowBox[{"u", ",", "w", ",", "y", ",", "5"}], "]"}], "]"}], "]"}], 
+        "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
+     RowBox[{"Graphics", "[", 
+      RowBox[{
+       RowBox[{"{", "\[IndentingNewLine]", 
+        RowBox[{"Dynamic", "[", 
+         RowBox[{"Point", "[", 
+          RowBox[{"BS4gen3", "[", 
+           RowBox[{"u", ",", "w", ",", "y", ",", "5"}], "]"}], "]"}], "]"}], 
+        "\[IndentingNewLine]", "}"}], ",", 
+       RowBox[{"PlotRange", "\[Rule]", "3"}]}], "]"}], ",", 
+     RowBox[{"{", 
+      RowBox[{
+       RowBox[{"Dynamic", "[", "u", "]"}], ",", 
+       RowBox[{"Dynamic", "[", "w", "]"}], ",", 
+       RowBox[{"Dynamic", "[", "y", "]"}]}], "}"}]}], "}"}]}], "]"}]], "Input",
+ CellChangeTimes->{{3.7561113658004427`*^9, 3.756111427418873*^9}, {
+  3.756111489670693*^9, 3.75611149321799*^9}},
+ CellLabel->"In[61]:=",ExpressionUUID->"5445dab5-8e96-4d99-9f40-43b620bd846e"],
+
+Cell[BoxData[
+ DynamicModuleBox[{$CellContext`u$$ = -5., $CellContext`w$$ = 
+  2.46, $CellContext`y$$ = Rational[3, 4]}, 
+  RowBox[{"{", 
+   RowBox[{
+    SliderBox[Dynamic[$CellContext`u$$], {-5, 7}], ",", 
+    SliderBox[Dynamic[$CellContext`w$$], {-5, 7}], ",", 
+    SliderBox[Dynamic[$CellContext`y$$], {-5, 7}], ",", 
+    GraphicsBox[
+     DynamicBox[Typeset`ToBoxes[
+       Point[
+        Spline`BS4gen3[$CellContext`u$$, $CellContext`w$$, $CellContext`y$$, 
+         5]], StandardForm, Graphics],
+      ImageSizeCache->{{61.1649169921875, 
+       121.5}, {-10.282047662256108`, -0.5}}],
+     PlotRange->3], ",", 
+    GraphicsBox[
+     DynamicBox[Typeset`ToBoxes[
+       Point[
+        Spline`BS4gen3[$CellContext`u$$, $CellContext`w$$, $CellContext`y$$, 
+         5]], StandardForm, Graphics],
+      ImageSizeCache->{{61.1649169921875, 
+       121.5}, {-10.282047662256108`, -0.5}}],
+     PlotRange->3], ",", 
+    RowBox[{"{", 
+     RowBox[{
+      DynamicBox[ToBoxes[$CellContext`u$$, StandardForm],
+       ImageSizeCache->{25., {1., 9.}}], ",", 
+      DynamicBox[ToBoxes[$CellContext`w$$, StandardForm],
+       ImageSizeCache->{31., {1., 9.}}], ",", 
+      DynamicBox[ToBoxes[$CellContext`y$$, StandardForm],
+       ImageSizeCache->{
+        12.678125000000001`, {10.6703125, 18.807499999999997`}}]}], "}"}]}], 
+   "}"}],
+  DynamicModuleValues:>{}]], "Output",
+ CellChangeTimes->{{3.7561114732924013`*^9, 3.7561114947720623`*^9}, {
+   3.756111531681285*^9, 3.756111572485814*^9}, 3.806303225326223*^9, 
+   3.8071876919987698`*^9, 3.809961131955469*^9, {3.809961478258583*^9, 
+   3.809961484248*^9}},
+ CellLabel->"Out[61]=",ExpressionUUID->"1bb6be5f-476a-462e-b6de-56bb1bbb950f"]
+}, Open  ]]
+},
+WindowSize->{878, 963},
+WindowMargins->{{Automatic, 41}, {0, Automatic}},
+FrontEndVersion->"12.1 for Linux x86 (64-bit) (June 19, 2020)",
+StyleDefinitions->"Default.nb",
+ExpressionUUID->"23da5697-2cb1-4193-afd5-e0470d5c61ee"
+]
+(* End of Notebook Content *)
+
+(* Internal cache information *)
+(*CellTagsOutline
+CellTagsIndex->{}
+*)
+(*CellTagsIndex
+CellTagsIndex->{}
+*)
+(*NotebookFileOutline
+Notebook[{
+Cell[558, 20, 239, 5, 30, "Input",ExpressionUUID->"2e7c28c4-94b6-4f0a-b06a-4128b32d2ac4"],
+Cell[800, 27, 319, 5, 30, "Input",ExpressionUUID->"5778195a-5bf6-4b92-9642-c2f2bd572a9d"],
+Cell[1122, 34, 459, 9, 81, "Text",ExpressionUUID->"6ea8292c-4b09-4e06-a3d1-0027de311060"],
+Cell[CellGroupData[{
+Cell[1606, 47, 5954, 100, 97, "Input",ExpressionUUID->"f2dab5d6-5b18-46f7-969d-ffb46b193fbe"],
+Cell[7563, 149, 1876, 31, 199, "Output",ExpressionUUID->"e6cd772c-5192-41b1-8ba4-384a183c98ce"]
+}, Open  ]],
+Cell[CellGroupData[{
+Cell[9476, 185, 2071, 55, 119, "Input",ExpressionUUID->"06c76740-37fc-423b-9161-58680057b9fc"],
+Cell[11550, 242, 2084, 45, 199, "Output",ExpressionUUID->"fcfe3b42-8d99-4fcd-8c07-3e794b546f06"]
+}, Open  ]],
+Cell[CellGroupData[{
+Cell[13671, 292, 1522, 42, 97, "Input",ExpressionUUID->"7467c43d-5991-4df3-aa93-d696bb7aafee"],
+Cell[15196, 336, 1600, 36, 242, "Output",ExpressionUUID->"6d219e22-0d77-4ef7-92fb-c9cb7bc5975a"]
+}, Open  ]],
+Cell[CellGroupData[{
+Cell[16833, 377, 2969, 75, 119, "Input",ExpressionUUID->"d6cd1c85-8f1b-47eb-8441-d636acd8448f"],
+Cell[19805, 454, 2486, 53, 413, "Output",ExpressionUUID->"e87dd6c5-c2b5-4955-a002-9f6abbae0361"]
+}, Open  ]],
+Cell[CellGroupData[{
+Cell[22328, 512, 2305, 63, 141, "Input",ExpressionUUID->"13281535-0874-469c-9673-5469dd452985"],
+Cell[24636, 577, 2010, 45, 242, "Output",ExpressionUUID->"8a77dd48-38aa-4b21-9f02-b3248e2a098e"]
+}, Open  ]],
+Cell[CellGroupData[{
+Cell[26683, 627, 1973, 54, 141, "Input",ExpressionUUID->"5445dab5-8e96-4d99-9f40-43b620bd846e"],
+Cell[28659, 683, 1684, 39, 265, "Output",ExpressionUUID->"1bb6be5f-476a-462e-b6de-56bb1bbb950f"]
+}, Open  ]]
+}
+]
+*)
+
```

### Comparing `stopeight-0.3.14/doc/run_comparator.txt` & `stopeight-0.3.22/doc/run_comparator.txt`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/sample-data.txt` & `stopeight-0.3.22/doc/sample-data.txt`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 Sample-Data
 -----------
 
 Legacy pen stroke test data can be found in the repository stopeight-clibs. Any arc-wise connected series of 2D points can be loaded. The sample data has been hand-drawn on a Wacom Cintiq 21UX and plain mouse using Symboloh. It is currently the only test-set available.
 
 It has to be extracted from here::
 
-    $ cd /path/to/where/stopeight-clibs/legacy/tests
+    $ cd /path/to/where/stopeight-clibs/legacy/test-data
     $ tar xvfz v0-1-0.tar.gz
 
 Or use the zip file (v0-1-0.zip) instead.
 
 Pen-Stroke and Vector Graph data in the new format is automatically generated in the ~/.stopeight directory if a editor algorithm fails. It can also be saved from the editor menu.
```

### Comparing `stopeight-0.3.14/doc/stopeight.txt` & `stopeight-0.3.22/doc/stopeight.txt`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/theory.txt` & `stopeight-0.3.22/doc/theory.txt`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/doc/vector-graph.txt` & `stopeight-0.3.22/doc/vector-graph.txt`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/attr.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/attr.h`

 * *Files 12% similar despite different names*

```diff
@@ -6,76 +6,121 @@
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
+#include "detail/common.h"
 #include "cast.h"
 
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+#include <functional>
+
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 /// \addtogroup annotations
 /// @{
 
 /// Annotation for methods
-struct is_method { handle class_; is_method(const handle &c) : class_(c) { } };
+struct is_method {
+    handle class_;
+    explicit is_method(const handle &c) : class_(c) {}
+};
 
 /// Annotation for operators
-struct is_operator { };
+struct is_operator {};
 
 /// Annotation for classes that cannot be subclassed
-struct is_final { };
+struct is_final {};
 
 /// Annotation for parent scope
-struct scope { handle value; scope(const handle &s) : value(s) { } };
+struct scope {
+    handle value;
+    explicit scope(const handle &s) : value(s) {}
+};
 
 /// Annotation for documentation
-struct doc { const char *value; doc(const char *value) : value(value) { } };
+struct doc {
+    const char *value;
+    explicit doc(const char *value) : value(value) {}
+};
 
 /// Annotation for function names
-struct name { const char *value; name(const char *value) : value(value) { } };
+struct name {
+    const char *value;
+    explicit name(const char *value) : value(value) {}
+};
 
 /// Annotation indicating that a function is an overload associated with a given "sibling"
-struct sibling { handle value; sibling(const handle &value) : value(value.ptr()) { } };
+struct sibling {
+    handle value;
+    explicit sibling(const handle &value) : value(value.ptr()) {}
+};
 
 /// Annotation indicating that a class derives from another given type
-template <typename T> struct base {
-    PYBIND11_DEPRECATED("base<T>() was deprecated in favor of specifying 'T' as a template argument to class_")
-    base() { }
+template <typename T>
+struct base {
+
+    PYBIND11_DEPRECATED(
+        "base<T>() was deprecated in favor of specifying 'T' as a template argument to class_")
+    base() = default;
 };
 
 /// Keep patient alive while nurse lives
-template <size_t Nurse, size_t Patient> struct keep_alive { };
+template <size_t Nurse, size_t Patient>
+struct keep_alive {};
 
 /// Annotation indicating that a class is involved in a multiple inheritance relationship
-struct multiple_inheritance { };
+struct multiple_inheritance {};
 
 /// Annotation which enables dynamic attributes, i.e. adds `__dict__` to a class
-struct dynamic_attr { };
+struct dynamic_attr {};
 
 /// Annotation which enables the buffer protocol for a type
-struct buffer_protocol { };
+struct buffer_protocol {};
 
 /// Annotation which requests that a special metaclass is created for a type
 struct metaclass {
     handle value;
 
     PYBIND11_DEPRECATED("py::metaclass() is no longer required. It's turned on by default now.")
-    metaclass() {}
+    metaclass() = default;
 
     /// Override pybind11's default metaclass
-    explicit metaclass(handle value) : value(value) { }
+    explicit metaclass(handle value) : value(value) {}
+};
+
+/// Specifies a custom callback with signature `void (PyHeapTypeObject*)` that
+/// may be used to customize the Python type.
+///
+/// The callback is invoked immediately before `PyType_Ready`.
+///
+/// Note: This is an advanced interface, and uses of it may require changes to
+/// work with later versions of pybind11.  You may wish to consult the
+/// implementation of `make_new_python_type` in `detail/classes.h` to understand
+/// the context in which the callback will be run.
+struct custom_type_setup {
+    using callback = std::function<void(PyHeapTypeObject *heap_type)>;
+
+    explicit custom_type_setup(callback value) : value(std::move(value)) {}
+
+    callback value;
 };
 
 /// Annotation that marks a class as local to the module:
-struct module_local { const bool value; constexpr module_local(bool v = true) : value(v) { } };
+struct module_local {
+    const bool value;
+    constexpr explicit module_local(bool v = true) : value(v) {}
+};
 
 /// Annotation to mark enums as an arithmetic type
-struct arithmetic { };
+struct arithmetic {};
+
+/// Mark a function for addition at the beginning of the existing overload chain instead of the end
+struct prepend {};
 
 /** \rst
     A call policy which places one or more guard variables (``Ts...``) around the function call.
 
     For example, this definition:
 
     .. code-block:: cpp
@@ -87,17 +132,21 @@
     .. code-block:: cpp
 
         m.def("foo", [](args...) {
             T scope_guard;
             return foo(args...); // forwarded arguments
         });
  \endrst */
-template <typename... Ts> struct call_guard;
+template <typename... Ts>
+struct call_guard;
 
-template <> struct call_guard<> { using type = detail::void_type; };
+template <>
+struct call_guard<> {
+    using type = detail::void_type;
+};
 
 template <typename T>
 struct call_guard<T> {
     static_assert(std::is_default_constructible<T>::value,
                   "The guard type must be default constructible");
 
     using type = T;
@@ -109,61 +158,63 @@
         T guard{}; // Compose multiple guard types with left-to-right default-constructor order
         typename call_guard<Ts...>::type next{};
     };
 };
 
 /// @} annotations
 
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(detail)
 /* Forward declarations */
 enum op_id : int;
 enum op_type : int;
 struct undefined_t;
-template <op_id id, op_type ot, typename L = undefined_t, typename R = undefined_t> struct op_;
-inline void keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret);
+template <op_id id, op_type ot, typename L = undefined_t, typename R = undefined_t>
+struct op_;
+void keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret);
 
 /// Internal data structure which holds metadata about a keyword argument
 struct argument_record {
     const char *name;  ///< Argument name
     const char *descr; ///< Human-readable version of the argument value
     handle value;      ///< Associated Python object
     bool convert : 1;  ///< True if the argument is allowed to convert when loading
     bool none : 1;     ///< True if None is allowed when loading
 
     argument_record(const char *name, const char *descr, handle value, bool convert, bool none)
-        : name(name), descr(descr), value(value), convert(convert), none(none) { }
+        : name(name), descr(descr), value(value), convert(convert), none(none) {}
 };
 
-/// Internal data structure which holds metadata about a bound function (signature, overloads, etc.)
+/// Internal data structure which holds metadata about a bound function (signature, overloads,
+/// etc.)
 struct function_record {
     function_record()
         : is_constructor(false), is_new_style_constructor(false), is_stateless(false),
-          is_operator(false), is_method(false),
-          has_args(false), has_kwargs(false), has_kwonly_args(false) { }
+          is_operator(false), is_method(false), has_args(false), has_kwargs(false),
+          prepend(false) {}
 
     /// Function name
     char *name = nullptr; /* why no C++ strings? They generate heavier code.. */
 
     // User-specified documentation string
     char *doc = nullptr;
 
     /// Human-readable version of the function signature
     char *signature = nullptr;
 
     /// List of registered keyword arguments
     std::vector<argument_record> args;
 
     /// Pointer to lambda function which converts arguments and performs the actual call
-    handle (*impl) (function_call &) = nullptr;
+    handle (*impl)(function_call &) = nullptr;
 
     /// Storage for the wrapped function pointer and captured data, if any
-    void *data[3] = { };
+    void *data[3] = {};
 
     /// Pointer to custom destructor for 'data' (if needed)
-    void (*free_data) (function_record *ptr) = nullptr;
+    void (*free_data)(function_record *ptr) = nullptr;
 
     /// Return value policy associated with this function
     return_value_policy policy = return_value_policy::automatic;
 
     /// True if name == '__init__'
     bool is_constructor : 1;
 
@@ -181,22 +232,26 @@
 
     /// True if the function has a '*args' argument
     bool has_args : 1;
 
     /// True if the function has a '**kwargs' argument
     bool has_kwargs : 1;
 
-    /// True once a 'py::kwonly' is encountered (any following args are keyword-only)
-    bool has_kwonly_args : 1;
+    /// True if this function is to be inserted at the beginning of the overload resolution chain
+    bool prepend : 1;
 
     /// Number of arguments (including py::args and/or py::kwargs, if present)
     std::uint16_t nargs;
 
-    /// Number of trailing arguments (counted in `nargs`) that are keyword-only
-    std::uint16_t nargs_kwonly = 0;
+    /// Number of leading positional arguments, which are terminated by a py::args or py::kwargs
+    /// argument or by a py::kw_only annotation.
+    std::uint16_t nargs_pos = 0;
+
+    /// Number of leading arguments (counted in `nargs`) that are positional-only
+    std::uint16_t nargs_pos_only = 0;
 
     /// Python method object
     PyMethodDef *def = nullptr;
 
     /// Python handle to the parent scope (a class or a module)
     handle scope;
 
@@ -207,15 +262,15 @@
     function_record *next = nullptr;
 };
 
 /// Special data structure which (temporarily) holds metadata about a bound class
 struct type_record {
     PYBIND11_NOINLINE type_record()
         : multiple_inheritance(false), dynamic_attr(false), buffer_protocol(false),
-          default_holder(true), module_local(false), is_final(false) { }
+          default_holder(true), module_local(false), is_final(false) {}
 
     /// Handle to the parent scope
     handle scope;
 
     /// Name of the class
     const char *name = nullptr;
 
@@ -245,14 +300,17 @@
 
     /// Optional docstring
     const char *doc = nullptr;
 
     /// Custom metaclass (optional)
     handle metaclass;
 
+    /// Custom type setup.
+    custom_type_setup::callback custom_type_setup_callback;
+
     /// Multiple inheritance marker
     bool multiple_inheritance : 1;
 
     /// Does the class manage a __dict__?
     bool dynamic_attr : 1;
 
     /// Does the class implement the buffer protocol?
@@ -263,194 +321,261 @@
 
     /// Is the class definition local to the module shared object?
     bool module_local : 1;
 
     /// Is the class inheritable from python classes?
     bool is_final : 1;
 
-    PYBIND11_NOINLINE void add_base(const std::type_info &base, void *(*caster)(void *)) {
-        auto base_info = detail::get_type_info(base, false);
+    PYBIND11_NOINLINE void add_base(const std::type_info &base, void *(*caster)(void *) ) {
+        auto *base_info = detail::get_type_info(base, false);
         if (!base_info) {
             std::string tname(base.name());
             detail::clean_type_id(tname);
-            pybind11_fail("generic_type: type \"" + std::string(name) +
-                          "\" referenced unknown base type \"" + tname + "\"");
+            pybind11_fail("generic_type: type \"" + std::string(name)
+                          + "\" referenced unknown base type \"" + tname + "\"");
         }
 
         if (default_holder != base_info->default_holder) {
             std::string tname(base.name());
             detail::clean_type_id(tname);
-            pybind11_fail("generic_type: type \"" + std::string(name) + "\" " +
-                    (default_holder ? "does not have" : "has") +
-                    " a non-default holder type while its base \"" + tname + "\" " +
-                    (base_info->default_holder ? "does not" : "does"));
+            pybind11_fail("generic_type: type \"" + std::string(name) + "\" "
+                          + (default_holder ? "does not have" : "has")
+                          + " a non-default holder type while its base \"" + tname + "\" "
+                          + (base_info->default_holder ? "does not" : "does"));
         }
 
         bases.append((PyObject *) base_info->type);
 
-        if (base_info->type->tp_dictoffset != 0)
-            dynamic_attr = true;
+#if PY_VERSION_HEX < 0x030B0000
+        dynamic_attr |= base_info->type->tp_dictoffset != 0;
+#else
+        dynamic_attr |= (base_info->type->tp_flags & Py_TPFLAGS_MANAGED_DICT) != 0;
+#endif
 
-        if (caster)
+        if (caster) {
             base_info->implicit_casts.emplace_back(type, caster);
+        }
     }
 };
 
-inline function_call::function_call(const function_record &f, handle p) :
-        func(f), parent(p) {
+inline function_call::function_call(const function_record &f, handle p) : func(f), parent(p) {
     args.reserve(f.nargs);
     args_convert.reserve(f.nargs);
 }
 
 /// Tag for a new-style `__init__` defined in `detail/init.h`
-struct is_new_style_constructor { };
+struct is_new_style_constructor {};
 
 /**
  * Partial template specializations to process custom attributes provided to
  * cpp_function_ and class_. These are either used to initialize the respective
  * fields in the type_record and function_record data structures or executed at
  * runtime to deal with custom call policies (e.g. keep_alive).
  */
-template <typename T, typename SFINAE = void> struct process_attribute;
+template <typename T, typename SFINAE = void>
+struct process_attribute;
 
-template <typename T> struct process_attribute_default {
+template <typename T>
+struct process_attribute_default {
     /// Default implementation: do nothing
-    static void init(const T &, function_record *) { }
-    static void init(const T &, type_record *) { }
-    static void precall(function_call &) { }
-    static void postcall(function_call &, handle) { }
+    static void init(const T &, function_record *) {}
+    static void init(const T &, type_record *) {}
+    static void precall(function_call &) {}
+    static void postcall(function_call &, handle) {}
 };
 
 /// Process an attribute specifying the function's name
-template <> struct process_attribute<name> : process_attribute_default<name> {
+template <>
+struct process_attribute<name> : process_attribute_default<name> {
     static void init(const name &n, function_record *r) { r->name = const_cast<char *>(n.value); }
 };
 
 /// Process an attribute specifying the function's docstring
-template <> struct process_attribute<doc> : process_attribute_default<doc> {
+template <>
+struct process_attribute<doc> : process_attribute_default<doc> {
     static void init(const doc &n, function_record *r) { r->doc = const_cast<char *>(n.value); }
 };
 
 /// Process an attribute specifying the function's docstring (provided as a C-style string)
-template <> struct process_attribute<const char *> : process_attribute_default<const char *> {
+template <>
+struct process_attribute<const char *> : process_attribute_default<const char *> {
     static void init(const char *d, function_record *r) { r->doc = const_cast<char *>(d); }
-    static void init(const char *d, type_record *r) { r->doc = const_cast<char *>(d); }
+    static void init(const char *d, type_record *r) { r->doc = d; }
 };
-template <> struct process_attribute<char *> : process_attribute<const char *> { };
+template <>
+struct process_attribute<char *> : process_attribute<const char *> {};
 
 /// Process an attribute indicating the function's return value policy
-template <> struct process_attribute<return_value_policy> : process_attribute_default<return_value_policy> {
+template <>
+struct process_attribute<return_value_policy> : process_attribute_default<return_value_policy> {
     static void init(const return_value_policy &p, function_record *r) { r->policy = p; }
 };
 
-/// Process an attribute which indicates that this is an overloaded function associated with a given sibling
-template <> struct process_attribute<sibling> : process_attribute_default<sibling> {
+/// Process an attribute which indicates that this is an overloaded function associated with a
+/// given sibling
+template <>
+struct process_attribute<sibling> : process_attribute_default<sibling> {
     static void init(const sibling &s, function_record *r) { r->sibling = s.value; }
 };
 
 /// Process an attribute which indicates that this function is a method
-template <> struct process_attribute<is_method> : process_attribute_default<is_method> {
-    static void init(const is_method &s, function_record *r) { r->is_method = true; r->scope = s.class_; }
+template <>
+struct process_attribute<is_method> : process_attribute_default<is_method> {
+    static void init(const is_method &s, function_record *r) {
+        r->is_method = true;
+        r->scope = s.class_;
+    }
 };
 
 /// Process an attribute which indicates the parent scope of a method
-template <> struct process_attribute<scope> : process_attribute_default<scope> {
+template <>
+struct process_attribute<scope> : process_attribute_default<scope> {
     static void init(const scope &s, function_record *r) { r->scope = s.value; }
 };
 
 /// Process an attribute which indicates that this function is an operator
-template <> struct process_attribute<is_operator> : process_attribute_default<is_operator> {
+template <>
+struct process_attribute<is_operator> : process_attribute_default<is_operator> {
     static void init(const is_operator &, function_record *r) { r->is_operator = true; }
 };
 
-template <> struct process_attribute<is_new_style_constructor> : process_attribute_default<is_new_style_constructor> {
-    static void init(const is_new_style_constructor &, function_record *r) { r->is_new_style_constructor = true; }
+template <>
+struct process_attribute<is_new_style_constructor>
+    : process_attribute_default<is_new_style_constructor> {
+    static void init(const is_new_style_constructor &, function_record *r) {
+        r->is_new_style_constructor = true;
+    }
 };
 
-inline void process_kwonly_arg(const arg &a, function_record *r) {
-    if (!a.name || strlen(a.name) == 0)
-        pybind11_fail("arg(): cannot specify an unnamed argument after an kwonly() annotation");
-    ++r->nargs_kwonly;
+inline void check_kw_only_arg(const arg &a, function_record *r) {
+    if (r->args.size() > r->nargs_pos && (!a.name || a.name[0] == '\0')) {
+        pybind11_fail("arg(): cannot specify an unnamed argument after a kw_only() annotation or "
+                      "args() argument");
+    }
+}
+
+inline void append_self_arg_if_needed(function_record *r) {
+    if (r->is_method && r->args.empty()) {
+        r->args.emplace_back("self", nullptr, handle(), /*convert=*/true, /*none=*/false);
+    }
 }
 
 /// Process a keyword argument attribute (*without* a default value)
-template <> struct process_attribute<arg> : process_attribute_default<arg> {
+template <>
+struct process_attribute<arg> : process_attribute_default<arg> {
     static void init(const arg &a, function_record *r) {
-        if (r->is_method && r->args.empty())
-            r->args.emplace_back("self", nullptr, handle(), true /*convert*/, false /*none not allowed*/);
+        append_self_arg_if_needed(r);
         r->args.emplace_back(a.name, nullptr, handle(), !a.flag_noconvert, a.flag_none);
 
-        if (r->has_kwonly_args) process_kwonly_arg(a, r);
+        check_kw_only_arg(a, r);
     }
 };
 
 /// Process a keyword argument attribute (*with* a default value)
-template <> struct process_attribute<arg_v> : process_attribute_default<arg_v> {
+template <>
+struct process_attribute<arg_v> : process_attribute_default<arg_v> {
     static void init(const arg_v &a, function_record *r) {
-        if (r->is_method && r->args.empty())
-            r->args.emplace_back("self", nullptr /*descr*/, handle() /*parent*/, true /*convert*/, false /*none not allowed*/);
+        if (r->is_method && r->args.empty()) {
+            r->args.emplace_back(
+                "self", /*descr=*/nullptr, /*parent=*/handle(), /*convert=*/true, /*none=*/false);
+        }
 
         if (!a.value) {
-#if !defined(NDEBUG)
+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)
             std::string descr("'");
-            if (a.name) descr += std::string(a.name) + ": ";
+            if (a.name) {
+                descr += std::string(a.name) + ": ";
+            }
             descr += a.type + "'";
             if (r->is_method) {
-                if (r->name)
-                    descr += " in method '" + (std::string) str(r->scope) + "." + (std::string) r->name + "'";
-                else
+                if (r->name) {
+                    descr += " in method '" + (std::string) str(r->scope) + "."
+                             + (std::string) r->name + "'";
+                } else {
                     descr += " in method of '" + (std::string) str(r->scope) + "'";
+                }
             } else if (r->name) {
                 descr += " in function '" + (std::string) r->name + "'";
             }
-            pybind11_fail("arg(): could not convert default argument "
-                          + descr + " into a Python object (type not registered yet?)");
+            pybind11_fail("arg(): could not convert default argument " + descr
+                          + " into a Python object (type not registered yet?)");
 #else
             pybind11_fail("arg(): could not convert default argument "
                           "into a Python object (type not registered yet?). "
-                          "Compile in debug mode for more information.");
+                          "#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for "
+                          "more information.");
 #endif
         }
         r->args.emplace_back(a.name, a.descr, a.value.inc_ref(), !a.flag_noconvert, a.flag_none);
 
-        if (r->has_kwonly_args) process_kwonly_arg(a, r);
+        check_kw_only_arg(a, r);
     }
 };
 
 /// Process a keyword-only-arguments-follow pseudo argument
-template <> struct process_attribute<kwonly> : process_attribute_default<kwonly> {
-    static void init(const kwonly &, function_record *r) {
-        r->has_kwonly_args = true;
+template <>
+struct process_attribute<kw_only> : process_attribute_default<kw_only> {
+    static void init(const kw_only &, function_record *r) {
+        append_self_arg_if_needed(r);
+        if (r->has_args && r->nargs_pos != static_cast<std::uint16_t>(r->args.size())) {
+            pybind11_fail("Mismatched args() and kw_only(): they must occur at the same relative "
+                          "argument location (or omit kw_only() entirely)");
+        }
+        r->nargs_pos = static_cast<std::uint16_t>(r->args.size());
+    }
+};
+
+/// Process a positional-only-argument maker
+template <>
+struct process_attribute<pos_only> : process_attribute_default<pos_only> {
+    static void init(const pos_only &, function_record *r) {
+        append_self_arg_if_needed(r);
+        r->nargs_pos_only = static_cast<std::uint16_t>(r->args.size());
+        if (r->nargs_pos_only > r->nargs_pos) {
+            pybind11_fail("pos_only(): cannot follow a py::args() argument");
+        }
+        // It also can't follow a kw_only, but a static_assert in pybind11.h checks that
     }
 };
 
-/// Process a parent class attribute.  Single inheritance only (class_ itself already guarantees that)
+/// Process a parent class attribute.  Single inheritance only (class_ itself already guarantees
+/// that)
 template <typename T>
-struct process_attribute<T, enable_if_t<is_pyobject<T>::value>> : process_attribute_default<handle> {
+struct process_attribute<T, enable_if_t<is_pyobject<T>::value>>
+    : process_attribute_default<handle> {
     static void init(const handle &h, type_record *r) { r->bases.append(h); }
 };
 
 /// Process a parent class attribute (deprecated, does not support multiple inheritance)
 template <typename T>
 struct process_attribute<base<T>> : process_attribute_default<base<T>> {
     static void init(const base<T> &, type_record *r) { r->add_base(typeid(T), nullptr); }
 };
 
 /// Process a multiple inheritance attribute
 template <>
 struct process_attribute<multiple_inheritance> : process_attribute_default<multiple_inheritance> {
-    static void init(const multiple_inheritance &, type_record *r) { r->multiple_inheritance = true; }
+    static void init(const multiple_inheritance &, type_record *r) {
+        r->multiple_inheritance = true;
+    }
 };
 
 template <>
 struct process_attribute<dynamic_attr> : process_attribute_default<dynamic_attr> {
     static void init(const dynamic_attr &, type_record *r) { r->dynamic_attr = true; }
 };
 
 template <>
+struct process_attribute<custom_type_setup> {
+    static void init(const custom_type_setup &value, type_record *r) {
+        r->custom_type_setup_callback = value.value;
+    }
+};
+
+template <>
 struct process_attribute<is_final> : process_attribute_default<is_final> {
     static void init(const is_final &, type_record *r) { r->is_final = true; }
 };
 
 template <>
 struct process_attribute<buffer_protocol> : process_attribute_default<buffer_protocol> {
     static void init(const buffer_protocol &, type_record *r) { r->buffer_protocol = true; }
@@ -462,67 +587,92 @@
 };
 
 template <>
 struct process_attribute<module_local> : process_attribute_default<module_local> {
     static void init(const module_local &l, type_record *r) { r->module_local = l.value; }
 };
 
+/// Process a 'prepend' attribute, putting this at the beginning of the overload chain
+template <>
+struct process_attribute<prepend> : process_attribute_default<prepend> {
+    static void init(const prepend &, function_record *r) { r->prepend = true; }
+};
+
 /// Process an 'arithmetic' attribute for enums (does nothing here)
 template <>
 struct process_attribute<arithmetic> : process_attribute_default<arithmetic> {};
 
 template <typename... Ts>
-struct process_attribute<call_guard<Ts...>> : process_attribute_default<call_guard<Ts...>> { };
+struct process_attribute<call_guard<Ts...>> : process_attribute_default<call_guard<Ts...>> {};
 
 /**
  * Process a keep_alive call policy -- invokes keep_alive_impl during the
  * pre-call handler if both Nurse, Patient != 0 and use the post-call handler
  * otherwise
  */
-template <size_t Nurse, size_t Patient> struct process_attribute<keep_alive<Nurse, Patient>> : public process_attribute_default<keep_alive<Nurse, Patient>> {
+template <size_t Nurse, size_t Patient>
+struct process_attribute<keep_alive<Nurse, Patient>>
+    : public process_attribute_default<keep_alive<Nurse, Patient>> {
     template <size_t N = Nurse, size_t P = Patient, enable_if_t<N != 0 && P != 0, int> = 0>
-    static void precall(function_call &call) { keep_alive_impl(Nurse, Patient, call, handle()); }
+    static void precall(function_call &call) {
+        keep_alive_impl(Nurse, Patient, call, handle());
+    }
     template <size_t N = Nurse, size_t P = Patient, enable_if_t<N != 0 && P != 0, int> = 0>
-    static void postcall(function_call &, handle) { }
+    static void postcall(function_call &, handle) {}
     template <size_t N = Nurse, size_t P = Patient, enable_if_t<N == 0 || P == 0, int> = 0>
-    static void precall(function_call &) { }
+    static void precall(function_call &) {}
     template <size_t N = Nurse, size_t P = Patient, enable_if_t<N == 0 || P == 0, int> = 0>
-    static void postcall(function_call &call, handle ret) { keep_alive_impl(Nurse, Patient, call, ret); }
+    static void postcall(function_call &call, handle ret) {
+        keep_alive_impl(Nurse, Patient, call, ret);
+    }
 };
 
 /// Recursively iterate over variadic template arguments
-template <typename... Args> struct process_attributes {
-    static void init(const Args&... args, function_record *r) {
-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::init(args, r), 0) ... };
-        ignore_unused(unused);
-    }
-    static void init(const Args&... args, type_record *r) {
-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::init(args, r), 0) ... };
-        ignore_unused(unused);
+template <typename... Args>
+struct process_attributes {
+    static void init(const Args &...args, function_record *r) {
+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(r);
+        PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(r);
+        using expander = int[];
+        (void) expander{
+            0, ((void) process_attribute<typename std::decay<Args>::type>::init(args, r), 0)...};
+    }
+    static void init(const Args &...args, type_record *r) {
+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(r);
+        PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(r);
+        using expander = int[];
+        (void) expander{0,
+                        (process_attribute<typename std::decay<Args>::type>::init(args, r), 0)...};
     }
     static void precall(function_call &call) {
-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::precall(call), 0) ... };
-        ignore_unused(unused);
+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(call);
+        using expander = int[];
+        (void) expander{0,
+                        (process_attribute<typename std::decay<Args>::type>::precall(call), 0)...};
     }
     static void postcall(function_call &call, handle fn_ret) {
-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::postcall(call, fn_ret), 0) ... };
-        ignore_unused(unused);
+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(call, fn_ret);
+        PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(fn_ret);
+        using expander = int[];
+        (void) expander{
+            0, (process_attribute<typename std::decay<Args>::type>::postcall(call, fn_ret), 0)...};
     }
 };
 
 template <typename T>
 using is_call_guard = is_instantiation<call_guard, T>;
 
 /// Extract the ``type`` from the first `call_guard` in `Extras...` (or `void_type` if none found)
 template <typename... Extra>
 using extract_guard_t = typename exactly_one_t<is_call_guard, call_guard<>, Extra...>::type;
 
 /// Check the number of named arguments at compile time
 template <typename... Extra,
           size_t named = constexpr_sum(std::is_base_of<arg, Extra>::value...),
-          size_t self  = constexpr_sum(std::is_same<is_method, Extra>::value...)>
+          size_t self = constexpr_sum(std::is_same<is_method, Extra>::value...)>
 constexpr bool expected_num_args(size_t nargs, bool has_args, bool has_kwargs) {
-    return named == 0 || (self + named + has_args + has_kwargs) == nargs;
+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(nargs, has_args, has_kwargs);
+    return named == 0 || (self + named + size_t(has_args) + size_t(has_kwargs)) == nargs;
 }
 
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/buffer_info.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/buffer_info.h`

 * *Files 22% similar despite different names*

```diff
@@ -7,108 +7,187 @@
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "detail/common.h"
 
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+
+PYBIND11_NAMESPACE_BEGIN(detail)
+
+// Default, C-style strides
+inline std::vector<ssize_t> c_strides(const std::vector<ssize_t> &shape, ssize_t itemsize) {
+    auto ndim = shape.size();
+    std::vector<ssize_t> strides(ndim, itemsize);
+    if (ndim > 0) {
+        for (size_t i = ndim - 1; i > 0; --i) {
+            strides[i - 1] = strides[i] * shape[i];
+        }
+    }
+    return strides;
+}
+
+// F-style strides; default when constructing an array_t with `ExtraFlags & f_style`
+inline std::vector<ssize_t> f_strides(const std::vector<ssize_t> &shape, ssize_t itemsize) {
+    auto ndim = shape.size();
+    std::vector<ssize_t> strides(ndim, itemsize);
+    for (size_t i = 1; i < ndim; ++i) {
+        strides[i] = strides[i - 1] * shape[i - 1];
+    }
+    return strides;
+}
+
+PYBIND11_NAMESPACE_END(detail)
 
 /// Information record describing a Python buffer object
 struct buffer_info {
     void *ptr = nullptr;          // Pointer to the underlying storage
     ssize_t itemsize = 0;         // Size of individual items in bytes
     ssize_t size = 0;             // Total number of entries
-    std::string format;           // For homogeneous buffers, this should be set to format_descriptor<T>::format()
+    std::string format;           // For homogeneous buffers, this should be set to
+                                  // format_descriptor<T>::format()
     ssize_t ndim = 0;             // Number of dimensions
     std::vector<ssize_t> shape;   // Shape of the tensor (1 entry per dimension)
-    std::vector<ssize_t> strides; // Number of bytes between adjacent entries (for each per dimension)
+    std::vector<ssize_t> strides; // Number of bytes between adjacent entries
+                                  // (for each per dimension)
     bool readonly = false;        // flag to indicate if the underlying storage may be written to
 
-    buffer_info() { }
+    buffer_info() = default;
 
-    buffer_info(void *ptr, ssize_t itemsize, const std::string &format, ssize_t ndim,
-                detail::any_container<ssize_t> shape_in, detail::any_container<ssize_t> strides_in, bool readonly=false)
-    : ptr(ptr), itemsize(itemsize), size(1), format(format), ndim(ndim),
-      shape(std::move(shape_in)), strides(std::move(strides_in)), readonly(readonly) {
-        if (ndim != (ssize_t) shape.size() || ndim != (ssize_t) strides.size())
+    buffer_info(void *ptr,
+                ssize_t itemsize,
+                const std::string &format,
+                ssize_t ndim,
+                detail::any_container<ssize_t> shape_in,
+                detail::any_container<ssize_t> strides_in,
+                bool readonly = false)
+        : ptr(ptr), itemsize(itemsize), size(1), format(format), ndim(ndim),
+          shape(std::move(shape_in)), strides(std::move(strides_in)), readonly(readonly) {
+        if (ndim != (ssize_t) shape.size() || ndim != (ssize_t) strides.size()) {
             pybind11_fail("buffer_info: ndim doesn't match shape and/or strides length");
-        for (size_t i = 0; i < (size_t) ndim; ++i)
+        }
+        for (size_t i = 0; i < (size_t) ndim; ++i) {
             size *= shape[i];
+        }
     }
 
     template <typename T>
-    buffer_info(T *ptr, detail::any_container<ssize_t> shape_in, detail::any_container<ssize_t> strides_in, bool readonly=false)
-    : buffer_info(private_ctr_tag(), ptr, sizeof(T), format_descriptor<T>::format(), static_cast<ssize_t>(shape_in->size()), std::move(shape_in), std::move(strides_in), readonly) { }
-
-    buffer_info(void *ptr, ssize_t itemsize, const std::string &format, ssize_t size, bool readonly=false)
-    : buffer_info(ptr, itemsize, format, 1, {size}, {itemsize}, readonly) { }
+    buffer_info(T *ptr,
+                detail::any_container<ssize_t> shape_in,
+                detail::any_container<ssize_t> strides_in,
+                bool readonly = false)
+        : buffer_info(private_ctr_tag(),
+                      ptr,
+                      sizeof(T),
+                      format_descriptor<T>::format(),
+                      static_cast<ssize_t>(shape_in->size()),
+                      std::move(shape_in),
+                      std::move(strides_in),
+                      readonly) {}
+
+    buffer_info(void *ptr,
+                ssize_t itemsize,
+                const std::string &format,
+                ssize_t size,
+                bool readonly = false)
+        : buffer_info(ptr, itemsize, format, 1, {size}, {itemsize}, readonly) {}
 
     template <typename T>
-    buffer_info(T *ptr, ssize_t size, bool readonly=false)
-    : buffer_info(ptr, sizeof(T), format_descriptor<T>::format(), size, readonly) { }
+    buffer_info(T *ptr, ssize_t size, bool readonly = false)
+        : buffer_info(ptr, sizeof(T), format_descriptor<T>::format(), size, readonly) {}
 
     template <typename T>
-    buffer_info(const T *ptr, ssize_t size, bool readonly=true)
-    : buffer_info(const_cast<T*>(ptr), sizeof(T), format_descriptor<T>::format(), size, readonly) { }
+    buffer_info(const T *ptr, ssize_t size, bool readonly = true)
+        : buffer_info(
+            const_cast<T *>(ptr), sizeof(T), format_descriptor<T>::format(), size, readonly) {}
 
     explicit buffer_info(Py_buffer *view, bool ownview = true)
-    : buffer_info(view->buf, view->itemsize, view->format, view->ndim,
-            {view->shape, view->shape + view->ndim}, {view->strides, view->strides + view->ndim}, view->readonly) {
-        this->view = view;
+        : buffer_info(
+            view->buf,
+            view->itemsize,
+            view->format,
+            view->ndim,
+            {view->shape, view->shape + view->ndim},
+            /* Though buffer::request() requests PyBUF_STRIDES, ctypes objects
+             * ignore this flag and return a view with NULL strides.
+             * When strides are NULL, build them manually.  */
+            view->strides
+                ? std::vector<ssize_t>(view->strides, view->strides + view->ndim)
+                : detail::c_strides({view->shape, view->shape + view->ndim}, view->itemsize),
+            (view->readonly != 0)) {
+        // NOLINTNEXTLINE(cppcoreguidelines-prefer-member-initializer)
+        this->m_view = view;
+        // NOLINTNEXTLINE(cppcoreguidelines-prefer-member-initializer)
         this->ownview = ownview;
     }
 
     buffer_info(const buffer_info &) = delete;
-    buffer_info& operator=(const buffer_info &) = delete;
+    buffer_info &operator=(const buffer_info &) = delete;
 
-    buffer_info(buffer_info &&other) {
-        (*this) = std::move(other);
-    }
+    buffer_info(buffer_info &&other) noexcept { (*this) = std::move(other); }
 
-    buffer_info& operator=(buffer_info &&rhs) {
+    buffer_info &operator=(buffer_info &&rhs) noexcept {
         ptr = rhs.ptr;
         itemsize = rhs.itemsize;
         size = rhs.size;
         format = std::move(rhs.format);
         ndim = rhs.ndim;
         shape = std::move(rhs.shape);
         strides = std::move(rhs.strides);
-        std::swap(view, rhs.view);
+        std::swap(m_view, rhs.m_view);
         std::swap(ownview, rhs.ownview);
         readonly = rhs.readonly;
         return *this;
     }
 
     ~buffer_info() {
-        if (view && ownview) { PyBuffer_Release(view); delete view; }
+        if (m_view && ownview) {
+            PyBuffer_Release(m_view);
+            delete m_view;
+        }
     }
 
+    Py_buffer *view() const { return m_view; }
+    Py_buffer *&view() { return m_view; }
+
 private:
-    struct private_ctr_tag { };
+    struct private_ctr_tag {};
 
-    buffer_info(private_ctr_tag, void *ptr, ssize_t itemsize, const std::string &format, ssize_t ndim,
-                detail::any_container<ssize_t> &&shape_in, detail::any_container<ssize_t> &&strides_in, bool readonly)
-    : buffer_info(ptr, itemsize, format, ndim, std::move(shape_in), std::move(strides_in), readonly) { }
+    buffer_info(private_ctr_tag,
+                void *ptr,
+                ssize_t itemsize,
+                const std::string &format,
+                ssize_t ndim,
+                detail::any_container<ssize_t> &&shape_in,
+                detail::any_container<ssize_t> &&strides_in,
+                bool readonly)
+        : buffer_info(
+            ptr, itemsize, format, ndim, std::move(shape_in), std::move(strides_in), readonly) {}
 
-    Py_buffer *view = nullptr;
+    Py_buffer *m_view = nullptr;
     bool ownview = false;
 };
 
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(detail)
 
-template <typename T, typename SFINAE = void> struct compare_buffer_info {
-    static bool compare(const buffer_info& b) {
+template <typename T, typename SFINAE = void>
+struct compare_buffer_info {
+    static bool compare(const buffer_info &b) {
         return b.format == format_descriptor<T>::format() && b.itemsize == (ssize_t) sizeof(T);
     }
 };
 
-template <typename T> struct compare_buffer_info<T, detail::enable_if_t<std::is_integral<T>::value>> {
-    static bool compare(const buffer_info& b) {
-        return (size_t) b.itemsize == sizeof(T) && (b.format == format_descriptor<T>::value ||
-            ((sizeof(T) == sizeof(long)) && b.format == (std::is_unsigned<T>::value ? "L" : "l")) ||
-            ((sizeof(T) == sizeof(size_t)) && b.format == (std::is_unsigned<T>::value ? "N" : "n")));
+template <typename T>
+struct compare_buffer_info<T, detail::enable_if_t<std::is_integral<T>::value>> {
+    static bool compare(const buffer_info &b) {
+        return (size_t) b.itemsize == sizeof(T)
+               && (b.format == format_descriptor<T>::value
+                   || ((sizeof(T) == sizeof(long))
+                       && b.format == (std::is_unsigned<T>::value ? "L" : "l"))
+                   || ((sizeof(T) == sizeof(size_t))
+                       && b.format == (std::is_unsigned<T>::value ? "N" : "n")));
     }
 };
 
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/cast.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/numpy.h`

 * *Files 26% similar despite different names*

```diff
@@ -1,2190 +1,1992 @@
 /*
-    pybind11/cast.h: Partial template specializations to cast between
-    C++ and Python types
+    pybind11/numpy.h: Basic NumPy support, vectorize() wrapper
 
     Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
-#include "pytypes.h"
-#include "detail/typeid.h"
-#include "detail/descr.h"
-#include "detail/internals.h"
+#include "pybind11.h"
+#include "complex.h"
+
+#include <algorithm>
 #include <array>
-#include <limits>
-#include <tuple>
+#include <cstdint>
+#include <cstdlib>
+#include <cstring>
+#include <functional>
+#include <numeric>
+#include <sstream>
+#include <string>
 #include <type_traits>
-
-#if defined(PYBIND11_CPP17)
-#  if defined(__has_include)
-#    if __has_include(<string_view>)
-#      define PYBIND11_HAS_STRING_VIEW
-#    endif
-#  elif defined(_MSC_VER)
-#    define PYBIND11_HAS_STRING_VIEW
-#  endif
-#endif
-#ifdef PYBIND11_HAS_STRING_VIEW
-#include <string_view>
-#endif
-
-#if defined(__cpp_lib_char8_t) && __cpp_lib_char8_t >= 201811L
-#  define PYBIND11_HAS_U8STRING
-#endif
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
-
-/// A life support system for temporary objects created by `type_caster::load()`.
-/// Adding a patient will keep it alive up until the enclosing function returns.
-class loader_life_support {
-public:
-    /// A new patient frame is created when a function is entered
-    loader_life_support() {
-        get_internals().loader_patient_stack.push_back(nullptr);
-    }
-
-    /// ... and destroyed after it returns
-    ~loader_life_support() {
-        auto &stack = get_internals().loader_patient_stack;
-        if (stack.empty())
-            pybind11_fail("loader_life_support: internal error");
-
-        auto ptr = stack.back();
-        stack.pop_back();
-        Py_CLEAR(ptr);
-
-        // A heuristic to reduce the stack's capacity (e.g. after long recursive calls)
-        if (stack.capacity() > 16 && stack.size() != 0 && stack.capacity() / stack.size() > 2)
-            stack.shrink_to_fit();
-    }
-
-    /// This can only be used inside a pybind11-bound function, either by `argument_loader`
-    /// at argument preparation time or by `py::cast()` at execution time.
-    PYBIND11_NOINLINE static void add_patient(handle h) {
-        auto &stack = get_internals().loader_patient_stack;
-        if (stack.empty())
-            throw cast_error("When called outside a bound function, py::cast() cannot "
-                             "do Python -> C++ conversions which require the creation "
-                             "of temporary values");
-
-        auto &list_ptr = stack.back();
-        if (list_ptr == nullptr) {
-            list_ptr = PyList_New(1);
-            if (!list_ptr)
-                pybind11_fail("loader_life_support: error allocating list");
-            PyList_SET_ITEM(list_ptr, 0, h.inc_ref().ptr());
-        } else {
-            auto result = PyList_Append(list_ptr, h.ptr());
-            if (result == -1)
-                pybind11_fail("loader_life_support: error adding patient");
+#include <typeindex>
+#include <utility>
+#include <vector>
+
+/* This will be true on all flat address space platforms and allows us to reduce the
+   whole npy_intp / ssize_t / Py_intptr_t business down to just ssize_t for all size
+   and dimension types (e.g. shape, strides, indexing), instead of inflicting this
+   upon the library user. */
+static_assert(sizeof(::pybind11::ssize_t) == sizeof(Py_intptr_t), "ssize_t != Py_intptr_t");
+static_assert(std::is_signed<Py_intptr_t>::value, "Py_intptr_t must be signed");
+// We now can reinterpret_cast between py::ssize_t and Py_intptr_t (MSVC + PyPy cares)
+
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+
+PYBIND11_WARNING_DISABLE_MSVC(4127)
+
+class array; // Forward declaration
+
+PYBIND11_NAMESPACE_BEGIN(detail)
+
+template <>
+struct handle_type_name<array> {
+    static constexpr auto name = const_name("numpy.ndarray");
+};
+
+template <typename type, typename SFINAE = void>
+struct npy_format_descriptor;
+
+struct PyArrayDescr_Proxy {
+    PyObject_HEAD
+    PyObject *typeobj;
+    char kind;
+    char type;
+    char byteorder;
+    char flags;
+    int type_num;
+    int elsize;
+    int alignment;
+    char *subarray;
+    PyObject *fields;
+    PyObject *names;
+};
+
+struct PyArray_Proxy {
+    PyObject_HEAD
+    char *data;
+    int nd;
+    ssize_t *dimensions;
+    ssize_t *strides;
+    PyObject *base;
+    PyObject *descr;
+    int flags;
+};
+
+struct PyVoidScalarObject_Proxy {
+    PyObject_VAR_HEAD char *obval;
+    PyArrayDescr_Proxy *descr;
+    int flags;
+    PyObject *base;
+};
+
+struct numpy_type_info {
+    PyObject *dtype_ptr;
+    std::string format_str;
+};
+
+struct numpy_internals {
+    std::unordered_map<std::type_index, numpy_type_info> registered_dtypes;
+
+    numpy_type_info *get_type_info(const std::type_info &tinfo, bool throw_if_missing = true) {
+        auto it = registered_dtypes.find(std::type_index(tinfo));
+        if (it != registered_dtypes.end()) {
+            return &(it->second);
         }
-    }
-};
-
-// Gets the cache entry for the given type, creating it if necessary.  The return value is the pair
-// returned by emplace, i.e. an iterator for the entry and a bool set to `true` if the entry was
-// just created.
-inline std::pair<decltype(internals::registered_types_py)::iterator, bool> all_type_info_get_cache(PyTypeObject *type);
-
-// Populates a just-created cache entry.
-PYBIND11_NOINLINE inline void all_type_info_populate(PyTypeObject *t, std::vector<type_info *> &bases) {
-    std::vector<PyTypeObject *> check;
-    for (handle parent : reinterpret_borrow<tuple>(t->tp_bases))
-        check.push_back((PyTypeObject *) parent.ptr());
-
-    auto const &type_dict = get_internals().registered_types_py;
-    for (size_t i = 0; i < check.size(); i++) {
-        auto type = check[i];
-        // Ignore Python2 old-style class super type:
-        if (!PyType_Check((PyObject *) type)) continue;
-
-        // Check `type` in the current set of registered python types:
-        auto it = type_dict.find(type);
-        if (it != type_dict.end()) {
-            // We found a cache entry for it, so it's either pybind-registered or has pre-computed
-            // pybind bases, but we have to make sure we haven't already seen the type(s) before: we
-            // want to follow Python/virtual C++ rules that there should only be one instance of a
-            // common base.
-            for (auto *tinfo : it->second) {
-                // NB: Could use a second set here, rather than doing a linear search, but since
-                // having a large number of immediate pybind11-registered types seems fairly
-                // unlikely, that probably isn't worthwhile.
-                bool found = false;
-                for (auto *known : bases) {
-                    if (known == tinfo) { found = true; break; }
-                }
-                if (!found) bases.push_back(tinfo);
-            }
-        }
-        else if (type->tp_bases) {
-            // It's some python type, so keep follow its bases classes to look for one or more
-            // registered types
-            if (i + 1 == check.size()) {
-                // When we're at the end, we can pop off the current element to avoid growing
-                // `check` when adding just one base (which is typical--i.e. when there is no
-                // multiple inheritance)
-                check.pop_back();
-                i--;
-            }
-            for (handle parent : reinterpret_borrow<tuple>(type->tp_bases))
-                check.push_back((PyTypeObject *) parent.ptr());
+        if (throw_if_missing) {
+            pybind11_fail(std::string("NumPy type info missing for ") + tinfo.name());
         }
-    }
-}
-
-/**
- * Extracts vector of type_info pointers of pybind-registered roots of the given Python type.  Will
- * be just 1 pybind type for the Python type of a pybind-registered class, or for any Python-side
- * derived class that uses single inheritance.  Will contain as many types as required for a Python
- * class that uses multiple inheritance to inherit (directly or indirectly) from multiple
- * pybind-registered classes.  Will be empty if neither the type nor any base classes are
- * pybind-registered.
- *
- * The value is cached for the lifetime of the Python type.
- */
-inline const std::vector<detail::type_info *> &all_type_info(PyTypeObject *type) {
-    auto ins = all_type_info_get_cache(type);
-    if (ins.second)
-        // New cache entry: populate it
-        all_type_info_populate(type, ins.first->second);
-
-    return ins.first->second;
-}
-
-/**
- * Gets a single pybind11 type info for a python type.  Returns nullptr if neither the type nor any
- * ancestors are pybind11-registered.  Throws an exception if there are multiple bases--use
- * `all_type_info` instead if you want to support multiple bases.
- */
-PYBIND11_NOINLINE inline detail::type_info* get_type_info(PyTypeObject *type) {
-    auto &bases = all_type_info(type);
-    if (bases.size() == 0)
         return nullptr;
-    if (bases.size() > 1)
-        pybind11_fail("pybind11::detail::get_type_info: type has multiple pybind11-registered bases");
-    return bases.front();
-}
+    }
 
-inline detail::type_info *get_local_type_info(const std::type_index &tp) {
-    auto &locals = registered_local_types_cpp();
-    auto it = locals.find(tp);
-    if (it != locals.end())
-        return it->second;
-    return nullptr;
-}
+    template <typename T>
+    numpy_type_info *get_type_info(bool throw_if_missing = true) {
+        return get_type_info(typeid(typename std::remove_cv<T>::type), throw_if_missing);
+    }
+};
 
-inline detail::type_info *get_global_type_info(const std::type_index &tp) {
-    auto &types = get_internals().registered_types_cpp;
-    auto it = types.find(tp);
-    if (it != types.end())
-        return it->second;
-    return nullptr;
+PYBIND11_NOINLINE void load_numpy_internals(numpy_internals *&ptr) {
+    ptr = &get_or_create_shared_data<numpy_internals>("_numpy_internals");
 }
 
-/// Return the type info for a given C++ type; on lookup failure can either throw or return nullptr.
-PYBIND11_NOINLINE inline detail::type_info *get_type_info(const std::type_index &tp,
-                                                          bool throw_if_missing = false) {
-    if (auto ltype = get_local_type_info(tp))
-        return ltype;
-    if (auto gtype = get_global_type_info(tp))
-        return gtype;
-
-    if (throw_if_missing) {
-        std::string tname = tp.name();
-        detail::clean_type_id(tname);
-        pybind11_fail("pybind11::detail::get_type_info: unable to find type info for \"" + tname + "\"");
+inline numpy_internals &get_numpy_internals() {
+    static numpy_internals *ptr = nullptr;
+    if (!ptr) {
+        load_numpy_internals(ptr);
     }
-    return nullptr;
-}
-
-PYBIND11_NOINLINE inline handle get_type_handle(const std::type_info &tp, bool throw_if_missing) {
-    detail::type_info *type_info = get_type_info(tp, throw_if_missing);
-    return handle(type_info ? ((PyObject *) type_info->type) : nullptr);
+    return *ptr;
 }
 
-struct value_and_holder {
-    instance *inst = nullptr;
-    size_t index = 0u;
-    const detail::type_info *type = nullptr;
-    void **vh = nullptr;
-
-    // Main constructor for a found value/holder:
-    value_and_holder(instance *i, const detail::type_info *type, size_t vpos, size_t index) :
-        inst{i}, index{index}, type{type},
-        vh{inst->simple_layout ? inst->simple_value_holder : &inst->nonsimple.values_and_holders[vpos]}
-    {}
-
-    // Default constructor (used to signal a value-and-holder not found by get_value_and_holder())
-    value_and_holder() {}
-
-    // Used for past-the-end iterator
-    value_and_holder(size_t index) : index{index} {}
-
-    template <typename V = void> V *&value_ptr() const {
-        return reinterpret_cast<V *&>(vh[0]);
-    }
-    // True if this `value_and_holder` has a non-null value pointer
-    explicit operator bool() const { return value_ptr(); }
-
-    template <typename H> H &holder() const {
-        return reinterpret_cast<H &>(vh[1]);
-    }
-    bool holder_constructed() const {
-        return inst->simple_layout
-            ? inst->simple_holder_constructed
-            : inst->nonsimple.status[index] & instance::status_holder_constructed;
-    }
-    void set_holder_constructed(bool v = true) {
-        if (inst->simple_layout)
-            inst->simple_holder_constructed = v;
-        else if (v)
-            inst->nonsimple.status[index] |= instance::status_holder_constructed;
-        else
-            inst->nonsimple.status[index] &= (uint8_t) ~instance::status_holder_constructed;
-    }
-    bool instance_registered() const {
-        return inst->simple_layout
-            ? inst->simple_instance_registered
-            : inst->nonsimple.status[index] & instance::status_instance_registered;
-    }
-    void set_instance_registered(bool v = true) {
-        if (inst->simple_layout)
-            inst->simple_instance_registered = v;
-        else if (v)
-            inst->nonsimple.status[index] |= instance::status_instance_registered;
-        else
-            inst->nonsimple.status[index] &= (uint8_t) ~instance::status_instance_registered;
-    }
-};
+template <typename T>
+struct same_size {
+    template <typename U>
+    using as = bool_constant<sizeof(T) == sizeof(U)>;
+};
+
+template <typename Concrete>
+constexpr int platform_lookup() {
+    return -1;
+}
+
+// Lookup a type according to its size, and return a value corresponding to the NumPy typenum.
+template <typename Concrete, typename T, typename... Ts, typename... Ints>
+constexpr int platform_lookup(int I, Ints... Is) {
+    return sizeof(Concrete) == sizeof(T) ? I : platform_lookup<Concrete, Ts...>(Is...);
+}
+
+struct npy_api {
+    enum constants {
+        NPY_ARRAY_C_CONTIGUOUS_ = 0x0001,
+        NPY_ARRAY_F_CONTIGUOUS_ = 0x0002,
+        NPY_ARRAY_OWNDATA_ = 0x0004,
+        NPY_ARRAY_FORCECAST_ = 0x0010,
+        NPY_ARRAY_ENSUREARRAY_ = 0x0040,
+        NPY_ARRAY_ALIGNED_ = 0x0100,
+        NPY_ARRAY_WRITEABLE_ = 0x0400,
+        NPY_BOOL_ = 0,
+        NPY_BYTE_,
+        NPY_UBYTE_,
+        NPY_SHORT_,
+        NPY_USHORT_,
+        NPY_INT_,
+        NPY_UINT_,
+        NPY_LONG_,
+        NPY_ULONG_,
+        NPY_LONGLONG_,
+        NPY_ULONGLONG_,
+        NPY_FLOAT_,
+        NPY_DOUBLE_,
+        NPY_LONGDOUBLE_,
+        NPY_CFLOAT_,
+        NPY_CDOUBLE_,
+        NPY_CLONGDOUBLE_,
+        NPY_OBJECT_ = 17,
+        NPY_STRING_,
+        NPY_UNICODE_,
+        NPY_VOID_,
+        // Platform-dependent normalization
+        NPY_INT8_ = NPY_BYTE_,
+        NPY_UINT8_ = NPY_UBYTE_,
+        NPY_INT16_ = NPY_SHORT_,
+        NPY_UINT16_ = NPY_USHORT_,
+        // `npy_common.h` defines the integer aliases. In order, it checks:
+        // NPY_BITSOF_LONG, NPY_BITSOF_LONGLONG, NPY_BITSOF_INT, NPY_BITSOF_SHORT, NPY_BITSOF_CHAR
+        // and assigns the alias to the first matching size, so we should check in this order.
+        NPY_INT32_
+        = platform_lookup<std::int32_t, long, int, short>(NPY_LONG_, NPY_INT_, NPY_SHORT_),
+        NPY_UINT32_ = platform_lookup<std::uint32_t, unsigned long, unsigned int, unsigned short>(
+            NPY_ULONG_, NPY_UINT_, NPY_USHORT_),
+        NPY_INT64_
+        = platform_lookup<std::int64_t, long, long long, int>(NPY_LONG_, NPY_LONGLONG_, NPY_INT_),
+        NPY_UINT64_
+        = platform_lookup<std::uint64_t, unsigned long, unsigned long long, unsigned int>(
+            NPY_ULONG_, NPY_ULONGLONG_, NPY_UINT_),
+    };
 
-// Container for accessing and iterating over an instance's values/holders
-struct values_and_holders {
-private:
-    instance *inst;
-    using type_vec = std::vector<detail::type_info *>;
-    const type_vec &tinfo;
+    struct PyArray_Dims {
+        Py_intptr_t *ptr;
+        int len;
+    };
 
-public:
-    values_and_holders(instance *inst) : inst{inst}, tinfo(all_type_info(Py_TYPE(inst))) {}
+    static npy_api &get() {
+        static npy_api api = lookup();
+        return api;
+    }
+
+    bool PyArray_Check_(PyObject *obj) const {
+        return PyObject_TypeCheck(obj, PyArray_Type_) != 0;
+    }
+    bool PyArrayDescr_Check_(PyObject *obj) const {
+        return PyObject_TypeCheck(obj, PyArrayDescr_Type_) != 0;
+    }
+
+    unsigned int (*PyArray_GetNDArrayCFeatureVersion_)();
+    PyObject *(*PyArray_DescrFromType_)(int);
+    PyObject *(*PyArray_NewFromDescr_)(PyTypeObject *,
+                                       PyObject *,
+                                       int,
+                                       Py_intptr_t const *,
+                                       Py_intptr_t const *,
+                                       void *,
+                                       int,
+                                       PyObject *);
+    // Unused. Not removed because that affects ABI of the class.
+    PyObject *(*PyArray_DescrNewFromType_)(int);
+    int (*PyArray_CopyInto_)(PyObject *, PyObject *);
+    PyObject *(*PyArray_NewCopy_)(PyObject *, int);
+    PyTypeObject *PyArray_Type_;
+    PyTypeObject *PyVoidArrType_Type_;
+    PyTypeObject *PyArrayDescr_Type_;
+    PyObject *(*PyArray_DescrFromScalar_)(PyObject *);
+    PyObject *(*PyArray_FromAny_)(PyObject *, PyObject *, int, int, int, PyObject *);
+    int (*PyArray_DescrConverter_)(PyObject *, PyObject **);
+    bool (*PyArray_EquivTypes_)(PyObject *, PyObject *);
+    int (*PyArray_GetArrayParamsFromObject_)(PyObject *,
+                                             PyObject *,
+                                             unsigned char,
+                                             PyObject **,
+                                             int *,
+                                             Py_intptr_t *,
+                                             PyObject **,
+                                             PyObject *);
+    PyObject *(*PyArray_Squeeze_)(PyObject *);
+    // Unused. Not removed because that affects ABI of the class.
+    int (*PyArray_SetBaseObject_)(PyObject *, PyObject *);
+    PyObject *(*PyArray_Resize_)(PyObject *, PyArray_Dims *, int, int);
+    PyObject *(*PyArray_Newshape_)(PyObject *, PyArray_Dims *, int);
+    PyObject *(*PyArray_View_)(PyObject *, PyObject *, PyObject *);
 
-    struct iterator {
-    private:
-        instance *inst = nullptr;
-        const type_vec *types = nullptr;
-        value_and_holder curr;
-        friend struct values_and_holders;
-        iterator(instance *inst, const type_vec *tinfo)
-            : inst{inst}, types{tinfo},
-            curr(inst /* instance */,
-                 types->empty() ? nullptr : (*types)[0] /* type info */,
-                 0, /* vpos: (non-simple types only): the first vptr comes first */
-                 0 /* index */)
-        {}
-        // Past-the-end iterator:
-        iterator(size_t end) : curr(end) {}
-    public:
-        bool operator==(const iterator &other) const { return curr.index == other.curr.index; }
-        bool operator!=(const iterator &other) const { return curr.index != other.curr.index; }
-        iterator &operator++() {
-            if (!inst->simple_layout)
-                curr.vh += 1 + (*types)[curr.index]->holder_size_in_ptrs;
-            ++curr.index;
-            curr.type = curr.index < types->size() ? (*types)[curr.index] : nullptr;
-            return *this;
-        }
-        value_and_holder &operator*() { return curr; }
-        value_and_holder *operator->() { return &curr; }
+private:
+    enum functions {
+        API_PyArray_GetNDArrayCFeatureVersion = 211,
+        API_PyArray_Type = 2,
+        API_PyArrayDescr_Type = 3,
+        API_PyVoidArrType_Type = 39,
+        API_PyArray_DescrFromType = 45,
+        API_PyArray_DescrFromScalar = 57,
+        API_PyArray_FromAny = 69,
+        API_PyArray_Resize = 80,
+        API_PyArray_CopyInto = 82,
+        API_PyArray_NewCopy = 85,
+        API_PyArray_NewFromDescr = 94,
+        API_PyArray_DescrNewFromType = 96,
+        API_PyArray_Newshape = 135,
+        API_PyArray_Squeeze = 136,
+        API_PyArray_View = 137,
+        API_PyArray_DescrConverter = 174,
+        API_PyArray_EquivTypes = 182,
+        API_PyArray_GetArrayParamsFromObject = 278,
+        API_PyArray_SetBaseObject = 282
     };
 
-    iterator begin() { return iterator(inst, &tinfo); }
-    iterator end() { return iterator(tinfo.size()); }
-
-    iterator find(const type_info *find_type) {
-        auto it = begin(), endit = end();
-        while (it != endit && it->type != find_type) ++it;
-        return it;
+    static npy_api lookup() {
+        module_ m = module_::import("numpy.core.multiarray");
+        auto c = m.attr("_ARRAY_API");
+        void **api_ptr = (void **) PyCapsule_GetPointer(c.ptr(), nullptr);
+        npy_api api;
+#define DECL_NPY_API(Func) api.Func##_ = (decltype(api.Func##_)) api_ptr[API_##Func];
+        DECL_NPY_API(PyArray_GetNDArrayCFeatureVersion);
+        if (api.PyArray_GetNDArrayCFeatureVersion_() < 0x7) {
+            pybind11_fail("pybind11 numpy support requires numpy >= 1.7.0");
+        }
+        DECL_NPY_API(PyArray_Type);
+        DECL_NPY_API(PyVoidArrType_Type);
+        DECL_NPY_API(PyArrayDescr_Type);
+        DECL_NPY_API(PyArray_DescrFromType);
+        DECL_NPY_API(PyArray_DescrFromScalar);
+        DECL_NPY_API(PyArray_FromAny);
+        DECL_NPY_API(PyArray_Resize);
+        DECL_NPY_API(PyArray_CopyInto);
+        DECL_NPY_API(PyArray_NewCopy);
+        DECL_NPY_API(PyArray_NewFromDescr);
+        DECL_NPY_API(PyArray_DescrNewFromType);
+        DECL_NPY_API(PyArray_Newshape);
+        DECL_NPY_API(PyArray_Squeeze);
+        DECL_NPY_API(PyArray_View);
+        DECL_NPY_API(PyArray_DescrConverter);
+        DECL_NPY_API(PyArray_EquivTypes);
+        DECL_NPY_API(PyArray_GetArrayParamsFromObject);
+        DECL_NPY_API(PyArray_SetBaseObject);
+
+#undef DECL_NPY_API
+        return api;
     }
-
-    size_t size() { return tinfo.size(); }
 };
 
-/**
- * Extracts C++ value and holder pointer references from an instance (which may contain multiple
- * values/holders for python-side multiple inheritance) that match the given type.  Throws an error
- * if the given type (or ValueType, if omitted) is not a pybind11 base of the given instance.  If
- * `find_type` is omitted (or explicitly specified as nullptr) the first value/holder are returned,
- * regardless of type (and the resulting .type will be nullptr).
- *
- * The returned object should be short-lived: in particular, it must not outlive the called-upon
- * instance.
- */
-PYBIND11_NOINLINE inline value_and_holder instance::get_value_and_holder(const type_info *find_type /*= nullptr default in common.h*/, bool throw_if_missing /*= true in common.h*/) {
-    // Optimize common case:
-    if (!find_type || Py_TYPE(this) == find_type->type)
-        return value_and_holder(this, find_type, 0, 0);
-
-    detail::values_and_holders vhs(this);
-    auto it = vhs.find(find_type);
-    if (it != vhs.end())
-        return *it;
-
-    if (!throw_if_missing)
-        return value_and_holder();
-
-#if defined(NDEBUG)
-    pybind11_fail("pybind11::detail::instance::get_value_and_holder: "
-            "type is not a pybind11 base of the given instance "
-            "(compile in debug mode for type details)");
-#else
-    pybind11_fail("pybind11::detail::instance::get_value_and_holder: `" +
-            std::string(find_type->type->tp_name) + "' is not a pybind11 base of the given `" +
-            std::string(Py_TYPE(this)->tp_name) + "' instance");
-#endif
+inline PyArray_Proxy *array_proxy(void *ptr) { return reinterpret_cast<PyArray_Proxy *>(ptr); }
+
+inline const PyArray_Proxy *array_proxy(const void *ptr) {
+    return reinterpret_cast<const PyArray_Proxy *>(ptr);
+}
+
+inline PyArrayDescr_Proxy *array_descriptor_proxy(PyObject *ptr) {
+    return reinterpret_cast<PyArrayDescr_Proxy *>(ptr);
 }
 
-PYBIND11_NOINLINE inline void instance::allocate_layout() {
-    auto &tinfo = all_type_info(Py_TYPE(this));
+inline const PyArrayDescr_Proxy *array_descriptor_proxy(const PyObject *ptr) {
+    return reinterpret_cast<const PyArrayDescr_Proxy *>(ptr);
+}
 
-    const size_t n_types = tinfo.size();
+inline bool check_flags(const void *ptr, int flag) {
+    return (flag == (array_proxy(ptr)->flags & flag));
+}
+
+template <typename T>
+struct is_std_array : std::false_type {};
+template <typename T, size_t N>
+struct is_std_array<std::array<T, N>> : std::true_type {};
+template <typename T>
+struct is_complex : std::false_type {};
+template <typename T>
+struct is_complex<std::complex<T>> : std::true_type {};
 
-    if (n_types == 0)
-        pybind11_fail("instance allocation failed: new instance has no pybind11-registered base types");
+template <typename T>
+struct array_info_scalar {
+    using type = T;
+    static constexpr bool is_array = false;
+    static constexpr bool is_empty = false;
+    static constexpr auto extents = const_name("");
+    static void append_extents(list & /* shape */) {}
+};
+// Computes underlying type and a comma-separated list of extents for array
+// types (any mix of std::array and built-in arrays). An array of char is
+// treated as scalar because it gets special handling.
+template <typename T>
+struct array_info : array_info_scalar<T> {};
+template <typename T, size_t N>
+struct array_info<std::array<T, N>> {
+    using type = typename array_info<T>::type;
+    static constexpr bool is_array = true;
+    static constexpr bool is_empty = (N == 0) || array_info<T>::is_empty;
+    static constexpr size_t extent = N;
+
+    // appends the extents to shape
+    static void append_extents(list &shape) {
+        shape.append(N);
+        array_info<T>::append_extents(shape);
+    }
+
+    static constexpr auto extents = const_name<array_info<T>::is_array>(
+        concat(const_name<N>(), array_info<T>::extents), const_name<N>());
+};
+// For numpy we have special handling for arrays of characters, so we don't include
+// the size in the array extents.
+template <size_t N>
+struct array_info<char[N]> : array_info_scalar<char[N]> {};
+template <size_t N>
+struct array_info<std::array<char, N>> : array_info_scalar<std::array<char, N>> {};
+template <typename T, size_t N>
+struct array_info<T[N]> : array_info<std::array<T, N>> {};
+template <typename T>
+using remove_all_extents_t = typename array_info<T>::type;
 
-    simple_layout =
-        n_types == 1 && tinfo.front()->holder_size_in_ptrs <= instance_simple_holder_in_ptrs();
-
-    // Simple path: no python-side multiple inheritance, and a small-enough holder
-    if (simple_layout) {
-        simple_value_holder[0] = nullptr;
-        simple_holder_constructed = false;
-        simple_instance_registered = false;
-    }
-    else { // multiple base types or a too-large holder
-        // Allocate space to hold: [v1*][h1][v2*][h2]...[bb...] where [vN*] is a value pointer,
-        // [hN] is the (uninitialized) holder instance for value N, and [bb...] is a set of bool
-        // values that tracks whether each associated holder has been initialized.  Each [block] is
-        // padded, if necessary, to an integer multiple of sizeof(void *).
-        size_t space = 0;
-        for (auto t : tinfo) {
-            space += 1; // value pointer
-            space += t->holder_size_in_ptrs; // holder instance
-        }
-        size_t flags_at = space;
-        space += size_in_ptrs(n_types); // status bytes (holder_constructed and instance_registered)
-
-        // Allocate space for flags, values, and holders, and initialize it to 0 (flags and values,
-        // in particular, need to be 0).  Use Python's memory allocation functions: in Python 3.6
-        // they default to using pymalloc, which is designed to be efficient for small allocations
-        // like the one we're doing here; in earlier versions (and for larger allocations) they are
-        // just wrappers around malloc.
-#if PY_VERSION_HEX >= 0x03050000
-        nonsimple.values_and_holders = (void **) PyMem_Calloc(space, sizeof(void *));
-        if (!nonsimple.values_and_holders) throw std::bad_alloc();
+template <typename T>
+using is_pod_struct
+    = all_of<std::is_standard_layout<T>, // since we're accessing directly in memory
+                                         // we need a standard layout type
+#if defined(__GLIBCXX__)                                                                          \
+    && (__GLIBCXX__ < 20150422 || __GLIBCXX__ == 20150426 || __GLIBCXX__ == 20150623              \
+        || __GLIBCXX__ == 20150626 || __GLIBCXX__ == 20160803)
+             // libstdc++ < 5 (including versions 4.8.5, 4.9.3 and 4.9.4 which were released after
+             // 5) don't implement is_trivially_copyable, so approximate it
+             std::is_trivially_destructible<T>,
+             satisfies_any_of<T, std::has_trivial_copy_constructor, std::has_trivial_copy_assign>,
 #else
-        nonsimple.values_and_holders = (void **) PyMem_New(void *, space);
-        if (!nonsimple.values_and_holders) throw std::bad_alloc();
-        std::memset(nonsimple.values_and_holders, 0, space * sizeof(void *));
+             std::is_trivially_copyable<T>,
 #endif
-        nonsimple.status = reinterpret_cast<uint8_t *>(&nonsimple.values_and_holders[flags_at]);
-    }
-    owned = true;
-}
+             satisfies_none_of<T,
+                               std::is_reference,
+                               std::is_array,
+                               is_std_array,
+                               std::is_arithmetic,
+                               is_complex,
+                               std::is_enum>>;
 
-PYBIND11_NOINLINE inline void instance::deallocate_layout() {
-    if (!simple_layout)
-        PyMem_Free(nonsimple.values_and_holders);
-}
+// Replacement for std::is_pod (deprecated in C++20)
+template <typename T>
+using is_pod = all_of<std::is_standard_layout<T>, std::is_trivial<T>>;
 
-PYBIND11_NOINLINE inline bool isinstance_generic(handle obj, const std::type_info &tp) {
-    handle type = detail::get_type_handle(tp, false);
-    if (!type)
-        return false;
-    return isinstance(obj, type);
+template <ssize_t Dim = 0, typename Strides>
+ssize_t byte_offset_unsafe(const Strides &) {
+    return 0;
+}
+template <ssize_t Dim = 0, typename Strides, typename... Ix>
+ssize_t byte_offset_unsafe(const Strides &strides, ssize_t i, Ix... index) {
+    return i * strides[Dim] + byte_offset_unsafe<Dim + 1>(strides, index...);
 }
 
-PYBIND11_NOINLINE inline std::string error_string() {
-    if (!PyErr_Occurred()) {
-        PyErr_SetString(PyExc_RuntimeError, "Unknown internal error occurred");
-        return "Unknown internal error occurred";
-    }
+/**
+ * Proxy class providing unsafe, unchecked const access to array data.  This is constructed through
+ * the `unchecked<T, N>()` method of `array` or the `unchecked<N>()` method of `array_t<T>`. `Dims`
+ * will be -1 for dimensions determined at runtime.
+ */
+template <typename T, ssize_t Dims>
+class unchecked_reference {
+protected:
+    static constexpr bool Dynamic = Dims < 0;
+    const unsigned char *data_;
+    // Storing the shape & strides in local variables (i.e. these arrays) allows the compiler to
+    // make large performance gains on big, nested loops, but requires compile-time dimensions
+    conditional_t<Dynamic, const ssize_t *, std::array<ssize_t, (size_t) Dims>> shape_, strides_;
+    const ssize_t dims_;
+
+    friend class pybind11::array;
+    // Constructor for compile-time dimensions:
+    template <bool Dyn = Dynamic>
+    unchecked_reference(const void *data,
+                        const ssize_t *shape,
+                        const ssize_t *strides,
+                        enable_if_t<!Dyn, ssize_t>)
+        : data_{reinterpret_cast<const unsigned char *>(data)}, dims_{Dims} {
+        for (size_t i = 0; i < (size_t) dims_; i++) {
+            shape_[i] = shape[i];
+            strides_[i] = strides[i];
+        }
+    }
+    // Constructor for runtime dimensions:
+    template <bool Dyn = Dynamic>
+    unchecked_reference(const void *data,
+                        const ssize_t *shape,
+                        const ssize_t *strides,
+                        enable_if_t<Dyn, ssize_t> dims)
+        : data_{reinterpret_cast<const unsigned char *>(data)}, shape_{shape}, strides_{strides},
+          dims_{dims} {}
 
-    error_scope scope; // Preserve error state
+public:
+    /**
+     * Unchecked const reference access to data at the given indices.  For a compile-time known
+     * number of dimensions, this requires the correct number of arguments; for run-time
+     * dimensionality, this is not checked (and so is up to the caller to use safely).
+     */
+    template <typename... Ix>
+    const T &operator()(Ix... index) const {
+        static_assert(ssize_t{sizeof...(Ix)} == Dims || Dynamic,
+                      "Invalid number of indices for unchecked array reference");
+        return *reinterpret_cast<const T *>(data_
+                                            + byte_offset_unsafe(strides_, ssize_t(index)...));
+    }
+    /**
+     * Unchecked const reference access to data; this operator only participates if the reference
+     * is to a 1-dimensional array.  When present, this is exactly equivalent to `obj(index)`.
+     */
+    template <ssize_t D = Dims, typename = enable_if_t<D == 1 || Dynamic>>
+    const T &operator[](ssize_t index) const {
+        return operator()(index);
+    }
+
+    /// Pointer access to the data at the given indices.
+    template <typename... Ix>
+    const T *data(Ix... ix) const {
+        return &operator()(ssize_t(ix)...);
+    }
+
+    /// Returns the item size, i.e. sizeof(T)
+    constexpr static ssize_t itemsize() { return sizeof(T); }
+
+    /// Returns the shape (i.e. size) of dimension `dim`
+    ssize_t shape(ssize_t dim) const { return shape_[(size_t) dim]; }
+
+    /// Returns the number of dimensions of the array
+    ssize_t ndim() const { return dims_; }
+
+    /// Returns the total number of elements in the referenced array, i.e. the product of the
+    /// shapes
+    template <bool Dyn = Dynamic>
+    enable_if_t<!Dyn, ssize_t> size() const {
+        return std::accumulate(
+            shape_.begin(), shape_.end(), (ssize_t) 1, std::multiplies<ssize_t>());
+    }
+    template <bool Dyn = Dynamic>
+    enable_if_t<Dyn, ssize_t> size() const {
+        return std::accumulate(shape_, shape_ + ndim(), (ssize_t) 1, std::multiplies<ssize_t>());
+    }
+
+    /// Returns the total number of bytes used by the referenced data.  Note that the actual span
+    /// in memory may be larger if the referenced array has non-contiguous strides (e.g. for a
+    /// slice).
+    ssize_t nbytes() const { return size() * itemsize(); }
+};
+
+template <typename T, ssize_t Dims>
+class unchecked_mutable_reference : public unchecked_reference<T, Dims> {
+    friend class pybind11::array;
+    using ConstBase = unchecked_reference<T, Dims>;
+    using ConstBase::ConstBase;
+    using ConstBase::Dynamic;
 
-    std::string errorString;
-    if (scope.type) {
-        errorString += handle(scope.type).attr("__name__").cast<std::string>();
-        errorString += ": ";
+public:
+    // Bring in const-qualified versions from base class
+    using ConstBase::operator();
+    using ConstBase::operator[];
+
+    /// Mutable, unchecked access to data at the given indices.
+    template <typename... Ix>
+    T &operator()(Ix... index) {
+        static_assert(ssize_t{sizeof...(Ix)} == Dims || Dynamic,
+                      "Invalid number of indices for unchecked array reference");
+        return const_cast<T &>(ConstBase::operator()(index...));
+    }
+    /**
+     * Mutable, unchecked access data at the given index; this operator only participates if the
+     * reference is to a 1-dimensional array (or has runtime dimensions).  When present, this is
+     * exactly equivalent to `obj(index)`.
+     */
+    template <ssize_t D = Dims, typename = enable_if_t<D == 1 || Dynamic>>
+    T &operator[](ssize_t index) {
+        return operator()(index);
+    }
+
+    /// Mutable pointer access to the data at the given indices.
+    template <typename... Ix>
+    T *mutable_data(Ix... ix) {
+        return &operator()(ssize_t(ix)...);
     }
-    if (scope.value)
-        errorString += (std::string) str(scope.value);
-
-    PyErr_NormalizeException(&scope.type, &scope.value, &scope.trace);
+};
 
-#if PY_MAJOR_VERSION >= 3
-    if (scope.trace != nullptr)
-        PyException_SetTraceback(scope.value, scope.trace);
-#endif
+template <typename T, ssize_t Dim>
+struct type_caster<unchecked_reference<T, Dim>> {
+    static_assert(Dim == 0 && Dim > 0 /* always fail */,
+                  "unchecked array proxy object is not castable");
+};
+template <typename T, ssize_t Dim>
+struct type_caster<unchecked_mutable_reference<T, Dim>>
+    : type_caster<unchecked_reference<T, Dim>> {};
 
-#if !defined(PYPY_VERSION)
-    if (scope.trace) {
-        PyTracebackObject *trace = (PyTracebackObject *) scope.trace;
-
-        /* Get the deepest trace possible */
-        while (trace->tb_next)
-            trace = trace->tb_next;
-
-        PyFrameObject *frame = trace->tb_frame;
-        errorString += "\n\nAt:\n";
-        while (frame) {
-            int lineno = PyFrame_GetLineNumber(frame);
-            errorString +=
-                "  " + handle(frame->f_code->co_filename).cast<std::string>() +
-                "(" + std::to_string(lineno) + "): " +
-                handle(frame->f_code->co_name).cast<std::string>() + "\n";
-            frame = frame->f_back;
-        }
-    }
-#endif
+PYBIND11_NAMESPACE_END(detail)
 
-    return errorString;
-}
+class dtype : public object {
+public:
+    PYBIND11_OBJECT_DEFAULT(dtype, object, detail::npy_api::get().PyArrayDescr_Check_)
 
-PYBIND11_NOINLINE inline handle get_object_handle(const void *ptr, const detail::type_info *type ) {
-    auto &instances = get_internals().registered_instances;
-    auto range = instances.equal_range(ptr);
-    for (auto it = range.first; it != range.second; ++it) {
-        for (auto vh : values_and_holders(it->second)) {
-            if (vh.type == type)
-                return handle((PyObject *) it->second);
-        }
+    explicit dtype(const buffer_info &info) {
+        dtype descr(_dtype_from_pep3118()(pybind11::str(info.format)));
+        // If info.itemsize == 0, use the value calculated from the format string
+        m_ptr = descr.strip_padding(info.itemsize != 0 ? info.itemsize : descr.itemsize())
+                    .release()
+                    .ptr();
     }
-    return handle();
-}
 
-inline PyThreadState *get_thread_state_unchecked() {
-#if defined(PYPY_VERSION)
-    return PyThreadState_GET();
-#elif PY_VERSION_HEX < 0x03000000
-    return _PyThreadState_Current;
-#elif PY_VERSION_HEX < 0x03050000
-    return (PyThreadState*) _Py_atomic_load_relaxed(&_PyThreadState_Current);
-#elif PY_VERSION_HEX < 0x03050200
-    return (PyThreadState*) _PyThreadState_Current.value;
-#else
-    return _PyThreadState_UncheckedGet();
-#endif
-}
+    explicit dtype(const pybind11::str &format) : dtype(from_args(format)) {}
 
-// Forward declarations
-inline void keep_alive_impl(handle nurse, handle patient);
-inline PyObject *make_new_instance(PyTypeObject *type);
+    explicit dtype(const std::string &format) : dtype(pybind11::str(format)) {}
 
-class type_caster_generic {
-public:
-    PYBIND11_NOINLINE type_caster_generic(const std::type_info &type_info)
-        : typeinfo(get_type_info(type_info)), cpptype(&type_info) { }
+    explicit dtype(const char *format) : dtype(pybind11::str(format)) {}
 
-    type_caster_generic(const type_info *typeinfo)
-        : typeinfo(typeinfo), cpptype(typeinfo ? typeinfo->cpptype : nullptr) { }
+    dtype(list names, list formats, list offsets, ssize_t itemsize) {
+        dict args;
+        args["names"] = std::move(names);
+        args["formats"] = std::move(formats);
+        args["offsets"] = std::move(offsets);
+        args["itemsize"] = pybind11::int_(itemsize);
+        m_ptr = from_args(args).release().ptr();
+    }
 
-    bool load(handle src, bool convert) {
-        return load_impl<type_caster_generic>(src, convert);
+    explicit dtype(int typenum)
+        : object(detail::npy_api::get().PyArray_DescrFromType_(typenum), stolen_t{}) {
+        if (m_ptr == nullptr) {
+            throw error_already_set();
+        }
     }
 
-    PYBIND11_NOINLINE static handle cast(const void *_src, return_value_policy policy, handle parent,
-                                         const detail::type_info *tinfo,
-                                         void *(*copy_constructor)(const void *),
-                                         void *(*move_constructor)(const void *),
-                                         const void *existing_holder = nullptr) {
-        if (!tinfo) // no type info: error will be set already
-            return handle();
-
-        void *src = const_cast<void *>(_src);
-        if (src == nullptr)
-            return none().release();
-
-        auto it_instances = get_internals().registered_instances.equal_range(src);
-        for (auto it_i = it_instances.first; it_i != it_instances.second; ++it_i) {
-            for (auto instance_type : detail::all_type_info(Py_TYPE(it_i->second))) {
-                if (instance_type && same_type(*instance_type->cpptype, *tinfo->cpptype))
-                    return handle((PyObject *) it_i->second).inc_ref();
-            }
+    /// This is essentially the same as calling numpy.dtype(args) in Python.
+    static dtype from_args(const object &args) {
+        PyObject *ptr = nullptr;
+        if ((detail::npy_api::get().PyArray_DescrConverter_(args.ptr(), &ptr) == 0) || !ptr) {
+            throw error_already_set();
         }
+        return reinterpret_steal<dtype>(ptr);
+    }
 
-        auto inst = reinterpret_steal<object>(make_new_instance(tinfo->type));
-        auto wrapper = reinterpret_cast<instance *>(inst.ptr());
-        wrapper->owned = false;
-        void *&valueptr = values_and_holders(wrapper).begin()->value_ptr();
-
-        switch (policy) {
-            case return_value_policy::automatic:
-            case return_value_policy::take_ownership:
-                valueptr = src;
-                wrapper->owned = true;
-                break;
+    /// Return dtype associated with a C++ type.
+    template <typename T>
+    static dtype of() {
+        return detail::npy_format_descriptor<typename std::remove_cv<T>::type>::dtype();
+    }
 
-            case return_value_policy::automatic_reference:
-            case return_value_policy::reference:
-                valueptr = src;
-                wrapper->owned = false;
-                break;
+    /// Size of the data type in bytes.
+    ssize_t itemsize() const { return detail::array_descriptor_proxy(m_ptr)->elsize; }
 
-            case return_value_policy::copy:
-                if (copy_constructor)
-                    valueptr = copy_constructor(src);
-                else {
-#if defined(NDEBUG)
-                    throw cast_error("return_value_policy = copy, but type is "
-                                     "non-copyable! (compile in debug mode for details)");
-#else
-                    std::string type_name(tinfo->cpptype->name());
-                    detail::clean_type_id(type_name);
-                    throw cast_error("return_value_policy = copy, but type " +
-                                     type_name + " is non-copyable!");
-#endif
-                }
-                wrapper->owned = true;
-                break;
+    /// Returns true for structured data types.
+    bool has_fields() const { return detail::array_descriptor_proxy(m_ptr)->names != nullptr; }
 
-            case return_value_policy::move:
-                if (move_constructor)
-                    valueptr = move_constructor(src);
-                else if (copy_constructor)
-                    valueptr = copy_constructor(src);
-                else {
-#if defined(NDEBUG)
-                    throw cast_error("return_value_policy = move, but type is neither "
-                                     "movable nor copyable! "
-                                     "(compile in debug mode for details)");
-#else
-                    std::string type_name(tinfo->cpptype->name());
-                    detail::clean_type_id(type_name);
-                    throw cast_error("return_value_policy = move, but type " +
-                                     type_name + " is neither movable nor copyable!");
-#endif
-                }
-                wrapper->owned = true;
-                break;
+    /// Single-character code for dtype's kind.
+    /// For example, floating point types are 'f' and integral types are 'i'.
+    char kind() const { return detail::array_descriptor_proxy(m_ptr)->kind; }
 
-            case return_value_policy::reference_internal:
-                valueptr = src;
-                wrapper->owned = false;
-                keep_alive_impl(inst, parent);
-                break;
+    /// Single-character for dtype's type.
+    /// For example, ``float`` is 'f', ``double`` 'd', ``int`` 'i', and ``long`` 'l'.
+    char char_() const {
+        // Note: The signature, `dtype::char_` follows the naming of NumPy's
+        // public Python API (i.e., ``dtype.char``), rather than its internal
+        // C API (``PyArray_Descr::type``).
+        return detail::array_descriptor_proxy(m_ptr)->type;
+    }
 
-            default:
-                throw cast_error("unhandled return_value_policy: should not happen!");
-        }
+    /// type number of dtype.
+    int num() const {
+        // Note: The signature, `dtype::num` follows the naming of NumPy's public
+        // Python API (i.e., ``dtype.num``), rather than its internal
+        // C API (``PyArray_Descr::type_num``).
+        return detail::array_descriptor_proxy(m_ptr)->type_num;
+    }
+
+    /// Single character for byteorder
+    char byteorder() const { return detail::array_descriptor_proxy(m_ptr)->byteorder; }
 
-        tinfo->init_instance(wrapper, existing_holder);
+    /// Alignment of the data type
+    int alignment() const { return detail::array_descriptor_proxy(m_ptr)->alignment; }
 
-        return inst.release();
+    /// Flags for the array descriptor
+    char flags() const { return detail::array_descriptor_proxy(m_ptr)->flags; }
+
+private:
+    static object _dtype_from_pep3118() {
+        static PyObject *obj = module_::import("numpy.core._internal")
+                                   .attr("_dtype_from_pep3118")
+                                   .cast<object>()
+                                   .release()
+                                   .ptr();
+        return reinterpret_borrow<object>(obj);
     }
 
-    // Base methods for generic caster; there are overridden in copyable_holder_caster
-    void load_value(value_and_holder &&v_h) {
-        auto *&vptr = v_h.value_ptr();
-        // Lazy allocation for unallocated values:
-        if (vptr == nullptr) {
-            auto *type = v_h.type ? v_h.type : typeinfo;
-            if (type->operator_new) {
-                vptr = type->operator_new(type->type_size);
-            } else {
-                #if defined(__cpp_aligned_new) && (!defined(_MSC_VER) || _MSC_VER >= 1912)
-                    if (type->type_align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
-                        vptr = ::operator new(type->type_size,
-                                              std::align_val_t(type->type_align));
-                    else
-                #endif
-                vptr = ::operator new(type->type_size);
-            }
+    dtype strip_padding(ssize_t itemsize) {
+        // Recursively strip all void fields with empty names that are generated for
+        // padding fields (as of NumPy v1.11).
+        if (!has_fields()) {
+            return *this;
         }
-        value = vptr;
-    }
-    bool try_implicit_casts(handle src, bool convert) {
-        for (auto &cast : typeinfo->implicit_casts) {
-            type_caster_generic sub_caster(*cast.first);
-            if (sub_caster.load(src, convert)) {
-                value = cast.second(sub_caster.value);
-                return true;
+
+        struct field_descr {
+            pybind11::str name;
+            object format;
+            pybind11::int_ offset;
+            field_descr(pybind11::str &&name, object &&format, pybind11::int_ &&offset)
+                : name{std::move(name)}, format{std::move(format)}, offset{std::move(offset)} {};
+        };
+        auto field_dict = attr("fields").cast<dict>();
+        std::vector<field_descr> field_descriptors;
+        field_descriptors.reserve(field_dict.size());
+
+        for (auto field : field_dict.attr("items")()) {
+            auto spec = field.cast<tuple>();
+            auto name = spec[0].cast<pybind11::str>();
+            auto spec_fo = spec[1].cast<tuple>();
+            auto format = spec_fo[0].cast<dtype>();
+            auto offset = spec_fo[1].cast<pybind11::int_>();
+            if ((len(name) == 0u) && format.kind() == 'V') {
+                continue;
             }
+            field_descriptors.emplace_back(
+                std::move(name), format.strip_padding(format.itemsize()), std::move(offset));
         }
-        return false;
-    }
-    bool try_direct_conversions(handle src) {
-        for (auto &converter : *typeinfo->direct_conversions) {
-            if (converter(src.ptr(), value))
-                return true;
+
+        std::sort(field_descriptors.begin(),
+                  field_descriptors.end(),
+                  [](const field_descr &a, const field_descr &b) {
+                      return a.offset.cast<int>() < b.offset.cast<int>();
+                  });
+
+        list names, formats, offsets;
+        for (auto &descr : field_descriptors) {
+            names.append(std::move(descr.name));
+            formats.append(std::move(descr.format));
+            offsets.append(std::move(descr.offset));
         }
-        return false;
+        return dtype(std::move(names), std::move(formats), std::move(offsets), itemsize);
     }
-    void check_holder_compat() {}
+};
 
-    PYBIND11_NOINLINE static void *local_load(PyObject *src, const type_info *ti) {
-        auto caster = type_caster_generic(ti);
-        if (caster.load(src, false))
-            return caster.value;
-        return nullptr;
-    }
+class array : public buffer {
+public:
+    PYBIND11_OBJECT_CVT(array, buffer, detail::npy_api::get().PyArray_Check_, raw_array)
 
-    /// Try to load with foreign typeinfo, if available. Used when there is no
-    /// native typeinfo, or when the native one wasn't able to produce a value.
-    PYBIND11_NOINLINE bool try_load_foreign_module_local(handle src) {
-        constexpr auto *local_key = PYBIND11_MODULE_LOCAL_ID;
-        const auto pytype = src.get_type();
-        if (!hasattr(pytype, local_key))
-            return false;
+    enum {
+        c_style = detail::npy_api::NPY_ARRAY_C_CONTIGUOUS_,
+        f_style = detail::npy_api::NPY_ARRAY_F_CONTIGUOUS_,
+        forcecast = detail::npy_api::NPY_ARRAY_FORCECAST_
+    };
 
-        type_info *foreign_typeinfo = reinterpret_borrow<capsule>(getattr(pytype, local_key));
-        // Only consider this foreign loader if actually foreign and is a loader of the correct cpp type
-        if (foreign_typeinfo->module_local_load == &local_load
-            || (cpptype && !same_type(*cpptype, *foreign_typeinfo->cpptype)))
-            return false;
+    array() : array(0, static_cast<const double *>(nullptr)) {}
 
-        if (auto result = foreign_typeinfo->module_local_load(src.ptr(), foreign_typeinfo)) {
-            value = result;
-            return true;
-        }
-        return false;
-    }
+    using ShapeContainer = detail::any_container<ssize_t>;
+    using StridesContainer = detail::any_container<ssize_t>;
 
-    // Implementation of `load`; this takes the type of `this` so that it can dispatch the relevant
-    // bits of code between here and copyable_holder_caster where the two classes need different
-    // logic (without having to resort to virtual inheritance).
-    template <typename ThisT>
-    PYBIND11_NOINLINE bool load_impl(handle src, bool convert) {
-        if (!src) return false;
-        if (!typeinfo) return try_load_foreign_module_local(src);
-        if (src.is_none()) {
-            // Defer accepting None to other overloads (if we aren't in convert mode):
-            if (!convert) return false;
-            value = nullptr;
-            return true;
-        }
-
-        auto &this_ = static_cast<ThisT &>(*this);
-        this_.check_holder_compat();
-
-        PyTypeObject *srctype = Py_TYPE(src.ptr());
-
-        // Case 1: If src is an exact type match for the target type then we can reinterpret_cast
-        // the instance's value pointer to the target type:
-        if (srctype == typeinfo->type) {
-            this_.load_value(reinterpret_cast<instance *>(src.ptr())->get_value_and_holder());
-            return true;
-        }
-        // Case 2: We have a derived class
-        else if (PyType_IsSubtype(srctype, typeinfo->type)) {
-            auto &bases = all_type_info(srctype);
-            bool no_cpp_mi = typeinfo->simple_type;
-
-            // Case 2a: the python type is a Python-inherited derived class that inherits from just
-            // one simple (no MI) pybind11 class, or is an exact match, so the C++ instance is of
-            // the right type and we can use reinterpret_cast.
-            // (This is essentially the same as case 2b, but because not using multiple inheritance
-            // is extremely common, we handle it specially to avoid the loop iterator and type
-            // pointer lookup overhead)
-            if (bases.size() == 1 && (no_cpp_mi || bases.front()->type == typeinfo->type)) {
-                this_.load_value(reinterpret_cast<instance *>(src.ptr())->get_value_and_holder());
-                return true;
-            }
-            // Case 2b: the python type inherits from multiple C++ bases.  Check the bases to see if
-            // we can find an exact match (or, for a simple C++ type, an inherited match); if so, we
-            // can safely reinterpret_cast to the relevant pointer.
-            else if (bases.size() > 1) {
-                for (auto base : bases) {
-                    if (no_cpp_mi ? PyType_IsSubtype(base->type, typeinfo->type) : base->type == typeinfo->type) {
-                        this_.load_value(reinterpret_cast<instance *>(src.ptr())->get_value_and_holder(base));
-                        return true;
-                    }
-                }
+    // Constructs an array taking shape/strides from arbitrary container types
+    array(const pybind11::dtype &dt,
+          ShapeContainer shape,
+          StridesContainer strides,
+          const void *ptr = nullptr,
+          handle base = handle()) {
+
+        if (strides->empty()) {
+            *strides = detail::c_strides(*shape, dt.itemsize());
+        }
+
+        auto ndim = shape->size();
+        if (ndim != strides->size()) {
+            pybind11_fail("NumPy: shape ndim doesn't match strides ndim");
+        }
+        auto descr = dt;
+
+        int flags = 0;
+        if (base && ptr) {
+            if (isinstance<array>(base)) {
+                /* Copy flags from base (except ownership bit) */
+                flags = reinterpret_borrow<array>(base).flags()
+                        & ~detail::npy_api::NPY_ARRAY_OWNDATA_;
+            } else {
+                /* Writable by default, easy to downgrade later on if needed */
+                flags = detail::npy_api::NPY_ARRAY_WRITEABLE_;
             }
-
-            // Case 2c: C++ multiple inheritance is involved and we couldn't find an exact type match
-            // in the registered bases, above, so try implicit casting (needed for proper C++ casting
-            // when MI is involved).
-            if (this_.try_implicit_casts(src, convert))
-                return true;
         }
 
-        // Perform an implicit conversion
-        if (convert) {
-            for (auto &converter : typeinfo->implicit_conversions) {
-                auto temp = reinterpret_steal<object>(converter(src.ptr(), typeinfo->type));
-                if (load_impl<ThisT>(temp, false)) {
-                    loader_life_support::add_patient(temp);
-                    return true;
-                }
-            }
-            if (this_.try_direct_conversions(src))
-                return true;
+        auto &api = detail::npy_api::get();
+        auto tmp = reinterpret_steal<object>(api.PyArray_NewFromDescr_(
+            api.PyArray_Type_,
+            descr.release().ptr(),
+            (int) ndim,
+            // Use reinterpret_cast for PyPy on Windows (remove if fixed, checked on 7.3.1)
+            reinterpret_cast<Py_intptr_t *>(shape->data()),
+            reinterpret_cast<Py_intptr_t *>(strides->data()),
+            const_cast<void *>(ptr),
+            flags,
+            nullptr));
+        if (!tmp) {
+            throw error_already_set();
         }
-
-        // Failed to match local typeinfo. Try again with global.
-        if (typeinfo->module_local) {
-            if (auto gtype = get_global_type_info(*typeinfo->cpptype)) {
-                typeinfo = gtype;
-                return load(src, false);
+        if (ptr) {
+            if (base) {
+                api.PyArray_SetBaseObject_(tmp.ptr(), base.inc_ref().ptr());
+            } else {
+                tmp = reinterpret_steal<object>(
+                    api.PyArray_NewCopy_(tmp.ptr(), -1 /* any order */));
             }
         }
-
-        // Global typeinfo has precedence over foreign module_local
-        return try_load_foreign_module_local(src);
+        m_ptr = tmp.release().ptr();
     }
 
+    array(const pybind11::dtype &dt,
+          ShapeContainer shape,
+          const void *ptr = nullptr,
+          handle base = handle())
+        : array(dt, std::move(shape), {}, ptr, base) {}
+
+    template <typename T,
+              typename
+              = detail::enable_if_t<std::is_integral<T>::value && !std::is_same<bool, T>::value>>
+    array(const pybind11::dtype &dt, T count, const void *ptr = nullptr, handle base = handle())
+        : array(dt, {{count}}, ptr, base) {}
 
-    // Called to do type lookup and wrap the pointer and type in a pair when a dynamic_cast
-    // isn't needed or can't be used.  If the type is unknown, sets the error and returns a pair
-    // with .second = nullptr.  (p.first = nullptr is not an error: it becomes None).
-    PYBIND11_NOINLINE static std::pair<const void *, const type_info *> src_and_type(
-            const void *src, const std::type_info &cast_type, const std::type_info *rtti_type = nullptr) {
-        if (auto *tpi = get_type_info(cast_type))
-            return {src, const_cast<const type_info *>(tpi)};
-
-        // Not found, set error:
-        std::string tname = rtti_type ? rtti_type->name() : cast_type.name();
-        detail::clean_type_id(tname);
-        std::string msg = "Unregistered type : " + tname;
-        PyErr_SetString(PyExc_TypeError, msg.c_str());
-        return {nullptr, nullptr};
-    }
-
-    const type_info *typeinfo = nullptr;
-    const std::type_info *cpptype = nullptr;
-    void *value = nullptr;
-};
-
-/**
- * Determine suitable casting operator for pointer-or-lvalue-casting type casters.  The type caster
- * needs to provide `operator T*()` and `operator T&()` operators.
- *
- * If the type supports moving the value away via an `operator T&&() &&` method, it should use
- * `movable_cast_op_type` instead.
- */
-template <typename T>
-using cast_op_type =
-    conditional_t<std::is_pointer<remove_reference_t<T>>::value,
-        typename std::add_pointer<intrinsic_t<T>>::type,
-        typename std::add_lvalue_reference<intrinsic_t<T>>::type>;
+    template <typename T>
+    array(ShapeContainer shape, StridesContainer strides, const T *ptr, handle base = handle())
+        : array(pybind11::dtype::of<T>(), std::move(shape), std::move(strides), ptr, base) {}
 
-/**
- * Determine suitable casting operator for a type caster with a movable value.  Such a type caster
- * needs to provide `operator T*()`, `operator T&()`, and `operator T&&() &&`.  The latter will be
- * called in appropriate contexts where the value can be moved rather than copied.
- *
- * These operator are automatically provided when using the PYBIND11_TYPE_CASTER macro.
- */
-template <typename T>
-using movable_cast_op_type =
-    conditional_t<std::is_pointer<typename std::remove_reference<T>::type>::value,
-        typename std::add_pointer<intrinsic_t<T>>::type,
-    conditional_t<std::is_rvalue_reference<T>::value,
-        typename std::add_rvalue_reference<intrinsic_t<T>>::type,
-        typename std::add_lvalue_reference<intrinsic_t<T>>::type>>;
-
-// std::is_copy_constructible isn't quite enough: it lets std::vector<T> (and similar) through when
-// T is non-copyable, but code containing such a copy constructor fails to actually compile.
-template <typename T, typename SFINAE = void> struct is_copy_constructible : std::is_copy_constructible<T> {};
-
-// Specialization for types that appear to be copy constructible but also look like stl containers
-// (we specifically check for: has `value_type` and `reference` with `reference = value_type&`): if
-// so, copy constructability depends on whether the value_type is copy constructible.
-template <typename Container> struct is_copy_constructible<Container, enable_if_t<all_of<
-        std::is_copy_constructible<Container>,
-        std::is_same<typename Container::value_type &, typename Container::reference>,
-        // Avoid infinite recursion
-        negation<std::is_same<Container, typename Container::value_type>>
-    >::value>> : is_copy_constructible<typename Container::value_type> {};
-
-// Likewise for std::pair
-// (after C++17 it is mandatory that the copy constructor not exist when the two types aren't themselves
-// copy constructible, but this can not be relied upon when T1 or T2 are themselves containers).
-template <typename T1, typename T2> struct is_copy_constructible<std::pair<T1, T2>>
-    : all_of<is_copy_constructible<T1>, is_copy_constructible<T2>> {};
-
-// The same problems arise with std::is_copy_assignable, so we use the same workaround.
-template <typename T, typename SFINAE = void> struct is_copy_assignable : std::is_copy_assignable<T> {};
-template <typename Container> struct is_copy_assignable<Container, enable_if_t<all_of<
-        std::is_copy_assignable<Container>,
-        std::is_same<typename Container::value_type &, typename Container::reference>
-    >::value>> : is_copy_assignable<typename Container::value_type> {};
-template <typename T1, typename T2> struct is_copy_assignable<std::pair<T1, T2>>
-    : all_of<is_copy_assignable<T1>, is_copy_assignable<T2>> {};
-
-NAMESPACE_END(detail)
-
-// polymorphic_type_hook<itype>::get(src, tinfo) determines whether the object pointed
-// to by `src` actually is an instance of some class derived from `itype`.
-// If so, it sets `tinfo` to point to the std::type_info representing that derived
-// type, and returns a pointer to the start of the most-derived object of that type
-// (in which `src` is a subobject; this will be the same address as `src` in most
-// single inheritance cases). If not, or if `src` is nullptr, it simply returns `src`
-// and leaves `tinfo` at its default value of nullptr.
-//
-// The default polymorphic_type_hook just returns src. A specialization for polymorphic
-// types determines the runtime type of the passed object and adjusts the this-pointer
-// appropriately via dynamic_cast<void*>. This is what enables a C++ Animal* to appear
-// to Python as a Dog (if Dog inherits from Animal, Animal is polymorphic, Dog is
-// registered with pybind11, and this Animal is in fact a Dog).
-//
-// You may specialize polymorphic_type_hook yourself for types that want to appear
-// polymorphic to Python but do not use C++ RTTI. (This is a not uncommon pattern
-// in performance-sensitive applications, used most notably in LLVM.)
-//
-// polymorphic_type_hook_base allows users to specialize polymorphic_type_hook with
-// std::enable_if. User provided specializations will always have higher priority than
-// the default implementation and specialization provided in polymorphic_type_hook_base.
-template <typename itype, typename SFINAE = void>
-struct polymorphic_type_hook_base
-{
-    static const void *get(const itype *src, const std::type_info*&) { return src; }
-};
-template <typename itype>
-struct polymorphic_type_hook_base<itype, detail::enable_if_t<std::is_polymorphic<itype>::value>>
-{
-    static const void *get(const itype *src, const std::type_info*& type) {
-        type = src ? &typeid(*src) : nullptr;
-        return dynamic_cast<const void*>(src);
-    }
-};
-template <typename itype, typename SFINAE = void>
-struct polymorphic_type_hook : public polymorphic_type_hook_base<itype> {};
-
-NAMESPACE_BEGIN(detail)
-
-/// Generic type caster for objects stored on the heap
-template <typename type> class type_caster_base : public type_caster_generic {
-    using itype = intrinsic_t<type>;
+    template <typename T>
+    array(ShapeContainer shape, const T *ptr, handle base = handle())
+        : array(std::move(shape), {}, ptr, base) {}
 
-public:
-    static constexpr auto name = _<type>();
+    template <typename T>
+    explicit array(ssize_t count, const T *ptr, handle base = handle())
+        : array({count}, {}, ptr, base) {}
 
-    type_caster_base() : type_caster_base(typeid(type)) { }
-    explicit type_caster_base(const std::type_info &info) : type_caster_generic(info) { }
+    explicit array(const buffer_info &info, handle base = handle())
+        : array(pybind11::dtype(info), info.shape, info.strides, info.ptr, base) {}
 
-    static handle cast(const itype &src, return_value_policy policy, handle parent) {
-        if (policy == return_value_policy::automatic || policy == return_value_policy::automatic_reference)
-            policy = return_value_policy::copy;
-        return cast(&src, policy, parent);
-    }
-
-    static handle cast(itype &&src, return_value_policy, handle parent) {
-        return cast(&src, return_value_policy::move, parent);
-    }
-
-    // Returns a (pointer, type_info) pair taking care of necessary type lookup for a
-    // polymorphic type (using RTTI by default, but can be overridden by specializing
-    // polymorphic_type_hook). If the instance isn't derived, returns the base version.
-    static std::pair<const void *, const type_info *> src_and_type(const itype *src) {
-        auto &cast_type = typeid(itype);
-        const std::type_info *instance_type = nullptr;
-        const void *vsrc = polymorphic_type_hook<itype>::get(src, instance_type);
-        if (instance_type && !same_type(cast_type, *instance_type)) {
-            // This is a base pointer to a derived type. If the derived type is registered
-            // with pybind11, we want to make the full derived object available.
-            // In the typical case where itype is polymorphic, we get the correct
-            // derived pointer (which may be != base pointer) by a dynamic_cast to
-            // most derived type. If itype is not polymorphic, we won't get here
-            // except via a user-provided specialization of polymorphic_type_hook,
-            // and the user has promised that no this-pointer adjustment is
-            // required in that case, so it's OK to use static_cast.
-            if (const auto *tpi = get_type_info(*instance_type))
-                return {vsrc, tpi};
-        }
-        // Otherwise we have either a nullptr, an `itype` pointer, or an unknown derived pointer, so
-        // don't do a cast
-        return type_caster_generic::src_and_type(src, cast_type, instance_type);
-    }
-
-    static handle cast(const itype *src, return_value_policy policy, handle parent) {
-        auto st = src_and_type(src);
-        return type_caster_generic::cast(
-            st.first, policy, parent, st.second,
-            make_copy_constructor(src), make_move_constructor(src));
-    }
-
-    static handle cast_holder(const itype *src, const void *holder) {
-        auto st = src_and_type(src);
-        return type_caster_generic::cast(
-            st.first, return_value_policy::take_ownership, {}, st.second,
-            nullptr, nullptr, holder);
+    /// Array descriptor (dtype)
+    pybind11::dtype dtype() const {
+        return reinterpret_borrow<pybind11::dtype>(detail::array_proxy(m_ptr)->descr);
     }
 
-    template <typename T> using cast_op_type = detail::cast_op_type<T>;
-
-    operator itype*() { return (type *) value; }
-    operator itype&() { if (!value) throw reference_cast_error(); return *((itype *) value); }
-
-protected:
-    using Constructor = void *(*)(const void *);
-
-    /* Only enabled when the types are {copy,move}-constructible *and* when the type
-       does not have a private operator new implementation. */
-    template <typename T, typename = enable_if_t<is_copy_constructible<T>::value>>
-    static auto make_copy_constructor(const T *x) -> decltype(new T(*x), Constructor{}) {
-        return [](const void *arg) -> void * {
-            return new T(*reinterpret_cast<const T *>(arg));
-        };
+    /// Total number of elements
+    ssize_t size() const {
+        return std::accumulate(shape(), shape() + ndim(), (ssize_t) 1, std::multiplies<ssize_t>());
     }
 
-    template <typename T, typename = enable_if_t<std::is_move_constructible<T>::value>>
-    static auto make_move_constructor(const T *x) -> decltype(new T(std::move(*const_cast<T *>(x))), Constructor{}) {
-        return [](const void *arg) -> void * {
-            return new T(std::move(*const_cast<T *>(reinterpret_cast<const T *>(arg))));
-        };
+    /// Byte size of a single element
+    ssize_t itemsize() const {
+        return detail::array_descriptor_proxy(detail::array_proxy(m_ptr)->descr)->elsize;
     }
 
-    static Constructor make_copy_constructor(...) { return nullptr; }
-    static Constructor make_move_constructor(...) { return nullptr; }
-};
+    /// Total number of bytes
+    ssize_t nbytes() const { return size() * itemsize(); }
 
-template <typename type, typename SFINAE = void> class type_caster : public type_caster_base<type> { };
-template <typename type> using make_caster = type_caster<intrinsic_t<type>>;
-
-// Shortcut for calling a caster's `cast_op_type` cast operator for casting a type_caster to a T
-template <typename T> typename make_caster<T>::template cast_op_type<T> cast_op(make_caster<T> &caster) {
-    return caster.operator typename make_caster<T>::template cast_op_type<T>();
-}
-template <typename T> typename make_caster<T>::template cast_op_type<typename std::add_rvalue_reference<T>::type>
-cast_op(make_caster<T> &&caster) {
-    return std::move(caster).operator
-        typename make_caster<T>::template cast_op_type<typename std::add_rvalue_reference<T>::type>();
-}
+    /// Number of dimensions
+    ssize_t ndim() const { return detail::array_proxy(m_ptr)->nd; }
 
-template <typename type> class type_caster<std::reference_wrapper<type>> {
-private:
-    using caster_t = make_caster<type>;
-    caster_t subcaster;
-    using subcaster_cast_op_type = typename caster_t::template cast_op_type<type>;
-    static_assert(std::is_same<typename std::remove_const<type>::type &, subcaster_cast_op_type>::value,
-            "std::reference_wrapper<T> caster requires T to have a caster with an `T &` operator");
-public:
-    bool load(handle src, bool convert) { return subcaster.load(src, convert); }
-    static constexpr auto name = caster_t::name;
-    static handle cast(const std::reference_wrapper<type> &src, return_value_policy policy, handle parent) {
-        // It is definitely wrong to take ownership of this pointer, so mask that rvp
-        if (policy == return_value_policy::take_ownership || policy == return_value_policy::automatic)
-            policy = return_value_policy::automatic_reference;
-        return caster_t::cast(&src.get(), policy, parent);
-    }
-    template <typename T> using cast_op_type = std::reference_wrapper<type>;
-    operator std::reference_wrapper<type>() { return subcaster.operator subcaster_cast_op_type&(); }
-};
-
-#define PYBIND11_TYPE_CASTER(type, py_name) \
-    protected: \
-        type value; \
-    public: \
-        static constexpr auto name = py_name; \
-        template <typename T_, enable_if_t<std::is_same<type, remove_cv_t<T_>>::value, int> = 0> \
-        static handle cast(T_ *src, return_value_policy policy, handle parent) { \
-            if (!src) return none().release(); \
-            if (policy == return_value_policy::take_ownership) { \
-                auto h = cast(std::move(*src), policy, parent); delete src; return h; \
-            } else { \
-                return cast(*src, policy, parent); \
-            } \
-        } \
-        operator type*() { return &value; } \
-        operator type&() { return value; } \
-        operator type&&() && { return std::move(value); } \
-        template <typename T_> using cast_op_type = pybind11::detail::movable_cast_op_type<T_>
-
-
-template <typename CharT> using is_std_char_type = any_of<
-    std::is_same<CharT, char>, /* std::string */
-#if defined(PYBIND11_HAS_U8STRING)
-    std::is_same<CharT, char8_t>, /* std::u8string */
-#endif
-    std::is_same<CharT, char16_t>, /* std::u16string */
-    std::is_same<CharT, char32_t>, /* std::u32string */
-    std::is_same<CharT, wchar_t> /* std::wstring */
->;
+    /// Base object
+    object base() const { return reinterpret_borrow<object>(detail::array_proxy(m_ptr)->base); }
 
-template <typename T>
-struct type_caster<T, enable_if_t<std::is_arithmetic<T>::value && !is_std_char_type<T>::value>> {
-    using _py_type_0 = conditional_t<sizeof(T) <= sizeof(long), long, long long>;
-    using _py_type_1 = conditional_t<std::is_signed<T>::value, _py_type_0, typename std::make_unsigned<_py_type_0>::type>;
-    using py_type = conditional_t<std::is_floating_point<T>::value, double, _py_type_1>;
-public:
+    /// Dimensions of the array
+    const ssize_t *shape() const { return detail::array_proxy(m_ptr)->dimensions; }
 
-    bool load(handle src, bool convert) {
-        py_type py_value;
+    /// Dimension along a given axis
+    ssize_t shape(ssize_t dim) const {
+        if (dim >= ndim()) {
+            fail_dim_check(dim, "invalid axis");
+        }
+        return shape()[dim];
+    }
 
-        if (!src)
-            return false;
+    /// Strides of the array
+    const ssize_t *strides() const { return detail::array_proxy(m_ptr)->strides; }
 
-        if (std::is_floating_point<T>::value) {
-            if (convert || PyFloat_Check(src.ptr()))
-                py_value = (py_type) PyFloat_AsDouble(src.ptr());
-            else
-                return false;
-        } else if (PyFloat_Check(src.ptr())) {
-            return false;
-        } else if (std::is_unsigned<py_type>::value) {
-            py_value = as_unsigned<py_type>(src.ptr());
-        } else { // signed integer:
-            py_value = sizeof(T) <= sizeof(long)
-                ? (py_type) PyLong_AsLong(src.ptr())
-                : (py_type) PYBIND11_LONG_AS_LONGLONG(src.ptr());
-        }
-
-        bool py_err = py_value == (py_type) -1 && PyErr_Occurred();
-
-        // Protect std::numeric_limits::min/max with parentheses
-        if (py_err || (std::is_integral<T>::value && sizeof(py_type) != sizeof(T) &&
-                       (py_value < (py_type) (std::numeric_limits<T>::min)() ||
-                        py_value > (py_type) (std::numeric_limits<T>::max)()))) {
-            bool type_error = py_err && PyErr_ExceptionMatches(
-#if PY_VERSION_HEX < 0x03000000 && !defined(PYPY_VERSION)
-                PyExc_SystemError
-#else
-                PyExc_TypeError
-#endif
-            );
-            PyErr_Clear();
-            if (type_error && convert && PyNumber_Check(src.ptr())) {
-                auto tmp = reinterpret_steal<object>(std::is_floating_point<T>::value
-                                                     ? PyNumber_Float(src.ptr())
-                                                     : PyNumber_Long(src.ptr()));
-                PyErr_Clear();
-                return load(tmp, false);
-            }
-            return false;
+    /// Stride along a given axis
+    ssize_t strides(ssize_t dim) const {
+        if (dim >= ndim()) {
+            fail_dim_check(dim, "invalid axis");
         }
-
-        value = (T) py_value;
-        return true;
+        return strides()[dim];
     }
 
-    template<typename U = T>
-    static typename std::enable_if<std::is_floating_point<U>::value, handle>::type
-    cast(U src, return_value_policy /* policy */, handle /* parent */) {
-        return PyFloat_FromDouble((double) src);
-    }
+    /// Return the NumPy array flags
+    int flags() const { return detail::array_proxy(m_ptr)->flags; }
 
-    template<typename U = T>
-    static typename std::enable_if<!std::is_floating_point<U>::value && std::is_signed<U>::value && (sizeof(U) <= sizeof(long)), handle>::type
-    cast(U src, return_value_policy /* policy */, handle /* parent */) {
-        return PYBIND11_LONG_FROM_SIGNED((long) src);
+    /// If set, the array is writeable (otherwise the buffer is read-only)
+    bool writeable() const {
+        return detail::check_flags(m_ptr, detail::npy_api::NPY_ARRAY_WRITEABLE_);
     }
 
-    template<typename U = T>
-    static typename std::enable_if<!std::is_floating_point<U>::value && std::is_unsigned<U>::value && (sizeof(U) <= sizeof(unsigned long)), handle>::type
-    cast(U src, return_value_policy /* policy */, handle /* parent */) {
-        return PYBIND11_LONG_FROM_UNSIGNED((unsigned long) src);
+    /// If set, the array owns the data (will be freed when the array is deleted)
+    bool owndata() const {
+        return detail::check_flags(m_ptr, detail::npy_api::NPY_ARRAY_OWNDATA_);
     }
 
-    template<typename U = T>
-    static typename std::enable_if<!std::is_floating_point<U>::value && std::is_signed<U>::value && (sizeof(U) > sizeof(long)), handle>::type
-    cast(U src, return_value_policy /* policy */, handle /* parent */) {
-        return PyLong_FromLongLong((long long) src);
+    /// Pointer to the contained data. If index is not provided, points to the
+    /// beginning of the buffer. May throw if the index would lead to out of bounds access.
+    template <typename... Ix>
+    const void *data(Ix... index) const {
+        return static_cast<const void *>(detail::array_proxy(m_ptr)->data + offset_at(index...));
     }
 
-    template<typename U = T>
-    static typename std::enable_if<!std::is_floating_point<U>::value && std::is_unsigned<U>::value && (sizeof(U) > sizeof(unsigned long)), handle>::type
-    cast(U src, return_value_policy /* policy */, handle /* parent */) {
-        return PyLong_FromUnsignedLongLong((unsigned long long) src);
+    /// Mutable pointer to the contained data. If index is not provided, points to the
+    /// beginning of the buffer. May throw if the index would lead to out of bounds access.
+    /// May throw if the array is not writeable.
+    template <typename... Ix>
+    void *mutable_data(Ix... index) {
+        check_writeable();
+        return static_cast<void *>(detail::array_proxy(m_ptr)->data + offset_at(index...));
     }
 
-    PYBIND11_TYPE_CASTER(T, _<std::is_integral<T>::value>("int", "float"));
-};
-
-template<typename T> struct void_caster {
-public:
-    bool load(handle src, bool) {
-        if (src && src.is_none())
-            return true;
-        return false;
-    }
-    static handle cast(T, return_value_policy /* policy */, handle /* parent */) {
-        return none().inc_ref();
+    /// Byte offset from beginning of the array to a given index (full or partial).
+    /// May throw if the index would lead to out of bounds access.
+    template <typename... Ix>
+    ssize_t offset_at(Ix... index) const {
+        if ((ssize_t) sizeof...(index) > ndim()) {
+            fail_dim_check(sizeof...(index), "too many indices for an array");
+        }
+        return byte_offset(ssize_t(index)...);
     }
-    PYBIND11_TYPE_CASTER(T, _("None"));
-};
 
-template <> class type_caster<void_type> : public void_caster<void_type> {};
-
-template <> class type_caster<void> : public type_caster<void_type> {
-public:
-    using type_caster<void_type>::cast;
+    ssize_t offset_at() const { return 0; }
 
-    bool load(handle h, bool) {
-        if (!h) {
-            return false;
-        } else if (h.is_none()) {
-            value = nullptr;
-            return true;
-        }
+    /// Item count from beginning of the array to a given index (full or partial).
+    /// May throw if the index would lead to out of bounds access.
+    template <typename... Ix>
+    ssize_t index_at(Ix... index) const {
+        return offset_at(index...) / itemsize();
+    }
 
-        /* Check if this is a capsule */
-        if (isinstance<capsule>(h)) {
-            value = reinterpret_borrow<capsule>(h);
-            return true;
+    /**
+     * Returns a proxy object that provides access to the array's data without bounds or
+     * dimensionality checking.  Will throw if the array is missing the `writeable` flag.  Use with
+     * care: the array must not be destroyed or reshaped for the duration of the returned object,
+     * and the caller must take care not to access invalid dimensions or dimension indices.
+     */
+    template <typename T, ssize_t Dims = -1>
+    detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {
+        if (Dims >= 0 && ndim() != Dims) {
+            throw std::domain_error("array has incorrect number of dimensions: "
+                                    + std::to_string(ndim()) + "; expected "
+                                    + std::to_string(Dims));
         }
+        return detail::unchecked_mutable_reference<T, Dims>(
+            mutable_data(), shape(), strides(), ndim());
+    }
 
-        /* Check if this is a C++ type */
-        auto &bases = all_type_info((PyTypeObject *) h.get_type().ptr());
-        if (bases.size() == 1) { // Only allowing loading from a single-value type
-            value = values_and_holders(reinterpret_cast<instance *>(h.ptr())).begin()->value_ptr();
-            return true;
+    /**
+     * Returns a proxy object that provides const access to the array's data without bounds or
+     * dimensionality checking.  Unlike `mutable_unchecked()`, this does not require that the
+     * underlying array have the `writable` flag.  Use with care: the array must not be destroyed
+     * or reshaped for the duration of the returned object, and the caller must take care not to
+     * access invalid dimensions or dimension indices.
+     */
+    template <typename T, ssize_t Dims = -1>
+    detail::unchecked_reference<T, Dims> unchecked() const & {
+        if (Dims >= 0 && ndim() != Dims) {
+            throw std::domain_error("array has incorrect number of dimensions: "
+                                    + std::to_string(ndim()) + "; expected "
+                                    + std::to_string(Dims));
         }
-
-        /* Fail */
-        return false;
+        return detail::unchecked_reference<T, Dims>(data(), shape(), strides(), ndim());
     }
 
-    static handle cast(const void *ptr, return_value_policy /* policy */, handle /* parent */) {
-        if (ptr)
-            return capsule(ptr).release();
-        else
-            return none().inc_ref();
+    /// Return a new view with all of the dimensions of length 1 removed
+    array squeeze() {
+        auto &api = detail::npy_api::get();
+        return reinterpret_steal<array>(api.PyArray_Squeeze_(m_ptr));
     }
 
-    template <typename T> using cast_op_type = void*&;
-    operator void *&() { return value; }
-    static constexpr auto name = _("capsule");
-private:
-    void *value = nullptr;
-};
-
-template <> class type_caster<std::nullptr_t> : public void_caster<std::nullptr_t> { };
-
-template <> class type_caster<bool> {
-public:
-    bool load(handle src, bool convert) {
-        if (!src) return false;
-        else if (src.ptr() == Py_True) { value = true; return true; }
-        else if (src.ptr() == Py_False) { value = false; return true; }
-        else if (convert || !strcmp("numpy.bool_", Py_TYPE(src.ptr())->tp_name)) {
-            // (allow non-implicit conversion for numpy booleans)
-
-            Py_ssize_t res = -1;
-            if (src.is_none()) {
-                res = 0;  // None is implicitly converted to False
-            }
-            #if defined(PYPY_VERSION)
-            // On PyPy, check that "__bool__" (or "__nonzero__" on Python 2.7) attr exists
-            else if (hasattr(src, PYBIND11_BOOL_ATTR)) {
-                res = PyObject_IsTrue(src.ptr());
-            }
-            #else
-            // Alternate approach for CPython: this does the same as the above, but optimized
-            // using the CPython API so as to avoid an unneeded attribute lookup.
-            else if (auto tp_as_number = src.ptr()->ob_type->tp_as_number) {
-                if (PYBIND11_NB_BOOL(tp_as_number)) {
-                    res = (*PYBIND11_NB_BOOL(tp_as_number))(src.ptr());
-                }
-            }
-            #endif
-            if (res == 0 || res == 1) {
-                value = (bool) res;
-                return true;
-            } else {
-                PyErr_Clear();
-            }
+    /// Resize array to given shape
+    /// If refcheck is true and more that one reference exist to this array
+    /// then resize will succeed only if it makes a reshape, i.e. original size doesn't change
+    void resize(ShapeContainer new_shape, bool refcheck = true) {
+        detail::npy_api::PyArray_Dims d
+            = {// Use reinterpret_cast for PyPy on Windows (remove if fixed, checked on 7.3.1)
+               reinterpret_cast<Py_intptr_t *>(new_shape->data()),
+               int(new_shape->size())};
+        // try to resize, set ordering param to -1 cause it's not used anyway
+        auto new_array = reinterpret_steal<object>(
+            detail::npy_api::get().PyArray_Resize_(m_ptr, &d, int(refcheck), -1));
+        if (!new_array) {
+            throw error_already_set();
+        }
+        if (isinstance<array>(new_array)) {
+            *this = std::move(new_array);
         }
-        return false;
-    }
-    static handle cast(bool src, return_value_policy /* policy */, handle /* parent */) {
-        return handle(src ? Py_True : Py_False).inc_ref();
     }
-    PYBIND11_TYPE_CASTER(bool, _("bool"));
-};
 
-// Helper class for UTF-{8,16,32} C++ stl strings:
-template <typename StringType, bool IsView = false> struct string_caster {
-    using CharT = typename StringType::value_type;
+    /// Optional `order` parameter omitted, to be added as needed.
+    array reshape(ShapeContainer new_shape) {
+        detail::npy_api::PyArray_Dims d
+            = {reinterpret_cast<Py_intptr_t *>(new_shape->data()), int(new_shape->size())};
+        auto new_array
+            = reinterpret_steal<array>(detail::npy_api::get().PyArray_Newshape_(m_ptr, &d, 0));
+        if (!new_array) {
+            throw error_already_set();
+        }
+        return new_array;
+    }
 
-    // Simplify life by being able to assume standard char sizes (the standard only guarantees
-    // minimums, but Python requires exact sizes)
-    static_assert(!std::is_same<CharT, char>::value || sizeof(CharT) == 1, "Unsupported char size != 1");
-#if defined(PYBIND11_HAS_U8STRING)
-    static_assert(!std::is_same<CharT, char8_t>::value || sizeof(CharT) == 1, "Unsupported char8_t size != 1");
-#endif
-    static_assert(!std::is_same<CharT, char16_t>::value || sizeof(CharT) == 2, "Unsupported char16_t size != 2");
-    static_assert(!std::is_same<CharT, char32_t>::value || sizeof(CharT) == 4, "Unsupported char32_t size != 4");
-    // wchar_t can be either 16 bits (Windows) or 32 (everywhere else)
-    static_assert(!std::is_same<CharT, wchar_t>::value || sizeof(CharT) == 2 || sizeof(CharT) == 4,
-            "Unsupported wchar_t size != 2/4");
-    static constexpr size_t UTF_N = 8 * sizeof(CharT);
-
-    bool load(handle src, bool) {
-#if PY_MAJOR_VERSION < 3
-        object temp;
-#endif
-        handle load_src = src;
-        if (!src) {
-            return false;
-        } else if (!PyUnicode_Check(load_src.ptr())) {
-#if PY_MAJOR_VERSION >= 3
-            return load_bytes(load_src);
-#else
-            if (std::is_same<CharT, char>::value) {
-                return load_bytes(load_src);
-            }
+    /// Create a view of an array in a different data type.
+    /// This function may fundamentally reinterpret the data in the array.
+    /// It is the responsibility of the caller to ensure that this is safe.
+    /// Only supports the `dtype` argument, the `type` argument is omitted,
+    /// to be added as needed.
+    array view(const std::string &dtype) {
+        auto &api = detail::npy_api::get();
+        auto new_view = reinterpret_steal<array>(api.PyArray_View_(
+            m_ptr, dtype::from_args(pybind11::str(dtype)).release().ptr(), nullptr));
+        if (!new_view) {
+            throw error_already_set();
+        }
+        return new_view;
+    }
 
-            // The below is a guaranteed failure in Python 3 when PyUnicode_Check returns false
-            if (!PYBIND11_BYTES_CHECK(load_src.ptr()))
-                return false;
-
-            temp = reinterpret_steal<object>(PyUnicode_FromObject(load_src.ptr()));
-            if (!temp) { PyErr_Clear(); return false; }
-            load_src = temp;
-#endif
+    /// Ensure that the argument is a NumPy array
+    /// In case of an error, nullptr is returned and the Python error is cleared.
+    static array ensure(handle h, int ExtraFlags = 0) {
+        auto result = reinterpret_steal<array>(raw_array(h.ptr(), ExtraFlags));
+        if (!result) {
+            PyErr_Clear();
         }
+        return result;
+    }
 
-        object utfNbytes = reinterpret_steal<object>(PyUnicode_AsEncodedString(
-            load_src.ptr(), UTF_N == 8 ? "utf-8" : UTF_N == 16 ? "utf-16" : "utf-32", nullptr));
-        if (!utfNbytes) { PyErr_Clear(); return false; }
+protected:
+    template <typename, typename>
+    friend struct detail::npy_format_descriptor;
 
-        const CharT *buffer = reinterpret_cast<const CharT *>(PYBIND11_BYTES_AS_STRING(utfNbytes.ptr()));
-        size_t length = (size_t) PYBIND11_BYTES_SIZE(utfNbytes.ptr()) / sizeof(CharT);
-        if (UTF_N > 8) { buffer++; length--; } // Skip BOM for UTF-16/32
-        value = StringType(buffer, length);
+    void fail_dim_check(ssize_t dim, const std::string &msg) const {
+        throw index_error(msg + ": " + std::to_string(dim) + " (ndim = " + std::to_string(ndim())
+                          + ')');
+    }
 
-        // If we're loading a string_view we need to keep the encoded Python object alive:
-        if (IsView)
-            loader_life_support::add_patient(utfNbytes);
+    template <typename... Ix>
+    ssize_t byte_offset(Ix... index) const {
+        check_dimensions(index...);
+        return detail::byte_offset_unsafe(strides(), ssize_t(index)...);
+    }
 
-        return true;
+    void check_writeable() const {
+        if (!writeable()) {
+            throw std::domain_error("array is not writeable");
+        }
     }
 
-    static handle cast(const StringType &src, return_value_policy /* policy */, handle /* parent */) {
-        const char *buffer = reinterpret_cast<const char *>(src.data());
-        ssize_t nbytes = ssize_t(src.size() * sizeof(CharT));
-        handle s = decode_utfN(buffer, nbytes);
-        if (!s) throw error_already_set();
-        return s;
+    template <typename... Ix>
+    void check_dimensions(Ix... index) const {
+        check_dimensions_impl(ssize_t(0), shape(), ssize_t(index)...);
     }
 
-    PYBIND11_TYPE_CASTER(StringType, _(PYBIND11_STRING_NAME));
+    void check_dimensions_impl(ssize_t, const ssize_t *) const {}
 
-private:
-    static handle decode_utfN(const char *buffer, ssize_t nbytes) {
-#if !defined(PYPY_VERSION)
-        return
-            UTF_N == 8  ? PyUnicode_DecodeUTF8(buffer, nbytes, nullptr) :
-            UTF_N == 16 ? PyUnicode_DecodeUTF16(buffer, nbytes, nullptr, nullptr) :
-                          PyUnicode_DecodeUTF32(buffer, nbytes, nullptr, nullptr);
-#else
-        // PyPy seems to have multiple problems related to PyUnicode_UTF*: the UTF8 version
-        // sometimes segfaults for unknown reasons, while the UTF16 and 32 versions require a
-        // non-const char * arguments, which is also a nuisance, so bypass the whole thing by just
-        // passing the encoding as a string value, which works properly:
-        return PyUnicode_Decode(buffer, nbytes, UTF_N == 8 ? "utf-8" : UTF_N == 16 ? "utf-16" : "utf-32", nullptr);
-#endif
+    template <typename... Ix>
+    void check_dimensions_impl(ssize_t axis, const ssize_t *shape, ssize_t i, Ix... index) const {
+        if (i >= *shape) {
+            throw index_error(std::string("index ") + std::to_string(i)
+                              + " is out of bounds for axis " + std::to_string(axis)
+                              + " with size " + std::to_string(*shape));
+        }
+        check_dimensions_impl(axis + 1, shape + 1, index...);
     }
 
-    // When loading into a std::string or char*, accept a bytes object as-is (i.e.
-    // without any encoding/decoding attempt).  For other C++ char sizes this is a no-op.
-    // which supports loading a unicode from a str, doesn't take this path.
-    template <typename C = CharT>
-    bool load_bytes(enable_if_t<std::is_same<C, char>::value, handle> src) {
-        if (PYBIND11_BYTES_CHECK(src.ptr())) {
-            // We were passed a Python 3 raw bytes; accept it into a std::string or char*
-            // without any encoding attempt.
-            const char *bytes = PYBIND11_BYTES_AS_STRING(src.ptr());
-            if (bytes) {
-                value = StringType(bytes, (size_t) PYBIND11_BYTES_SIZE(src.ptr()));
-                return true;
-            }
+    /// Create array from any object -- always returns a new reference
+    static PyObject *raw_array(PyObject *ptr, int ExtraFlags = 0) {
+        if (ptr == nullptr) {
+            PyErr_SetString(PyExc_ValueError, "cannot create a pybind11::array from a nullptr");
+            return nullptr;
         }
-
-        return false;
+        return detail::npy_api::get().PyArray_FromAny_(
+            ptr, nullptr, 0, 0, detail::npy_api::NPY_ARRAY_ENSUREARRAY_ | ExtraFlags, nullptr);
     }
-
-    template <typename C = CharT>
-    bool load_bytes(enable_if_t<!std::is_same<C, char>::value, handle>) { return false; }
 };
 
-template <typename CharT, class Traits, class Allocator>
-struct type_caster<std::basic_string<CharT, Traits, Allocator>, enable_if_t<is_std_char_type<CharT>::value>>
-    : string_caster<std::basic_string<CharT, Traits, Allocator>> {};
-
-#ifdef PYBIND11_HAS_STRING_VIEW
-template <typename CharT, class Traits>
-struct type_caster<std::basic_string_view<CharT, Traits>, enable_if_t<is_std_char_type<CharT>::value>>
-    : string_caster<std::basic_string_view<CharT, Traits>, true> {};
-#endif
+template <typename T, int ExtraFlags = array::forcecast>
+class array_t : public array {
+private:
+    struct private_ctor {};
+    // Delegating constructor needed when both moving and accessing in the same constructor
+    array_t(private_ctor,
+            ShapeContainer &&shape,
+            StridesContainer &&strides,
+            const T *ptr,
+            handle base)
+        : array(std::move(shape), std::move(strides), ptr, base) {}
 
-// Type caster for C-style strings.  We basically use a std::string type caster, but also add the
-// ability to use None as a nullptr char* (which the string caster doesn't allow).
-template <typename CharT> struct type_caster<CharT, enable_if_t<is_std_char_type<CharT>::value>> {
-    using StringType = std::basic_string<CharT>;
-    using StringCaster = type_caster<StringType>;
-    StringCaster str_caster;
-    bool none = false;
-    CharT one_char = 0;
 public:
-    bool load(handle src, bool convert) {
-        if (!src) return false;
-        if (src.is_none()) {
-            // Defer accepting None to other overloads (if we aren't in convert mode):
-            if (!convert) return false;
-            none = true;
-            return true;
-        }
-        return str_caster.load(src, convert);
-    }
-
-    static handle cast(const CharT *src, return_value_policy policy, handle parent) {
-        if (src == nullptr) return pybind11::none().inc_ref();
-        return StringCaster::cast(StringType(src), policy, parent);
-    }
-
-    static handle cast(CharT src, return_value_policy policy, handle parent) {
-        if (std::is_same<char, CharT>::value) {
-            handle s = PyUnicode_DecodeLatin1((const char *) &src, 1, nullptr);
-            if (!s) throw error_already_set();
-            return s;
-        }
-        return StringCaster::cast(StringType(1, src), policy, parent);
-    }
-
-    operator CharT*() { return none ? nullptr : const_cast<CharT *>(static_cast<StringType &>(str_caster).c_str()); }
-    operator CharT&() {
-        if (none)
-            throw value_error("Cannot convert None to a character");
-
-        auto &value = static_cast<StringType &>(str_caster);
-        size_t str_len = value.size();
-        if (str_len == 0)
-            throw value_error("Cannot convert empty string to a character");
-
-        // If we're in UTF-8 mode, we have two possible failures: one for a unicode character that
-        // is too high, and one for multiple unicode characters (caught later), so we need to figure
-        // out how long the first encoded character is in bytes to distinguish between these two
-        // errors.  We also allow want to allow unicode characters U+0080 through U+00FF, as those
-        // can fit into a single char value.
-        if (StringCaster::UTF_N == 8 && str_len > 1 && str_len <= 4) {
-            unsigned char v0 = static_cast<unsigned char>(value[0]);
-            size_t char0_bytes = !(v0 & 0x80) ? 1 : // low bits only: 0-127
-                (v0 & 0xE0) == 0xC0 ? 2 : // 0b110xxxxx - start of 2-byte sequence
-                (v0 & 0xF0) == 0xE0 ? 3 : // 0b1110xxxx - start of 3-byte sequence
-                4; // 0b11110xxx - start of 4-byte sequence
-
-            if (char0_bytes == str_len) {
-                // If we have a 128-255 value, we can decode it into a single char:
-                if (char0_bytes == 2 && (v0 & 0xFC) == 0xC0) { // 0x110000xx 0x10xxxxxx
-                    one_char = static_cast<CharT>(((v0 & 3) << 6) + (static_cast<unsigned char>(value[1]) & 0x3F));
-                    return one_char;
-                }
-                // Otherwise we have a single character, but it's > U+00FF
-                throw value_error("Character code point not in range(0x100)");
-            }
-        }
+    static_assert(!detail::array_info<T>::is_array, "Array types cannot be used with array_t");
 
-        // UTF-16 is much easier: we can only have a surrogate pair for values above U+FFFF, thus a
-        // surrogate pair with total length 2 instantly indicates a range error (but not a "your
-        // string was too long" error).
-        else if (StringCaster::UTF_N == 16 && str_len == 2) {
-            one_char = static_cast<CharT>(value[0]);
-            if (one_char >= 0xD800 && one_char < 0xE000)
-                throw value_error("Character code point not in range(0x10000)");
-        }
+    using value_type = T;
 
-        if (str_len != 1)
-            throw value_error("Expected a character, but multi-character string found");
+    array_t() : array(0, static_cast<const T *>(nullptr)) {}
+    array_t(handle h, borrowed_t) : array(h, borrowed_t{}) {}
+    array_t(handle h, stolen_t) : array(h, stolen_t{}) {}
 
-        one_char = value[0];
-        return one_char;
+    PYBIND11_DEPRECATED("Use array_t<T>::ensure() instead")
+    array_t(handle h, bool is_borrowed) : array(raw_array_t(h.ptr()), stolen_t{}) {
+        if (!m_ptr) {
+            PyErr_Clear();
+        }
+        if (!is_borrowed) {
+            Py_XDECREF(h.ptr());
+        }
     }
 
-    static constexpr auto name = _(PYBIND11_STRING_NAME);
-    template <typename _T> using cast_op_type = pybind11::detail::cast_op_type<_T>;
-};
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    array_t(const object &o) : array(raw_array_t(o.ptr()), stolen_t{}) {
+        if (!m_ptr) {
+            throw error_already_set();
+        }
+    }
 
-// Base implementation for std::tuple and std::pair
-template <template<typename...> class Tuple, typename... Ts> class tuple_caster {
-    using type = Tuple<Ts...>;
-    static constexpr auto size = sizeof...(Ts);
-    using indices = make_index_sequence<size>;
-public:
+    explicit array_t(const buffer_info &info, handle base = handle()) : array(info, base) {}
 
-    bool load(handle src, bool convert) {
-        if (!isinstance<sequence>(src))
-            return false;
-        const auto seq = reinterpret_borrow<sequence>(src);
-        if (seq.size() != size)
-            return false;
-        return load_impl(seq, convert, indices{});
+    array_t(ShapeContainer shape,
+            StridesContainer strides,
+            const T *ptr = nullptr,
+            handle base = handle())
+        : array(std::move(shape), std::move(strides), ptr, base) {}
+
+    explicit array_t(ShapeContainer shape, const T *ptr = nullptr, handle base = handle())
+        : array_t(private_ctor{},
+                  std::move(shape),
+                  (ExtraFlags & f_style) != 0 ? detail::f_strides(*shape, itemsize())
+                                              : detail::c_strides(*shape, itemsize()),
+                  ptr,
+                  base) {}
+
+    explicit array_t(ssize_t count, const T *ptr = nullptr, handle base = handle())
+        : array({count}, {}, ptr, base) {}
+
+    constexpr ssize_t itemsize() const { return sizeof(T); }
+
+    template <typename... Ix>
+    ssize_t index_at(Ix... index) const {
+        return offset_at(index...) / itemsize();
+    }
+
+    template <typename... Ix>
+    const T *data(Ix... index) const {
+        return static_cast<const T *>(array::data(index...));
+    }
+
+    template <typename... Ix>
+    T *mutable_data(Ix... index) {
+        return static_cast<T *>(array::mutable_data(index...));
+    }
+
+    // Reference to element at a given index
+    template <typename... Ix>
+    const T &at(Ix... index) const {
+        if ((ssize_t) sizeof...(index) != ndim()) {
+            fail_dim_check(sizeof...(index), "index dimension mismatch");
+        }
+        return *(static_cast<const T *>(array::data())
+                 + byte_offset(ssize_t(index)...) / itemsize());
+    }
+
+    // Mutable reference to element at a given index
+    template <typename... Ix>
+    T &mutable_at(Ix... index) {
+        if ((ssize_t) sizeof...(index) != ndim()) {
+            fail_dim_check(sizeof...(index), "index dimension mismatch");
+        }
+        return *(static_cast<T *>(array::mutable_data())
+                 + byte_offset(ssize_t(index)...) / itemsize());
+    }
+
+    /**
+     * Returns a proxy object that provides access to the array's data without bounds or
+     * dimensionality checking.  Will throw if the array is missing the `writeable` flag.  Use with
+     * care: the array must not be destroyed or reshaped for the duration of the returned object,
+     * and the caller must take care not to access invalid dimensions or dimension indices.
+     */
+    template <ssize_t Dims = -1>
+    detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {
+        return array::mutable_unchecked<T, Dims>();
+    }
+
+    /**
+     * Returns a proxy object that provides const access to the array's data without bounds or
+     * dimensionality checking.  Unlike `mutable_unchecked()`, this does not require that the
+     * underlying array have the `writable` flag.  Use with care: the array must not be destroyed
+     * or reshaped for the duration of the returned object, and the caller must take care not to
+     * access invalid dimensions or dimension indices.
+     */
+    template <ssize_t Dims = -1>
+    detail::unchecked_reference<T, Dims> unchecked() const & {
+        return array::unchecked<T, Dims>();
+    }
+
+    /// Ensure that the argument is a NumPy array of the correct dtype (and if not, try to convert
+    /// it).  In case of an error, nullptr is returned and the Python error is cleared.
+    static array_t ensure(handle h) {
+        auto result = reinterpret_steal<array_t>(raw_array_t(h.ptr()));
+        if (!result) {
+            PyErr_Clear();
+        }
+        return result;
     }
 
-    template <typename T>
-    static handle cast(T &&src, return_value_policy policy, handle parent) {
-        return cast_impl(std::forward<T>(src), policy, parent, indices{});
+    static bool check_(handle h) {
+        const auto &api = detail::npy_api::get();
+        return api.PyArray_Check_(h.ptr())
+               && api.PyArray_EquivTypes_(detail::array_proxy(h.ptr())->descr,
+                                          dtype::of<T>().ptr())
+               && detail::check_flags(h.ptr(), ExtraFlags & (array::c_style | array::f_style));
     }
 
-    static constexpr auto name = _("Tuple[") + concat(make_caster<Ts>::name...) + _("]");
-
-    template <typename T> using cast_op_type = type;
-
-    operator type() & { return implicit_cast(indices{}); }
-    operator type() && { return std::move(*this).implicit_cast(indices{}); }
-
 protected:
-    template <size_t... Is>
-    type implicit_cast(index_sequence<Is...>) & { return type(cast_op<Ts>(std::get<Is>(subcasters))...); }
-    template <size_t... Is>
-    type implicit_cast(index_sequence<Is...>) && { return type(cast_op<Ts>(std::move(std::get<Is>(subcasters)))...); }
-
-    static constexpr bool load_impl(const sequence &, bool, index_sequence<>) { return true; }
-
-    template <size_t... Is>
-    bool load_impl(const sequence &seq, bool convert, index_sequence<Is...>) {
-#ifdef __cpp_fold_expressions
-        if ((... || !std::get<Is>(subcasters).load(seq[Is], convert)))
-            return false;
-#else
-        for (bool r : {std::get<Is>(subcasters).load(seq[Is], convert)...})
-            if (!r)
-                return false;
-#endif
-        return true;
+    /// Create array from any object -- always returns a new reference
+    static PyObject *raw_array_t(PyObject *ptr) {
+        if (ptr == nullptr) {
+            PyErr_SetString(PyExc_ValueError, "cannot create a pybind11::array_t from a nullptr");
+            return nullptr;
+        }
+        return detail::npy_api::get().PyArray_FromAny_(ptr,
+                                                       dtype::of<T>().release().ptr(),
+                                                       0,
+                                                       0,
+                                                       detail::npy_api::NPY_ARRAY_ENSUREARRAY_
+                                                           | ExtraFlags,
+                                                       nullptr);
     }
-
-    /* Implementation: Convert a C++ tuple into a Python tuple */
-    template <typename T, size_t... Is>
-    static handle cast_impl(T &&src, return_value_policy policy, handle parent, index_sequence<Is...>) {
-        std::array<object, size> entries{{
-            reinterpret_steal<object>(make_caster<Ts>::cast(std::get<Is>(std::forward<T>(src)), policy, parent))...
-        }};
-        for (const auto &entry: entries)
-            if (!entry)
-                return handle();
-        tuple result(size);
-        int counter = 0;
-        for (auto & entry: entries)
-            PyTuple_SET_ITEM(result.ptr(), counter++, entry.release().ptr());
-        return result.release();
-    }
-
-    Tuple<make_caster<Ts>...> subcasters;
 };
 
-template <typename T1, typename T2> class type_caster<std::pair<T1, T2>>
-    : public tuple_caster<std::pair, T1, T2> {};
-
-template <typename... Ts> class type_caster<std::tuple<Ts...>>
-    : public tuple_caster<std::tuple, Ts...> {};
-
-/// Helper class which abstracts away certain actions. Users can provide specializations for
-/// custom holders, but it's only necessary if the type has a non-standard interface.
 template <typename T>
-struct holder_helper {
-    static auto get(const T &p) -> decltype(p.get()) { return p.get(); }
-};
-
-/// Type caster for holder types like std::shared_ptr, etc.
-template <typename type, typename holder_type>
-struct copyable_holder_caster : public type_caster_base<type> {
-public:
-    using base = type_caster_base<type>;
-    static_assert(std::is_base_of<base, type_caster<type>>::value,
-            "Holder classes are only supported for custom types");
-    using base::base;
-    using base::cast;
-    using base::typeinfo;
-    using base::value;
-
-    bool load(handle src, bool convert) {
-        return base::template load_impl<copyable_holder_caster<type, holder_type>>(src, convert);
-    }
-
-    explicit operator type*() { return this->value; }
-    explicit operator type&() { return *(this->value); }
-    explicit operator holder_type*() { return std::addressof(holder); }
-
-    // Workaround for Intel compiler bug
-    // see pybind11 issue 94
-    #if defined(__ICC) || defined(__INTEL_COMPILER)
-    operator holder_type&() { return holder; }
-    #else
-    explicit operator holder_type&() { return holder; }
-    #endif
-
-    static handle cast(const holder_type &src, return_value_policy, handle) {
-        const auto *ptr = holder_helper<holder_type>::get(src);
-        return type_caster_base<type>::cast_holder(ptr, &src);
+struct format_descriptor<T, detail::enable_if_t<detail::is_pod_struct<T>::value>> {
+    static std::string format() {
+        return detail::npy_format_descriptor<typename std::remove_cv<T>::type>::format();
     }
+};
 
-protected:
-    friend class type_caster_generic;
-    void check_holder_compat() {
-        if (typeinfo->default_holder)
-            throw cast_error("Unable to load a custom holder type from a default-holder instance");
-    }
+template <size_t N>
+struct format_descriptor<char[N]> {
+    static std::string format() { return std::to_string(N) + 's'; }
+};
+template <size_t N>
+struct format_descriptor<std::array<char, N>> {
+    static std::string format() { return std::to_string(N) + 's'; }
+};
 
-    bool load_value(value_and_holder &&v_h) {
-        if (v_h.holder_constructed()) {
-            value = v_h.value_ptr();
-            holder = v_h.template holder<holder_type>();
-            return true;
-        } else {
-            throw cast_error("Unable to cast from non-held to held instance (T& to Holder<T>) "
-#if defined(NDEBUG)
-                             "(compile in debug mode for type information)");
-#else
-                             "of type '" + type_id<holder_type>() + "''");
-#endif
-        }
+template <typename T>
+struct format_descriptor<T, detail::enable_if_t<std::is_enum<T>::value>> {
+    static std::string format() {
+        return format_descriptor<
+            typename std::remove_cv<typename std::underlying_type<T>::type>::type>::format();
     }
+};
 
-    template <typename T = holder_type, detail::enable_if_t<!std::is_constructible<T, const T &, type*>::value, int> = 0>
-    bool try_implicit_casts(handle, bool) { return false; }
-
-    template <typename T = holder_type, detail::enable_if_t<std::is_constructible<T, const T &, type*>::value, int> = 0>
-    bool try_implicit_casts(handle src, bool convert) {
-        for (auto &cast : typeinfo->implicit_casts) {
-            copyable_holder_caster sub_caster(*cast.first);
-            if (sub_caster.load(src, convert)) {
-                value = cast.second(sub_caster.value);
-                holder = holder_type(sub_caster.holder, (type *) value);
-                return true;
-            }
-        }
-        return false;
+template <typename T>
+struct format_descriptor<T, detail::enable_if_t<detail::array_info<T>::is_array>> {
+    static std::string format() {
+        using namespace detail;
+        static constexpr auto extents = const_name("(") + array_info<T>::extents + const_name(")");
+        return extents.text + format_descriptor<remove_all_extents_t<T>>::format();
     }
-
-    static bool try_direct_conversions(handle) { return false; }
-
-
-    holder_type holder;
 };
 
-/// Specialize for the common std::shared_ptr, so users don't need to
-template <typename T>
-class type_caster<std::shared_ptr<T>> : public copyable_holder_caster<T, std::shared_ptr<T>> { };
+PYBIND11_NAMESPACE_BEGIN(detail)
+template <typename T, int ExtraFlags>
+struct pyobject_caster<array_t<T, ExtraFlags>> {
+    using type = array_t<T, ExtraFlags>;
 
-template <typename type, typename holder_type>
-struct move_only_holder_caster {
-    static_assert(std::is_base_of<type_caster_base<type>, type_caster<type>>::value,
-            "Holder classes are only supported for custom types");
-
-    static handle cast(holder_type &&src, return_value_policy, handle) {
-        auto *ptr = holder_helper<holder_type>::get(src);
-        return type_caster_base<type>::cast_holder(ptr, std::addressof(src));
-    }
-    static constexpr auto name = type_caster_base<type>::name;
-};
-
-template <typename type, typename deleter>
-class type_caster<std::unique_ptr<type, deleter>>
-    : public move_only_holder_caster<type, std::unique_ptr<type, deleter>> { };
-
-template <typename type, typename holder_type>
-using type_caster_holder = conditional_t<is_copy_constructible<holder_type>::value,
-                                         copyable_holder_caster<type, holder_type>,
-                                         move_only_holder_caster<type, holder_type>>;
-
-template <typename T, bool Value = false> struct always_construct_holder { static constexpr bool value = Value; };
-
-/// Create a specialization for custom holder types (silently ignores std::shared_ptr)
-#define PYBIND11_DECLARE_HOLDER_TYPE(type, holder_type, ...) \
-    namespace pybind11 { namespace detail { \
-    template <typename type> \
-    struct always_construct_holder<holder_type> : always_construct_holder<void, ##__VA_ARGS__>  { }; \
-    template <typename type> \
-    class type_caster<holder_type, enable_if_t<!is_shared_ptr<holder_type>::value>> \
-        : public type_caster_holder<type, holder_type> { }; \
-    }}
-
-// PYBIND11_DECLARE_HOLDER_TYPE holder types:
-template <typename base, typename holder> struct is_holder_type :
-    std::is_base_of<detail::type_caster_holder<base, holder>, detail::type_caster<holder>> {};
-// Specialization for always-supported unique_ptr holders:
-template <typename base, typename deleter> struct is_holder_type<base, std::unique_ptr<base, deleter>> :
-    std::true_type {};
-
-template <typename T> struct handle_type_name { static constexpr auto name = _<T>(); };
-template <> struct handle_type_name<bytes> { static constexpr auto name = _(PYBIND11_BYTES_NAME); };
-template <> struct handle_type_name<args> { static constexpr auto name = _("*args"); };
-template <> struct handle_type_name<kwargs> { static constexpr auto name = _("**kwargs"); };
-
-template <typename type>
-struct pyobject_caster {
-    template <typename T = type, enable_if_t<std::is_same<T, handle>::value, int> = 0>
-    bool load(handle src, bool /* convert */) { value = src; return static_cast<bool>(value); }
-
-    template <typename T = type, enable_if_t<std::is_base_of<object, T>::value, int> = 0>
-    bool load(handle src, bool /* convert */) {
-        if (!isinstance<type>(src))
+    bool load(handle src, bool convert) {
+        if (!convert && !type::check_(src)) {
             return false;
-        value = reinterpret_borrow<type>(src);
-        return true;
+        }
+        value = type::ensure(src);
+        return static_cast<bool>(value);
     }
 
     static handle cast(const handle &src, return_value_policy /* policy */, handle /* parent */) {
         return src.inc_ref();
     }
     PYBIND11_TYPE_CASTER(type, handle_type_name<type>::name);
 };
 
 template <typename T>
-class type_caster<T, enable_if_t<is_pyobject<T>::value>> : public pyobject_caster<T> { };
-
-// Our conditions for enabling moving are quite restrictive:
-// At compile time:
-// - T needs to be a non-const, non-pointer, non-reference type
-// - type_caster<T>::operator T&() must exist
-// - the type must be move constructible (obviously)
-// At run-time:
-// - if the type is non-copy-constructible, the object must be the sole owner of the type (i.e. it
-//   must have ref_count() == 1)h
-// If any of the above are not satisfied, we fall back to copying.
-template <typename T> using move_is_plain_type = satisfies_none_of<T,
-    std::is_void, std::is_pointer, std::is_reference, std::is_const
->;
-template <typename T, typename SFINAE = void> struct move_always : std::false_type {};
-template <typename T> struct move_always<T, enable_if_t<all_of<
-    move_is_plain_type<T>,
-    negation<is_copy_constructible<T>>,
-    std::is_move_constructible<T>,
-    std::is_same<decltype(std::declval<make_caster<T>>().operator T&()), T&>
->::value>> : std::true_type {};
-template <typename T, typename SFINAE = void> struct move_if_unreferenced : std::false_type {};
-template <typename T> struct move_if_unreferenced<T, enable_if_t<all_of<
-    move_is_plain_type<T>,
-    negation<move_always<T>>,
-    std::is_move_constructible<T>,
-    std::is_same<decltype(std::declval<make_caster<T>>().operator T&()), T&>
->::value>> : std::true_type {};
-template <typename T> using move_never = none_of<move_always<T>, move_if_unreferenced<T>>;
-
-// Detect whether returning a `type` from a cast on type's type_caster is going to result in a
-// reference or pointer to a local variable of the type_caster.  Basically, only
-// non-reference/pointer `type`s and reference/pointers from a type_caster_generic are safe;
-// everything else returns a reference/pointer to a local variable.
-template <typename type> using cast_is_temporary_value_reference = bool_constant<
-    (std::is_reference<type>::value || std::is_pointer<type>::value) &&
-    !std::is_base_of<type_caster_generic, make_caster<type>>::value &&
-    !std::is_same<intrinsic_t<type>, void>::value
->;
-
-// When a value returned from a C++ function is being cast back to Python, we almost always want to
-// force `policy = move`, regardless of the return value policy the function/method was declared
-// with.
-template <typename Return, typename SFINAE = void> struct return_value_policy_override {
-    static return_value_policy policy(return_value_policy p) { return p; }
-};
-
-template <typename Return> struct return_value_policy_override<Return,
-        detail::enable_if_t<std::is_base_of<type_caster_generic, make_caster<Return>>::value, void>> {
-    static return_value_policy policy(return_value_policy p) {
-        return !std::is_lvalue_reference<Return>::value &&
-               !std::is_pointer<Return>::value
-                   ? return_value_policy::move : p;
+struct compare_buffer_info<T, detail::enable_if_t<detail::is_pod_struct<T>::value>> {
+    static bool compare(const buffer_info &b) {
+        return npy_api::get().PyArray_EquivTypes_(dtype::of<T>().ptr(), dtype(b).ptr());
     }
 };
 
-// Basic python -> C++ casting; throws if casting fails
-template <typename T, typename SFINAE> type_caster<T, SFINAE> &load_type(type_caster<T, SFINAE> &conv, const handle &handle) {
-    if (!conv.load(handle, true)) {
-#if defined(NDEBUG)
-        throw cast_error("Unable to cast Python instance to C++ type (compile in debug mode for details)");
-#else
-        throw cast_error("Unable to cast Python instance of type " +
-            (std::string) str(handle.get_type()) + " to C++ type '" + type_id<T>() + "'");
-#endif
-    }
-    return conv;
-}
-// Wrapper around the above that also constructs and returns a type_caster
-template <typename T> make_caster<T> load_type(const handle &handle) {
-    make_caster<T> conv;
-    load_type(conv, handle);
-    return conv;
-}
-
-NAMESPACE_END(detail)
-
-// pytype -> C++ type
-template <typename T, detail::enable_if_t<!detail::is_pyobject<T>::value, int> = 0>
-T cast(const handle &handle) {
-    using namespace detail;
-    static_assert(!cast_is_temporary_value_reference<T>::value,
-            "Unable to cast type to reference: value is local to type caster");
-    return cast_op<T>(load_type<T>(handle));
-}
-
-// pytype -> pytype (calls converting constructor)
-template <typename T, detail::enable_if_t<detail::is_pyobject<T>::value, int> = 0>
-T cast(const handle &handle) { return T(reinterpret_borrow<object>(handle)); }
-
-// C++ type -> py::object
-template <typename T, detail::enable_if_t<!detail::is_pyobject<T>::value, int> = 0>
-object cast(const T &value, return_value_policy policy = return_value_policy::automatic_reference,
-            handle parent = handle()) {
-    if (policy == return_value_policy::automatic)
-        policy = std::is_pointer<T>::value ? return_value_policy::take_ownership : return_value_policy::copy;
-    else if (policy == return_value_policy::automatic_reference)
-        policy = std::is_pointer<T>::value ? return_value_policy::reference : return_value_policy::copy;
-    return reinterpret_steal<object>(detail::make_caster<T>::cast(value, policy, parent));
-}
+template <typename T, typename = void>
+struct npy_format_descriptor_name;
 
-template <typename T> T handle::cast() const { return pybind11::cast<T>(*this); }
-template <> inline void handle::cast() const { return; }
+template <typename T>
+struct npy_format_descriptor_name<T, enable_if_t<std::is_integral<T>::value>> {
+    static constexpr auto name = const_name<std::is_same<T, bool>::value>(
+        const_name("bool"),
+        const_name<std::is_signed<T>::value>("numpy.int", "numpy.uint")
+            + const_name<sizeof(T) * 8>());
+};
 
 template <typename T>
-detail::enable_if_t<!detail::move_never<T>::value, T> move(object &&obj) {
-    if (obj.ref_count() > 1)
-#if defined(NDEBUG)
-        throw cast_error("Unable to cast Python instance to C++ rvalue: instance has multiple references"
-            " (compile in debug mode for details)");
-#else
-        throw cast_error("Unable to move from Python " + (std::string) str(obj.get_type()) +
-                " instance to C++ " + type_id<T>() + " instance: instance has multiple references");
-#endif
+struct npy_format_descriptor_name<T, enable_if_t<std::is_floating_point<T>::value>> {
+    static constexpr auto name = const_name < std::is_same<T, float>::value
+                                 || std::is_same<T, const float>::value
+                                 || std::is_same<T, double>::value
+                                 || std::is_same<T, const double>::value
+                                        > (const_name("numpy.float") + const_name<sizeof(T) * 8>(),
+                                           const_name("numpy.longdouble"));
+};
 
-    // Move into a temporary and return that, because the reference may be a local value of `conv`
-    T ret = std::move(detail::load_type<T>(obj).operator T&());
-    return ret;
-}
+template <typename T>
+struct npy_format_descriptor_name<T, enable_if_t<is_complex<T>::value>> {
+    static constexpr auto name = const_name < std::is_same<typename T::value_type, float>::value
+                                 || std::is_same<typename T::value_type, const float>::value
+                                 || std::is_same<typename T::value_type, double>::value
+                                 || std::is_same<typename T::value_type, const double>::value
+                                        > (const_name("numpy.complex")
+                                               + const_name<sizeof(typename T::value_type) * 16>(),
+                                           const_name("numpy.longcomplex"));
+};
 
-// Calling cast() on an rvalue calls pybind::cast with the object rvalue, which does:
-// - If we have to move (because T has no copy constructor), do it.  This will fail if the moved
-//   object has multiple references, but trying to copy will fail to compile.
-// - If both movable and copyable, check ref count: if 1, move; otherwise copy
-// - Otherwise (not movable), copy.
-template <typename T> detail::enable_if_t<detail::move_always<T>::value, T> cast(object &&object) {
-    return move<T>(std::move(object));
-}
-template <typename T> detail::enable_if_t<detail::move_if_unreferenced<T>::value, T> cast(object &&object) {
-    if (object.ref_count() > 1)
-        return cast<T>(object);
-    else
-        return move<T>(std::move(object));
-}
-template <typename T> detail::enable_if_t<detail::move_never<T>::value, T> cast(object &&object) {
-    return cast<T>(object);
-}
+template <typename T>
+struct npy_format_descriptor<
+    T,
+    enable_if_t<satisfies_any_of<T, std::is_arithmetic, is_complex>::value>>
+    : npy_format_descriptor_name<T> {
+private:
+    // NB: the order here must match the one in common.h
+    constexpr static const int values[15] = {npy_api::NPY_BOOL_,
+                                             npy_api::NPY_BYTE_,
+                                             npy_api::NPY_UBYTE_,
+                                             npy_api::NPY_INT16_,
+                                             npy_api::NPY_UINT16_,
+                                             npy_api::NPY_INT32_,
+                                             npy_api::NPY_UINT32_,
+                                             npy_api::NPY_INT64_,
+                                             npy_api::NPY_UINT64_,
+                                             npy_api::NPY_FLOAT_,
+                                             npy_api::NPY_DOUBLE_,
+                                             npy_api::NPY_LONGDOUBLE_,
+                                             npy_api::NPY_CFLOAT_,
+                                             npy_api::NPY_CDOUBLE_,
+                                             npy_api::NPY_CLONGDOUBLE_};
 
-template <typename T> T object::cast() const & { return pybind11::cast<T>(*this); }
-template <typename T> T object::cast() && { return pybind11::cast<T>(std::move(*this)); }
-template <> inline void object::cast() const & { return; }
-template <> inline void object::cast() && { return; }
-
-NAMESPACE_BEGIN(detail)
-
-// Declared in pytypes.h:
-template <typename T, enable_if_t<!is_pyobject<T>::value, int>>
-object object_or_cast(T &&o) { return pybind11::cast(std::forward<T>(o)); }
-
-struct overload_unused {}; // Placeholder type for the unneeded (and dead code) static variable in the OVERLOAD_INT macro
-template <typename ret_type> using overload_caster_t = conditional_t<
-    cast_is_temporary_value_reference<ret_type>::value, make_caster<ret_type>, overload_unused>;
-
-// Trampoline use: for reference/pointer types to value-converted values, we do a value cast, then
-// store the result in the given variable.  For other types, this is a no-op.
-template <typename T> enable_if_t<cast_is_temporary_value_reference<T>::value, T> cast_ref(object &&o, make_caster<T> &caster) {
-    return cast_op<T>(load_type(caster, o));
-}
-template <typename T> enable_if_t<!cast_is_temporary_value_reference<T>::value, T> cast_ref(object &&, overload_unused &) {
-    pybind11_fail("Internal error: cast_ref fallback invoked"); }
+public:
+    static constexpr int value = values[detail::is_fmt_numeric<T>::index];
 
-// Trampoline use: Having a pybind11::cast with an invalid reference type is going to static_assert, even
-// though if it's in dead code, so we provide a "trampoline" to pybind11::cast that only does anything in
-// cases where pybind11::cast is valid.
-template <typename T> enable_if_t<!cast_is_temporary_value_reference<T>::value, T> cast_safe(object &&o) {
-    return pybind11::cast<T>(std::move(o)); }
-template <typename T> enable_if_t<cast_is_temporary_value_reference<T>::value, T> cast_safe(object &&) {
-    pybind11_fail("Internal error: cast_safe fallback invoked"); }
-template <> inline void cast_safe<void>(object &&) {}
-
-NAMESPACE_END(detail)
-
-template <return_value_policy policy = return_value_policy::automatic_reference>
-tuple make_tuple() { return tuple(0); }
-
-template <return_value_policy policy = return_value_policy::automatic_reference,
-          typename... Args> tuple make_tuple(Args&&... args_) {
-    constexpr size_t size = sizeof...(Args);
-    std::array<object, size> args {
-        { reinterpret_steal<object>(detail::make_caster<Args>::cast(
-            std::forward<Args>(args_), policy, nullptr))... }
-    };
-    for (size_t i = 0; i < args.size(); i++) {
-        if (!args[i]) {
-#if defined(NDEBUG)
-            throw cast_error("make_tuple(): unable to convert arguments to Python object (compile in debug mode for details)");
-#else
-            std::array<std::string, size> argtypes { {type_id<Args>()...} };
-            throw cast_error("make_tuple(): unable to convert argument of type '" +
-                argtypes[i] + "' to Python object");
-#endif
+    static pybind11::dtype dtype() {
+        if (auto *ptr = npy_api::get().PyArray_DescrFromType_(value)) {
+            return reinterpret_steal<pybind11::dtype>(ptr);
         }
+        pybind11_fail("Unsupported buffer format!");
     }
-    tuple result(size);
-    int counter = 0;
-    for (auto &arg_value : args)
-        PyTuple_SET_ITEM(result.ptr(), counter++, arg_value.release().ptr());
-    return result;
-}
+};
+
+#define PYBIND11_DECL_CHAR_FMT                                                                    \
+    static constexpr auto name = const_name("S") + const_name<N>();                               \
+    static pybind11::dtype dtype() {                                                              \
+        return pybind11::dtype(std::string("S") + std::to_string(N));                             \
+    }
+template <size_t N>
+struct npy_format_descriptor<char[N]> {
+    PYBIND11_DECL_CHAR_FMT
+};
+template <size_t N>
+struct npy_format_descriptor<std::array<char, N>> {
+    PYBIND11_DECL_CHAR_FMT
+};
+#undef PYBIND11_DECL_CHAR_FMT
 
-/// \ingroup annotations
-/// Annotation for arguments
-struct arg {
-    /// Constructs an argument with the name of the argument; if null or omitted, this is a positional argument.
-    constexpr explicit arg(const char *name = nullptr) : name(name), flag_noconvert(false), flag_none(true) { }
-    /// Assign a value to this argument
-    template <typename T> arg_v operator=(T &&value) const;
-    /// Indicate that the type should not be converted in the type caster
-    arg &noconvert(bool flag = true) { flag_noconvert = flag; return *this; }
-    /// Indicates that the argument should/shouldn't allow None (e.g. for nullable pointer args)
-    arg &none(bool flag = true) { flag_none = flag; return *this; }
-
-    const char *name; ///< If non-null, this is a named kwargs argument
-    bool flag_noconvert : 1; ///< If set, do not allow conversion (requires a supporting type caster!)
-    bool flag_none : 1; ///< If set (the default), allow None to be passed to this argument
-};
-
-/// \ingroup annotations
-/// Annotation for arguments with values
-struct arg_v : arg {
+template <typename T>
+struct npy_format_descriptor<T, enable_if_t<array_info<T>::is_array>> {
 private:
-    template <typename T>
-    arg_v(arg &&base, T &&x, const char *descr = nullptr)
-        : arg(base),
-          value(reinterpret_steal<object>(
-              detail::make_caster<T>::cast(x, return_value_policy::automatic, {})
-          )),
-          descr(descr)
-#if !defined(NDEBUG)
-        , type(type_id<T>())
-#endif
-    { }
+    using base_descr = npy_format_descriptor<typename array_info<T>::type>;
 
 public:
-    /// Direct construction with name, default, and description
-    template <typename T>
-    arg_v(const char *name, T &&x, const char *descr = nullptr)
-        : arg_v(arg(name), std::forward<T>(x), descr) { }
+    static_assert(!array_info<T>::is_empty, "Zero-sized arrays are not supported");
 
-    /// Called internally when invoking `py::arg("a") = value`
-    template <typename T>
-    arg_v(const arg &base, T &&x, const char *descr = nullptr)
-        : arg_v(arg(base), std::forward<T>(x), descr) { }
-
-    /// Same as `arg::noconvert()`, but returns *this as arg_v&, not arg&
-    arg_v &noconvert(bool flag = true) { arg::noconvert(flag); return *this; }
+    static constexpr auto name
+        = const_name("(") + array_info<T>::extents + const_name(")") + base_descr::name;
+    static pybind11::dtype dtype() {
+        list shape;
+        array_info<T>::append_extents(shape);
+        return pybind11::dtype::from_args(
+            pybind11::make_tuple(base_descr::dtype(), std::move(shape)));
+    }
+};
 
-    /// Same as `arg::nonone()`, but returns *this as arg_v&, not arg&
-    arg_v &none(bool flag = true) { arg::none(flag); return *this; }
+template <typename T>
+struct npy_format_descriptor<T, enable_if_t<std::is_enum<T>::value>> {
+private:
+    using base_descr = npy_format_descriptor<typename std::underlying_type<T>::type>;
 
-    /// The default value
-    object value;
-    /// The (optional) description of the default value
-    const char *descr;
-#if !defined(NDEBUG)
-    /// The C++ type name of the default value (only available when compiled in debug mode)
-    std::string type;
-#endif
+public:
+    static constexpr auto name = base_descr::name;
+    static pybind11::dtype dtype() { return base_descr::dtype(); }
 };
 
-/// \ingroup annotations
-/// Annotation indicating that all following arguments are keyword-only; the is the equivalent of an
-/// unnamed '*' argument (in Python 3)
-struct kwonly {};
-
-template <typename T>
-arg_v arg::operator=(T &&value) const { return {std::move(*this), std::forward<T>(value)}; }
+struct field_descriptor {
+    const char *name;
+    ssize_t offset;
+    ssize_t size;
+    std::string format;
+    dtype descr;
+};
+
+PYBIND11_NOINLINE void register_structured_dtype(any_container<field_descriptor> fields,
+                                                 const std::type_info &tinfo,
+                                                 ssize_t itemsize,
+                                                 bool (*direct_converter)(PyObject *, void *&)) {
+
+    auto &numpy_internals = get_numpy_internals();
+    if (numpy_internals.get_type_info(tinfo, false)) {
+        pybind11_fail("NumPy: dtype is already registered");
+    }
+
+    // Use ordered fields because order matters as of NumPy 1.14:
+    // https://docs.scipy.org/doc/numpy/release.html#multiple-field-indexing-assignment-of-structured-arrays
+    std::vector<field_descriptor> ordered_fields(std::move(fields));
+    std::sort(
+        ordered_fields.begin(),
+        ordered_fields.end(),
+        [](const field_descriptor &a, const field_descriptor &b) { return a.offset < b.offset; });
+
+    list names, formats, offsets;
+    for (auto &field : ordered_fields) {
+        if (!field.descr) {
+            pybind11_fail(std::string("NumPy: unsupported field dtype: `") + field.name + "` @ "
+                          + tinfo.name());
+        }
+        names.append(pybind11::str(field.name));
+        formats.append(field.descr);
+        offsets.append(pybind11::int_(field.offset));
+    }
+    auto *dtype_ptr
+        = pybind11::dtype(std::move(names), std::move(formats), std::move(offsets), itemsize)
+              .release()
+              .ptr();
+
+    // There is an existing bug in NumPy (as of v1.11): trailing bytes are
+    // not encoded explicitly into the format string. This will supposedly
+    // get fixed in v1.12; for further details, see these:
+    // - https://github.com/numpy/numpy/issues/7797
+    // - https://github.com/numpy/numpy/pull/7798
+    // Because of this, we won't use numpy's logic to generate buffer format
+    // strings and will just do it ourselves.
+    ssize_t offset = 0;
+    std::ostringstream oss;
+    // mark the structure as unaligned with '^', because numpy and C++ don't
+    // always agree about alignment (particularly for complex), and we're
+    // explicitly listing all our padding. This depends on none of the fields
+    // overriding the endianness. Putting the ^ in front of individual fields
+    // isn't guaranteed to work due to https://github.com/numpy/numpy/issues/9049
+    oss << "^T{";
+    for (auto &field : ordered_fields) {
+        if (field.offset > offset) {
+            oss << (field.offset - offset) << 'x';
+        }
+        oss << field.format << ':' << field.name << ':';
+        offset = field.offset + field.size;
+    }
+    if (itemsize > offset) {
+        oss << (itemsize - offset) << 'x';
+    }
+    oss << '}';
+    auto format_str = oss.str();
+
+    // Smoke test: verify that NumPy properly parses our buffer format string
+    auto &api = npy_api::get();
+    auto arr = array(buffer_info(nullptr, itemsize, format_str, 1));
+    if (!api.PyArray_EquivTypes_(dtype_ptr, arr.dtype().ptr())) {
+        pybind11_fail("NumPy: invalid buffer descriptor!");
+    }
+
+    auto tindex = std::type_index(tinfo);
+    numpy_internals.registered_dtypes[tindex] = {dtype_ptr, std::move(format_str)};
+    get_internals().direct_conversions[tindex].push_back(direct_converter);
+}
+
+template <typename T, typename SFINAE>
+struct npy_format_descriptor {
+    static_assert(is_pod_struct<T>::value,
+                  "Attempt to use a non-POD or unimplemented POD type as a numpy dtype");
+
+    static constexpr auto name = make_caster<T>::name;
+
+    static pybind11::dtype dtype() { return reinterpret_borrow<pybind11::dtype>(dtype_ptr()); }
+
+    static std::string format() {
+        static auto format_str = get_numpy_internals().get_type_info<T>(true)->format_str;
+        return format_str;
+    }
+
+    static void register_dtype(any_container<field_descriptor> fields) {
+        register_structured_dtype(std::move(fields),
+                                  typeid(typename std::remove_cv<T>::type),
+                                  sizeof(T),
+                                  &direct_converter);
+    }
 
-/// Alias for backward compatibility -- to be removed in version 2.0
-template <typename /*unused*/> using arg_t = arg_v;
+private:
+    static PyObject *dtype_ptr() {
+        static PyObject *ptr = get_numpy_internals().get_type_info<T>(true)->dtype_ptr;
+        return ptr;
+    }
 
-inline namespace literals {
-/** \rst
-    String literal version of `arg`
- \endrst */
-constexpr arg operator"" _a(const char *name, size_t) { return arg(name); }
-}
+    static bool direct_converter(PyObject *obj, void *&value) {
+        auto &api = npy_api::get();
+        if (!PyObject_TypeCheck(obj, api.PyVoidArrType_Type_)) {
+            return false;
+        }
+        if (auto descr = reinterpret_steal<object>(api.PyArray_DescrFromScalar_(obj))) {
+            if (api.PyArray_EquivTypes_(dtype_ptr(), descr.ptr())) {
+                value = ((PyVoidScalarObject_Proxy *) obj)->obval;
+                return true;
+            }
+        }
+        return false;
+    }
+};
 
-NAMESPACE_BEGIN(detail)
+#ifdef __CLION_IDE__ // replace heavy macro with dummy code for the IDE (doesn't affect code)
+#    define PYBIND11_NUMPY_DTYPE(Type, ...) ((void) 0)
+#    define PYBIND11_NUMPY_DTYPE_EX(Type, ...) ((void) 0)
+#else
 
-// forward declaration (definition in attr.h)
-struct function_record;
+#    define PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, Name)                                          \
+        ::pybind11::detail::field_descriptor {                                                    \
+            Name, offsetof(T, Field), sizeof(decltype(std::declval<T>().Field)),                  \
+                ::pybind11::format_descriptor<decltype(std::declval<T>().Field)>::format(),       \
+                ::pybind11::detail::npy_format_descriptor<                                        \
+                    decltype(std::declval<T>().Field)>::dtype()                                   \
+        }
+
+// Extract name, offset and format descriptor for a struct field
+#    define PYBIND11_FIELD_DESCRIPTOR(T, Field) PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, #Field)
+
+// The main idea of this macro is borrowed from https://github.com/swansontec/map-macro
+// (C) William Swanson, Paul Fultz
+#    define PYBIND11_EVAL0(...) __VA_ARGS__
+#    define PYBIND11_EVAL1(...) PYBIND11_EVAL0(PYBIND11_EVAL0(PYBIND11_EVAL0(__VA_ARGS__)))
+#    define PYBIND11_EVAL2(...) PYBIND11_EVAL1(PYBIND11_EVAL1(PYBIND11_EVAL1(__VA_ARGS__)))
+#    define PYBIND11_EVAL3(...) PYBIND11_EVAL2(PYBIND11_EVAL2(PYBIND11_EVAL2(__VA_ARGS__)))
+#    define PYBIND11_EVAL4(...) PYBIND11_EVAL3(PYBIND11_EVAL3(PYBIND11_EVAL3(__VA_ARGS__)))
+#    define PYBIND11_EVAL(...) PYBIND11_EVAL4(PYBIND11_EVAL4(PYBIND11_EVAL4(__VA_ARGS__)))
+#    define PYBIND11_MAP_END(...)
+#    define PYBIND11_MAP_OUT
+#    define PYBIND11_MAP_COMMA ,
+#    define PYBIND11_MAP_GET_END() 0, PYBIND11_MAP_END
+#    define PYBIND11_MAP_NEXT0(test, next, ...) next PYBIND11_MAP_OUT
+#    define PYBIND11_MAP_NEXT1(test, next) PYBIND11_MAP_NEXT0(test, next, 0)
+#    define PYBIND11_MAP_NEXT(test, next) PYBIND11_MAP_NEXT1(PYBIND11_MAP_GET_END test, next)
+#    if defined(_MSC_VER)                                                                         \
+        && !defined(__clang__) // MSVC is not as eager to expand macros, hence this workaround
+#        define PYBIND11_MAP_LIST_NEXT1(test, next)                                               \
+            PYBIND11_EVAL0(PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0))
+#    else
+#        define PYBIND11_MAP_LIST_NEXT1(test, next)                                               \
+            PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0)
+#    endif
+#    define PYBIND11_MAP_LIST_NEXT(test, next)                                                    \
+        PYBIND11_MAP_LIST_NEXT1(PYBIND11_MAP_GET_END test, next)
+#    define PYBIND11_MAP_LIST0(f, t, x, peek, ...)                                                \
+        f(t, x) PYBIND11_MAP_LIST_NEXT(peek, PYBIND11_MAP_LIST1)(f, t, peek, __VA_ARGS__)
+#    define PYBIND11_MAP_LIST1(f, t, x, peek, ...)                                                \
+        f(t, x) PYBIND11_MAP_LIST_NEXT(peek, PYBIND11_MAP_LIST0)(f, t, peek, __VA_ARGS__)
+// PYBIND11_MAP_LIST(f, t, a1, a2, ...) expands to f(t, a1), f(t, a2), ...
+#    define PYBIND11_MAP_LIST(f, t, ...)                                                          \
+        PYBIND11_EVAL(PYBIND11_MAP_LIST1(f, t, __VA_ARGS__, (), 0))
+
+#    define PYBIND11_NUMPY_DTYPE(Type, ...)                                                       \
+        ::pybind11::detail::npy_format_descriptor<Type>::register_dtype(                          \
+            ::std::vector<::pybind11::detail::field_descriptor>{                                  \
+                PYBIND11_MAP_LIST(PYBIND11_FIELD_DESCRIPTOR, Type, __VA_ARGS__)})
+
+#    if defined(_MSC_VER) && !defined(__clang__)
+#        define PYBIND11_MAP2_LIST_NEXT1(test, next)                                              \
+            PYBIND11_EVAL0(PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0))
+#    else
+#        define PYBIND11_MAP2_LIST_NEXT1(test, next)                                              \
+            PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0)
+#    endif
+#    define PYBIND11_MAP2_LIST_NEXT(test, next)                                                   \
+        PYBIND11_MAP2_LIST_NEXT1(PYBIND11_MAP_GET_END test, next)
+#    define PYBIND11_MAP2_LIST0(f, t, x1, x2, peek, ...)                                          \
+        f(t, x1, x2) PYBIND11_MAP2_LIST_NEXT(peek, PYBIND11_MAP2_LIST1)(f, t, peek, __VA_ARGS__)
+#    define PYBIND11_MAP2_LIST1(f, t, x1, x2, peek, ...)                                          \
+        f(t, x1, x2) PYBIND11_MAP2_LIST_NEXT(peek, PYBIND11_MAP2_LIST0)(f, t, peek, __VA_ARGS__)
+// PYBIND11_MAP2_LIST(f, t, a1, a2, ...) expands to f(t, a1, a2), f(t, a3, a4), ...
+#    define PYBIND11_MAP2_LIST(f, t, ...)                                                         \
+        PYBIND11_EVAL(PYBIND11_MAP2_LIST1(f, t, __VA_ARGS__, (), 0))
+
+#    define PYBIND11_NUMPY_DTYPE_EX(Type, ...)                                                    \
+        ::pybind11::detail::npy_format_descriptor<Type>::register_dtype(                          \
+            ::std::vector<::pybind11::detail::field_descriptor>{                                  \
+                PYBIND11_MAP2_LIST(PYBIND11_FIELD_DESCRIPTOR_EX, Type, __VA_ARGS__)})
 
-/// Internal data associated with a single function call
-struct function_call {
-    function_call(const function_record &f, handle p); // Implementation in attr.h
+#endif // __CLION_IDE__
 
-    /// The function data:
-    const function_record &func;
+class common_iterator {
+public:
+    using container_type = std::vector<ssize_t>;
+    using value_type = container_type::value_type;
+    using size_type = container_type::size_type;
 
-    /// Arguments passed to the function:
-    std::vector<handle> args;
+    common_iterator() : m_strides() {}
 
-    /// The `convert` value the arguments should be loaded with
-    std::vector<bool> args_convert;
+    common_iterator(void *ptr, const container_type &strides, const container_type &shape)
+        : p_ptr(reinterpret_cast<char *>(ptr)), m_strides(strides.size()) {
+        m_strides.back() = static_cast<value_type>(strides.back());
+        for (size_type i = m_strides.size() - 1; i != 0; --i) {
+            size_type j = i - 1;
+            auto s = static_cast<value_type>(shape[i]);
+            m_strides[j] = strides[j] + m_strides[i] - strides[i] * s;
+        }
+    }
 
-    /// Extra references for the optional `py::args` and/or `py::kwargs` arguments (which, if
-    /// present, are also in `args` but without a reference).
-    object args_ref, kwargs_ref;
+    void increment(size_type dim) { p_ptr += m_strides[dim]; }
 
-    /// The parent, if any
-    handle parent;
+    void *data() const { return p_ptr; }
 
-    /// If this is a call to an initializer, this argument contains `self`
-    handle init_self;
+private:
+    char *p_ptr{nullptr};
+    container_type m_strides;
 };
 
+template <size_t N>
+class multi_array_iterator {
+public:
+    using container_type = std::vector<ssize_t>;
 
-/// Helper class which loads arguments for C++ functions called from Python
-template <typename... Args>
-class argument_loader {
-    using indices = make_index_sequence<sizeof...(Args)>;
+    multi_array_iterator(const std::array<buffer_info, N> &buffers, const container_type &shape)
+        : m_shape(shape.size()), m_index(shape.size(), 0), m_common_iterator() {
 
-    template <typename Arg> using argument_is_args   = std::is_same<intrinsic_t<Arg>, args>;
-    template <typename Arg> using argument_is_kwargs = std::is_same<intrinsic_t<Arg>, kwargs>;
-    // Get args/kwargs argument positions relative to the end of the argument list:
-    static constexpr auto args_pos = constexpr_first<argument_is_args, Args...>() - (int) sizeof...(Args),
-                        kwargs_pos = constexpr_first<argument_is_kwargs, Args...>() - (int) sizeof...(Args);
+        // Manual copy to avoid conversion warning if using std::copy
+        for (size_t i = 0; i < shape.size(); ++i) {
+            m_shape[i] = shape[i];
+        }
 
-    static constexpr bool args_kwargs_are_last = kwargs_pos >= - 1 && args_pos >= kwargs_pos - 1;
+        container_type strides(shape.size());
+        for (size_t i = 0; i < N; ++i) {
+            init_common_iterator(buffers[i], shape, m_common_iterator[i], strides);
+        }
+    }
+
+    multi_array_iterator &operator++() {
+        for (size_t j = m_index.size(); j != 0; --j) {
+            size_t i = j - 1;
+            if (++m_index[i] != m_shape[i]) {
+                increment_common_iterator(i);
+                break;
+            }
+            m_index[i] = 0;
+        }
+        return *this;
+    }
 
-    static_assert(args_kwargs_are_last, "py::args/py::kwargs are only permitted as the last argument(s) of a function");
+    template <size_t K, class T = void>
+    T *data() const {
+        return reinterpret_cast<T *>(m_common_iterator[K].data());
+    }
 
-public:
-    static constexpr bool has_kwargs = kwargs_pos < 0;
-    static constexpr bool has_args = args_pos < 0;
+private:
+    using common_iter = common_iterator;
 
-    static constexpr auto arg_names = concat(type_descr(make_caster<Args>::name)...);
+    void init_common_iterator(const buffer_info &buffer,
+                              const container_type &shape,
+                              common_iter &iterator,
+                              container_type &strides) {
+        auto buffer_shape_iter = buffer.shape.rbegin();
+        auto buffer_strides_iter = buffer.strides.rbegin();
+        auto shape_iter = shape.rbegin();
+        auto strides_iter = strides.rbegin();
+
+        while (buffer_shape_iter != buffer.shape.rend()) {
+            if (*shape_iter == *buffer_shape_iter) {
+                *strides_iter = *buffer_strides_iter;
+            } else {
+                *strides_iter = 0;
+            }
 
-    bool load_args(function_call &call) {
-        return load_impl_sequence(call, indices{});
+            ++buffer_shape_iter;
+            ++buffer_strides_iter;
+            ++shape_iter;
+            ++strides_iter;
+        }
+
+        std::fill(strides_iter, strides.rend(), 0);
+        iterator = common_iter(buffer.ptr, strides, shape);
+    }
+
+    void increment_common_iterator(size_t dim) {
+        for (auto &iter : m_common_iterator) {
+            iter.increment(dim);
+        }
     }
 
-    template <typename Return, typename Guard, typename Func>
-    enable_if_t<!std::is_void<Return>::value, Return> call(Func &&f) && {
-        return std::move(*this).template call_impl<Return>(std::forward<Func>(f), indices{}, Guard{});
+    container_type m_shape;
+    container_type m_index;
+    std::array<common_iter, N> m_common_iterator;
+};
+
+enum class broadcast_trivial { non_trivial, c_trivial, f_trivial };
+
+// Populates the shape and number of dimensions for the set of buffers.  Returns a
+// broadcast_trivial enum value indicating whether the broadcast is "trivial"--that is, has each
+// buffer being either a singleton or a full-size, C-contiguous (`c_trivial`) or Fortran-contiguous
+// (`f_trivial`) storage buffer; returns `non_trivial` otherwise.
+template <size_t N>
+broadcast_trivial
+broadcast(const std::array<buffer_info, N> &buffers, ssize_t &ndim, std::vector<ssize_t> &shape) {
+    ndim = std::accumulate(
+        buffers.begin(), buffers.end(), ssize_t(0), [](ssize_t res, const buffer_info &buf) {
+            return std::max(res, buf.ndim);
+        });
+
+    shape.clear();
+    shape.resize((size_t) ndim, 1);
+
+    // Figure out the output size, and make sure all input arrays conform (i.e. are either size 1
+    // or the full size).
+    for (size_t i = 0; i < N; ++i) {
+        auto res_iter = shape.rbegin();
+        auto end = buffers[i].shape.rend();
+        for (auto shape_iter = buffers[i].shape.rbegin(); shape_iter != end;
+             ++shape_iter, ++res_iter) {
+            const auto &dim_size_in = *shape_iter;
+            auto &dim_size_out = *res_iter;
+
+            // Each input dimension can either be 1 or `n`, but `n` values must match across
+            // buffers
+            if (dim_size_out == 1) {
+                dim_size_out = dim_size_in;
+            } else if (dim_size_in != 1 && dim_size_in != dim_size_out) {
+                pybind11_fail("pybind11::vectorize: incompatible size/dimension of inputs!");
+            }
+        }
     }
 
-    template <typename Return, typename Guard, typename Func>
-    enable_if_t<std::is_void<Return>::value, void_type> call(Func &&f) && {
-        std::move(*this).template call_impl<Return>(std::forward<Func>(f), indices{}, Guard{});
-        return void_type();
+    bool trivial_broadcast_c = true;
+    bool trivial_broadcast_f = true;
+    for (size_t i = 0; i < N && (trivial_broadcast_c || trivial_broadcast_f); ++i) {
+        if (buffers[i].size == 1) {
+            continue;
+        }
+
+        // Require the same number of dimensions:
+        if (buffers[i].ndim != ndim) {
+            return broadcast_trivial::non_trivial;
+        }
+
+        // Require all dimensions be full-size:
+        if (!std::equal(buffers[i].shape.cbegin(), buffers[i].shape.cend(), shape.cbegin())) {
+            return broadcast_trivial::non_trivial;
+        }
+
+        // Check for C contiguity (but only if previous inputs were also C contiguous)
+        if (trivial_broadcast_c) {
+            ssize_t expect_stride = buffers[i].itemsize;
+            auto end = buffers[i].shape.crend();
+            for (auto shape_iter = buffers[i].shape.crbegin(),
+                      stride_iter = buffers[i].strides.crbegin();
+                 trivial_broadcast_c && shape_iter != end;
+                 ++shape_iter, ++stride_iter) {
+                if (expect_stride == *stride_iter) {
+                    expect_stride *= *shape_iter;
+                } else {
+                    trivial_broadcast_c = false;
+                }
+            }
+        }
+
+        // Check for Fortran contiguity (if previous inputs were also F contiguous)
+        if (trivial_broadcast_f) {
+            ssize_t expect_stride = buffers[i].itemsize;
+            auto end = buffers[i].shape.cend();
+            for (auto shape_iter = buffers[i].shape.cbegin(),
+                      stride_iter = buffers[i].strides.cbegin();
+                 trivial_broadcast_f && shape_iter != end;
+                 ++shape_iter, ++stride_iter) {
+                if (expect_stride == *stride_iter) {
+                    expect_stride *= *shape_iter;
+                } else {
+                    trivial_broadcast_f = false;
+                }
+            }
+        }
     }
 
-private:
+    return trivial_broadcast_c   ? broadcast_trivial::c_trivial
+           : trivial_broadcast_f ? broadcast_trivial::f_trivial
+                                 : broadcast_trivial::non_trivial;
+}
 
-    static bool load_impl_sequence(function_call &, index_sequence<>) { return true; }
+template <typename T>
+struct vectorize_arg {
+    static_assert(!std::is_rvalue_reference<T>::value,
+                  "Functions with rvalue reference arguments cannot be vectorized");
+    // The wrapped function gets called with this type:
+    using call_type = remove_reference_t<T>;
+    // Is this a vectorized argument?
+    static constexpr bool vectorize
+        = satisfies_any_of<call_type, std::is_arithmetic, is_complex, is_pod>::value
+          && satisfies_none_of<call_type,
+                               std::is_pointer,
+                               std::is_array,
+                               is_std_array,
+                               std::is_enum>::value
+          && (!std::is_reference<T>::value
+              || (std::is_lvalue_reference<T>::value && std::is_const<call_type>::value));
+    // Accept this type: an array for vectorized types, otherwise the type as-is:
+    using type = conditional_t<vectorize, array_t<remove_cv_t<call_type>, array::forcecast>, T>;
+};
 
-    template <size_t... Is>
-    bool load_impl_sequence(function_call &call, index_sequence<Is...>) {
-#ifdef __cpp_fold_expressions
-        if ((... || !std::get<Is>(argcasters).load(call.args[Is], call.args_convert[Is])))
-            return false;
-#else
-        for (bool r : {std::get<Is>(argcasters).load(call.args[Is], call.args_convert[Is])...})
-            if (!r)
-                return false;
-#endif
-        return true;
-    }
+// py::vectorize when a return type is present
+template <typename Func, typename Return, typename... Args>
+struct vectorize_returned_array {
+    using Type = array_t<Return>;
 
-    template <typename Return, typename Func, size_t... Is, typename Guard>
-    Return call_impl(Func &&f, index_sequence<Is...>, Guard &&) && {
-        return std::forward<Func>(f)(cast_op<Args>(std::move(std::get<Is>(argcasters)))...);
+    static Type create(broadcast_trivial trivial, const std::vector<ssize_t> &shape) {
+        if (trivial == broadcast_trivial::f_trivial) {
+            return array_t<Return, array::f_style>(shape);
+        }
+        return array_t<Return>(shape);
     }
 
-    std::tuple<make_caster<Args>...> argcasters;
+    static Return *mutable_data(Type &array) { return array.mutable_data(); }
+
+    static Return call(Func &f, Args &...args) { return f(args...); }
+
+    static void call(Return *out, size_t i, Func &f, Args &...args) { out[i] = f(args...); }
 };
 
-/// Helper class which collects only positional arguments for a Python function call.
-/// A fancier version below can collect any argument, but this one is optimal for simple calls.
-template <return_value_policy policy>
-class simple_collector {
-public:
-    template <typename... Ts>
-    explicit simple_collector(Ts &&...values)
-        : m_args(pybind11::make_tuple<policy>(std::forward<Ts>(values)...)) { }
-
-    const tuple &args() const & { return m_args; }
-    dict kwargs() const { return {}; }
-
-    tuple args() && { return std::move(m_args); }
-
-    /// Call a Python function and pass the collected arguments
-    object call(PyObject *ptr) const {
-        PyObject *result = PyObject_CallObject(ptr, m_args.ptr());
-        if (!result)
-            throw error_already_set();
-        return reinterpret_steal<object>(result);
+// py::vectorize when a return type is not present
+template <typename Func, typename... Args>
+struct vectorize_returned_array<Func, void, Args...> {
+    using Type = none;
+
+    static Type create(broadcast_trivial, const std::vector<ssize_t> &) { return none(); }
+
+    static void *mutable_data(Type &) { return nullptr; }
+
+    static detail::void_type call(Func &f, Args &...args) {
+        f(args...);
+        return {};
     }
 
-private:
-    tuple m_args;
+    static void call(void *, size_t, Func &f, Args &...args) { f(args...); }
 };
 
-/// Helper class which collects positional, keyword, * and ** arguments for a Python function call
-template <return_value_policy policy>
-class unpacking_collector {
-public:
-    template <typename... Ts>
-    explicit unpacking_collector(Ts &&...values) {
-        // Tuples aren't (easily) resizable so a list is needed for collection,
-        // but the actual function call strictly requires a tuple.
-        auto args_list = list();
-        int _[] = { 0, (process(args_list, std::forward<Ts>(values)), 0)... };
-        ignore_unused(_);
-
-        m_args = std::move(args_list);
-    }
-
-    const tuple &args() const & { return m_args; }
-    const dict &kwargs() const & { return m_kwargs; }
-
-    tuple args() && { return std::move(m_args); }
-    dict kwargs() && { return std::move(m_kwargs); }
-
-    /// Call a Python function and pass the collected arguments
-    object call(PyObject *ptr) const {
-        PyObject *result = PyObject_Call(ptr, m_args.ptr(), m_kwargs.ptr());
-        if (!result)
-            throw error_already_set();
-        return reinterpret_steal<object>(result);
-    }
+template <typename Func, typename Return, typename... Args>
+struct vectorize_helper {
 
-private:
-    template <typename T>
-    void process(list &args_list, T &&x) {
-        auto o = reinterpret_steal<object>(detail::make_caster<T>::cast(std::forward<T>(x), policy, {}));
-        if (!o) {
-#if defined(NDEBUG)
-            argument_cast_error();
+// NVCC for some reason breaks if NVectorized is private
+#ifdef __CUDACC__
+public:
 #else
-            argument_cast_error(std::to_string(args_list.size()), type_id<T>());
+private:
 #endif
-        }
-        args_list.append(o);
-    }
 
-    void process(list &args_list, detail::args_proxy ap) {
-        for (const auto &a : ap)
-            args_list.append(a);
+    static constexpr size_t N = sizeof...(Args);
+    static constexpr size_t NVectorized = constexpr_sum(vectorize_arg<Args>::vectorize...);
+    static_assert(
+        NVectorized >= 1,
+        "pybind11::vectorize(...) requires a function with at least one vectorizable argument");
+
+public:
+    template <typename T,
+              // SFINAE to prevent shadowing the copy constructor.
+              typename = detail::enable_if_t<
+                  !std::is_same<vectorize_helper, typename std::decay<T>::type>::value>>
+    explicit vectorize_helper(T &&f) : f(std::forward<T>(f)) {}
+
+    object operator()(typename vectorize_arg<Args>::type... args) {
+        return run(args...,
+                   make_index_sequence<N>(),
+                   select_indices<vectorize_arg<Args>::vectorize...>(),
+                   make_index_sequence<NVectorized>());
     }
 
-    void process(list &/*args_list*/, arg_v a) {
-        if (!a.name)
-#if defined(NDEBUG)
-            nameless_argument_error();
-#else
-            nameless_argument_error(a.type);
-#endif
+private:
+    remove_reference_t<Func> f;
 
-        if (m_kwargs.contains(a.name)) {
-#if defined(NDEBUG)
-            multiple_values_error();
-#else
-            multiple_values_error(a.name);
-#endif
-        }
-        if (!a.value) {
-#if defined(NDEBUG)
-            argument_cast_error();
-#else
-            argument_cast_error(a.name, a.type);
-#endif
+    // Internal compiler error in MSVC 19.16.27025.1 (Visual Studio 2017 15.9.4), when compiling
+    // with "/permissive-" flag when arg_call_types is manually inlined.
+    using arg_call_types = std::tuple<typename vectorize_arg<Args>::call_type...>;
+    template <size_t Index>
+    using param_n_t = typename std::tuple_element<Index, arg_call_types>::type;
+
+    using returned_array = vectorize_returned_array<Func, Return, Args...>;
+
+    // Runs a vectorized function given arguments tuple and three index sequences:
+    //     - Index is the full set of 0 ... (N-1) argument indices;
+    //     - VIndex is the subset of argument indices with vectorized parameters, letting us access
+    //       vectorized arguments (anything not in this sequence is passed through)
+    //     - BIndex is a incremental sequence (beginning at 0) of the same size as VIndex, so that
+    //       we can store vectorized buffer_infos in an array (argument VIndex has its buffer at
+    //       index BIndex in the array).
+    template <size_t... Index, size_t... VIndex, size_t... BIndex>
+    object run(typename vectorize_arg<Args>::type &...args,
+               index_sequence<Index...> i_seq,
+               index_sequence<VIndex...> vi_seq,
+               index_sequence<BIndex...> bi_seq) {
+
+        // Pointers to values the function was called with; the vectorized ones set here will start
+        // out as array_t<T> pointers, but they will be changed them to T pointers before we make
+        // call the wrapped function.  Non-vectorized pointers are left as-is.
+        std::array<void *, N> params{{&args...}};
+
+        // The array of `buffer_info`s of vectorized arguments:
+        std::array<buffer_info, NVectorized> buffers{
+            {reinterpret_cast<array *>(params[VIndex])->request()...}};
+
+        /* Determine dimensions parameters of output array */
+        ssize_t nd = 0;
+        std::vector<ssize_t> shape(0);
+        auto trivial = broadcast(buffers, nd, shape);
+        auto ndim = (size_t) nd;
+
+        size_t size
+            = std::accumulate(shape.begin(), shape.end(), (size_t) 1, std::multiplies<size_t>());
+
+        // If all arguments are 0-dimension arrays (i.e. single values) return a plain value (i.e.
+        // not wrapped in an array).
+        if (size == 1 && ndim == 0) {
+            PYBIND11_EXPAND_SIDE_EFFECTS(params[VIndex] = buffers[BIndex].ptr);
+            return cast(
+                returned_array::call(f, *reinterpret_cast<param_n_t<Index> *>(params[Index])...));
+        }
+
+        auto result = returned_array::create(trivial, shape);
+
+        PYBIND11_WARNING_PUSH
+#ifdef PYBIND11_DETECTED_CLANG_WITH_MISLEADING_CALL_STD_MOVE_EXPLICITLY_WARNING
+        PYBIND11_WARNING_DISABLE_CLANG("-Wreturn-std-move")
+#endif
+
+        if (size == 0) {
+            return result;
+        }
+
+        /* Call the function */
+        auto *mutable_data = returned_array::mutable_data(result);
+        if (trivial == broadcast_trivial::non_trivial) {
+            apply_broadcast(buffers, params, mutable_data, size, shape, i_seq, vi_seq, bi_seq);
+        } else {
+            apply_trivial(buffers, params, mutable_data, size, i_seq, vi_seq, bi_seq);
         }
-        m_kwargs[a.name] = a.value;
+
+        return result;
+        PYBIND11_WARNING_POP
     }
 
-    void process(list &/*args_list*/, detail::kwargs_proxy kp) {
-        if (!kp)
-            return;
-        for (const auto &k : reinterpret_borrow<dict>(kp)) {
-            if (m_kwargs.contains(k.first)) {
-#if defined(NDEBUG)
-                multiple_values_error();
-#else
-                multiple_values_error(str(k.first));
-#endif
+    template <size_t... Index, size_t... VIndex, size_t... BIndex>
+    void apply_trivial(std::array<buffer_info, NVectorized> &buffers,
+                       std::array<void *, N> &params,
+                       Return *out,
+                       size_t size,
+                       index_sequence<Index...>,
+                       index_sequence<VIndex...>,
+                       index_sequence<BIndex...>) {
+
+        // Initialize an array of mutable byte references and sizes with references set to the
+        // appropriate pointer in `params`; as we iterate, we'll increment each pointer by its size
+        // (except for singletons, which get an increment of 0).
+        std::array<std::pair<unsigned char *&, const size_t>, NVectorized> vecparams{
+            {std::pair<unsigned char *&, const size_t>(
+                reinterpret_cast<unsigned char *&>(params[VIndex] = buffers[BIndex].ptr),
+                buffers[BIndex].size == 1 ? 0 : sizeof(param_n_t<VIndex>))...}};
+
+        for (size_t i = 0; i < size; ++i) {
+            returned_array::call(
+                out, i, f, *reinterpret_cast<param_n_t<Index> *>(params[Index])...);
+            for (auto &x : vecparams) {
+                x.first += x.second;
             }
-            m_kwargs[k.first] = k.second;
         }
     }
 
-    [[noreturn]] static void nameless_argument_error() {
-        throw type_error("Got kwargs without a name; only named arguments "
-                         "may be passed via py::arg() to a python function call. "
-                         "(compile in debug mode for details)");
-    }
-    [[noreturn]] static void nameless_argument_error(std::string type) {
-        throw type_error("Got kwargs without a name of type '" + type + "'; only named "
-                         "arguments may be passed via py::arg() to a python function call. ");
-    }
-    [[noreturn]] static void multiple_values_error() {
-        throw type_error("Got multiple values for keyword argument "
-                         "(compile in debug mode for details)");
-    }
+    template <size_t... Index, size_t... VIndex, size_t... BIndex>
+    void apply_broadcast(std::array<buffer_info, NVectorized> &buffers,
+                         std::array<void *, N> &params,
+                         Return *out,
+                         size_t size,
+                         const std::vector<ssize_t> &output_shape,
+                         index_sequence<Index...>,
+                         index_sequence<VIndex...>,
+                         index_sequence<BIndex...>) {
 
-    [[noreturn]] static void multiple_values_error(std::string name) {
-        throw type_error("Got multiple values for keyword argument '" + name + "'");
-    }
+        multi_array_iterator<NVectorized> input_iter(buffers, output_shape);
 
-    [[noreturn]] static void argument_cast_error() {
-        throw cast_error("Unable to convert call argument to Python object "
-                         "(compile in debug mode for details)");
+        for (size_t i = 0; i < size; ++i, ++input_iter) {
+            PYBIND11_EXPAND_SIDE_EFFECTS((params[VIndex] = input_iter.template data<BIndex>()));
+            returned_array::call(
+                out, i, f, *reinterpret_cast<param_n_t<Index> *>(std::get<Index>(params))...);
+        }
     }
+};
 
-    [[noreturn]] static void argument_cast_error(std::string name, std::string type) {
-        throw cast_error("Unable to convert call argument '" + name
-                         + "' of type '" + type + "' to Python object");
-    }
+template <typename Func, typename Return, typename... Args>
+vectorize_helper<Func, Return, Args...> vectorize_extractor(const Func &f, Return (*)(Args...)) {
+    return detail::vectorize_helper<Func, Return, Args...>(f);
+}
 
-private:
-    tuple m_args;
-    dict m_kwargs;
+template <typename T, int Flags>
+struct handle_type_name<array_t<T, Flags>> {
+    static constexpr auto name
+        = const_name("numpy.ndarray[") + npy_format_descriptor<T>::name + const_name("]");
 };
 
-/// Collect only positional arguments for a Python function call
-template <return_value_policy policy, typename... Args,
-          typename = enable_if_t<all_of<is_positional<Args>...>::value>>
-simple_collector<policy> collect_arguments(Args &&...args) {
-    return simple_collector<policy>(std::forward<Args>(args)...);
-}
+PYBIND11_NAMESPACE_END(detail)
 
-/// Collect all arguments, including keywords and unpacking (only instantiated when needed)
-template <return_value_policy policy, typename... Args,
-          typename = enable_if_t<!all_of<is_positional<Args>...>::value>>
-unpacking_collector<policy> collect_arguments(Args &&...args) {
-    // Following argument order rules for generalized unpacking according to PEP 448
-    static_assert(
-        constexpr_last<is_positional, Args...>() < constexpr_first<is_keyword_or_ds, Args...>()
-        && constexpr_last<is_s_unpacking, Args...>() < constexpr_first<is_ds_unpacking, Args...>(),
-        "Invalid function call: positional args must precede keywords and ** unpacking; "
-        "* unpacking must precede ** unpacking"
-    );
-    return unpacking_collector<policy>(std::forward<Args>(args)...);
+// Vanilla pointer vectorizer:
+template <typename Return, typename... Args>
+detail::vectorize_helper<Return (*)(Args...), Return, Args...> vectorize(Return (*f)(Args...)) {
+    return detail::vectorize_helper<Return (*)(Args...), Return, Args...>(f);
 }
 
-template <typename Derived>
-template <return_value_policy policy, typename... Args>
-object object_api<Derived>::operator()(Args &&...args) const {
-    return detail::collect_arguments<policy>(std::forward<Args>(args)...).call(derived().ptr());
+// lambda vectorizer:
+template <typename Func, detail::enable_if_t<detail::is_lambda<Func>::value, int> = 0>
+auto vectorize(Func &&f)
+    -> decltype(detail::vectorize_extractor(std::forward<Func>(f),
+                                            (detail::function_signature_t<Func> *) nullptr)) {
+    return detail::vectorize_extractor(std::forward<Func>(f),
+                                       (detail::function_signature_t<Func> *) nullptr);
 }
 
-template <typename Derived>
-template <return_value_policy policy, typename... Args>
-object object_api<Derived>::call(Args &&...args) const {
-    return operator()<policy>(std::forward<Args>(args)...);
+// Vectorize a class method (non-const):
+template <typename Return,
+          typename Class,
+          typename... Args,
+          typename Helper = detail::vectorize_helper<
+              decltype(std::mem_fn(std::declval<Return (Class::*)(Args...)>())),
+              Return,
+              Class *,
+              Args...>>
+Helper vectorize(Return (Class::*f)(Args...)) {
+    return Helper(std::mem_fn(f));
 }
 
-NAMESPACE_END(detail)
-
-#define PYBIND11_MAKE_OPAQUE(...) \
-    namespace pybind11 { namespace detail { \
-        template<> class type_caster<__VA_ARGS__> : public type_caster_base<__VA_ARGS__> { }; \
-    }}
-
-/// Lets you pass a type containing a `,` through a macro parameter without needing a separate
-/// typedef, e.g.: `PYBIND11_OVERLOAD(PYBIND11_TYPE(ReturnType<A, B>), PYBIND11_TYPE(Parent<C, D>), f, arg)`
-#define PYBIND11_TYPE(...) __VA_ARGS__
+// Vectorize a class method (const):
+template <typename Return,
+          typename Class,
+          typename... Args,
+          typename Helper = detail::vectorize_helper<
+              decltype(std::mem_fn(std::declval<Return (Class::*)(Args...) const>())),
+              Return,
+              const Class *,
+              Args...>>
+Helper vectorize(Return (Class::*f)(Args...) const) {
+    return Helper(std::mem_fn(f));
+}
 
-NAMESPACE_END(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/chrono.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/chrono.h`

 * *Files 18% similar despite different names*

```diff
@@ -7,178 +7,219 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "pybind11.h"
+
+#include <chrono>
 #include <cmath>
 #include <ctime>
-#include <chrono>
 #include <datetime.h>
+#include <mutex>
 
-// Backport the PyDateTime_DELTA functions from Python3.3 if required
-#ifndef PyDateTime_DELTA_GET_DAYS
-#define PyDateTime_DELTA_GET_DAYS(o)         (((PyDateTime_Delta*)o)->days)
-#endif
-#ifndef PyDateTime_DELTA_GET_SECONDS
-#define PyDateTime_DELTA_GET_SECONDS(o)      (((PyDateTime_Delta*)o)->seconds)
-#endif
-#ifndef PyDateTime_DELTA_GET_MICROSECONDS
-#define PyDateTime_DELTA_GET_MICROSECONDS(o) (((PyDateTime_Delta*)o)->microseconds)
-#endif
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_BEGIN(detail)
 
-template <typename type> class duration_caster {
+template <typename type>
+class duration_caster {
 public:
-    typedef typename type::rep rep;
-    typedef typename type::period period;
+    using rep = typename type::rep;
+    using period = typename type::period;
 
-    typedef std::chrono::duration<uint_fast32_t, std::ratio<86400>> days;
+    // signed 25 bits required by the standard.
+    using days = std::chrono::duration<int_least32_t, std::ratio<86400>>;
 
     bool load(handle src, bool) {
         using namespace std::chrono;
 
         // Lazy initialise the PyDateTime import
-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }
+        if (!PyDateTimeAPI) {
+            PyDateTime_IMPORT;
+        }
 
-        if (!src) return false;
+        if (!src) {
+            return false;
+        }
         // If invoked with datetime.delta object
         if (PyDelta_Check(src.ptr())) {
             value = type(duration_cast<duration<rep, period>>(
-                  days(PyDateTime_DELTA_GET_DAYS(src.ptr()))
+                days(PyDateTime_DELTA_GET_DAYS(src.ptr()))
                 + seconds(PyDateTime_DELTA_GET_SECONDS(src.ptr()))
                 + microseconds(PyDateTime_DELTA_GET_MICROSECONDS(src.ptr()))));
             return true;
         }
         // If invoked with a float we assume it is seconds and convert
-        else if (PyFloat_Check(src.ptr())) {
-            value = type(duration_cast<duration<rep, period>>(duration<double>(PyFloat_AsDouble(src.ptr()))));
+        if (PyFloat_Check(src.ptr())) {
+            value = type(duration_cast<duration<rep, period>>(
+                duration<double>(PyFloat_AsDouble(src.ptr()))));
             return true;
         }
-        else return false;
+        return false;
     }
 
     // If this is a duration just return it back
-    static const std::chrono::duration<rep, period>& get_duration(const std::chrono::duration<rep, period> &src) {
+    static const std::chrono::duration<rep, period> &
+    get_duration(const std::chrono::duration<rep, period> &src) {
         return src;
     }
 
     // If this is a time_point get the time_since_epoch
-    template <typename Clock> static std::chrono::duration<rep, period> get_duration(const std::chrono::time_point<Clock, std::chrono::duration<rep, period>> &src) {
+    template <typename Clock>
+    static std::chrono::duration<rep, period>
+    get_duration(const std::chrono::time_point<Clock, std::chrono::duration<rep, period>> &src) {
         return src.time_since_epoch();
     }
 
     static handle cast(const type &src, return_value_policy /* policy */, handle /* parent */) {
         using namespace std::chrono;
 
         // Use overloaded function to get our duration from our source
         // Works out if it is a duration or time_point and get the duration
         auto d = get_duration(src);
 
         // Lazy initialise the PyDateTime import
-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }
+        if (!PyDateTimeAPI) {
+            PyDateTime_IMPORT;
+        }
 
-        // Declare these special duration types so the conversions happen with the correct primitive types (int)
+        // Declare these special duration types so the conversions happen with the correct
+        // primitive types (int)
         using dd_t = duration<int, std::ratio<86400>>;
         using ss_t = duration<int, std::ratio<1>>;
         using us_t = duration<int, std::micro>;
 
         auto dd = duration_cast<dd_t>(d);
         auto subd = d - dd;
         auto ss = duration_cast<ss_t>(subd);
         auto us = duration_cast<us_t>(subd - ss);
         return PyDelta_FromDSU(dd.count(), ss.count(), us.count());
     }
 
-    PYBIND11_TYPE_CASTER(type, _("datetime.timedelta"));
+    PYBIND11_TYPE_CASTER(type, const_name("datetime.timedelta"));
 };
 
+inline std::tm *localtime_thread_safe(const std::time_t *time, std::tm *buf) {
+#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || defined(_MSC_VER)
+    if (localtime_s(buf, time))
+        return nullptr;
+    return buf;
+#else
+    static std::mutex mtx;
+    std::lock_guard<std::mutex> lock(mtx);
+    std::tm *tm_ptr = std::localtime(time);
+    if (tm_ptr != nullptr) {
+        *buf = *tm_ptr;
+    }
+    return tm_ptr;
+#endif
+}
+
 // This is for casting times on the system clock into datetime.datetime instances
-template <typename Duration> class type_caster<std::chrono::time_point<std::chrono::system_clock, Duration>> {
+template <typename Duration>
+class type_caster<std::chrono::time_point<std::chrono::system_clock, Duration>> {
 public:
-    typedef std::chrono::time_point<std::chrono::system_clock, Duration> type;
+    using type = std::chrono::time_point<std::chrono::system_clock, Duration>;
     bool load(handle src, bool) {
         using namespace std::chrono;
 
         // Lazy initialise the PyDateTime import
-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }
+        if (!PyDateTimeAPI) {
+            PyDateTime_IMPORT;
+        }
 
-        if (!src) return false;
+        if (!src) {
+            return false;
+        }
 
         std::tm cal;
         microseconds msecs;
 
         if (PyDateTime_Check(src.ptr())) {
-            cal.tm_sec   = PyDateTime_DATE_GET_SECOND(src.ptr());
-            cal.tm_min   = PyDateTime_DATE_GET_MINUTE(src.ptr());
-            cal.tm_hour  = PyDateTime_DATE_GET_HOUR(src.ptr());
-            cal.tm_mday  = PyDateTime_GET_DAY(src.ptr());
-            cal.tm_mon   = PyDateTime_GET_MONTH(src.ptr()) - 1;
-            cal.tm_year  = PyDateTime_GET_YEAR(src.ptr()) - 1900;
+            cal.tm_sec = PyDateTime_DATE_GET_SECOND(src.ptr());
+            cal.tm_min = PyDateTime_DATE_GET_MINUTE(src.ptr());
+            cal.tm_hour = PyDateTime_DATE_GET_HOUR(src.ptr());
+            cal.tm_mday = PyDateTime_GET_DAY(src.ptr());
+            cal.tm_mon = PyDateTime_GET_MONTH(src.ptr()) - 1;
+            cal.tm_year = PyDateTime_GET_YEAR(src.ptr()) - 1900;
             cal.tm_isdst = -1;
-            msecs        = microseconds(PyDateTime_DATE_GET_MICROSECOND(src.ptr()));
+            msecs = microseconds(PyDateTime_DATE_GET_MICROSECOND(src.ptr()));
         } else if (PyDate_Check(src.ptr())) {
-            cal.tm_sec   = 0;
-            cal.tm_min   = 0;
-            cal.tm_hour  = 0;
-            cal.tm_mday  = PyDateTime_GET_DAY(src.ptr());
-            cal.tm_mon   = PyDateTime_GET_MONTH(src.ptr()) - 1;
-            cal.tm_year  = PyDateTime_GET_YEAR(src.ptr()) - 1900;
+            cal.tm_sec = 0;
+            cal.tm_min = 0;
+            cal.tm_hour = 0;
+            cal.tm_mday = PyDateTime_GET_DAY(src.ptr());
+            cal.tm_mon = PyDateTime_GET_MONTH(src.ptr()) - 1;
+            cal.tm_year = PyDateTime_GET_YEAR(src.ptr()) - 1900;
             cal.tm_isdst = -1;
-            msecs        = microseconds(0);
+            msecs = microseconds(0);
         } else if (PyTime_Check(src.ptr())) {
-            cal.tm_sec   = PyDateTime_TIME_GET_SECOND(src.ptr());
-            cal.tm_min   = PyDateTime_TIME_GET_MINUTE(src.ptr());
-            cal.tm_hour  = PyDateTime_TIME_GET_HOUR(src.ptr());
-            cal.tm_mday  = 1;   // This date (day, month, year) = (1, 0, 70)
-            cal.tm_mon   = 0;   // represents 1-Jan-1970, which is the first
-            cal.tm_year  = 70;  // earliest available date for Python's datetime
+            cal.tm_sec = PyDateTime_TIME_GET_SECOND(src.ptr());
+            cal.tm_min = PyDateTime_TIME_GET_MINUTE(src.ptr());
+            cal.tm_hour = PyDateTime_TIME_GET_HOUR(src.ptr());
+            cal.tm_mday = 1;  // This date (day, month, year) = (1, 0, 70)
+            cal.tm_mon = 0;   // represents 1-Jan-1970, which is the first
+            cal.tm_year = 70; // earliest available date for Python's datetime
             cal.tm_isdst = -1;
-            msecs        = microseconds(PyDateTime_TIME_GET_MICROSECOND(src.ptr()));
+            msecs = microseconds(PyDateTime_TIME_GET_MICROSECOND(src.ptr()));
+        } else {
+            return false;
         }
-        else return false;
 
-        value = system_clock::from_time_t(std::mktime(&cal)) + msecs;
+        value = time_point_cast<Duration>(system_clock::from_time_t(std::mktime(&cal)) + msecs);
         return true;
     }
 
-    static handle cast(const std::chrono::time_point<std::chrono::system_clock, Duration> &src, return_value_policy /* policy */, handle /* parent */) {
+    static handle cast(const std::chrono::time_point<std::chrono::system_clock, Duration> &src,
+                       return_value_policy /* policy */,
+                       handle /* parent */) {
         using namespace std::chrono;
 
         // Lazy initialise the PyDateTime import
-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }
-
-        std::time_t tt = system_clock::to_time_t(time_point_cast<system_clock::duration>(src));
-        // this function uses static memory so it's best to copy it out asap just in case
-        // otherwise other code that is using localtime may break this (not just python code)
-        std::tm localtime = *std::localtime(&tt);
+        if (!PyDateTimeAPI) {
+            PyDateTime_IMPORT;
+        }
 
-        // Declare these special duration types so the conversions happen with the correct primitive types (int)
+        // Get out microseconds, and make sure they are positive, to avoid bug in eastern
+        // hemisphere time zones (cfr. https://github.com/pybind/pybind11/issues/2417)
         using us_t = duration<int, std::micro>;
+        auto us = duration_cast<us_t>(src.time_since_epoch() % seconds(1));
+        if (us.count() < 0) {
+            us += seconds(1);
+        }
 
+        // Subtract microseconds BEFORE `system_clock::to_time_t`, because:
+        // > If std::time_t has lower precision, it is implementation-defined whether the value is
+        // rounded or truncated. (https://en.cppreference.com/w/cpp/chrono/system_clock/to_time_t)
+        std::time_t tt
+            = system_clock::to_time_t(time_point_cast<system_clock::duration>(src - us));
+
+        std::tm localtime;
+        std::tm *localtime_ptr = localtime_thread_safe(&tt, &localtime);
+        if (!localtime_ptr) {
+            throw cast_error("Unable to represent system_clock in local time");
+        }
         return PyDateTime_FromDateAndTime(localtime.tm_year + 1900,
                                           localtime.tm_mon + 1,
                                           localtime.tm_mday,
                                           localtime.tm_hour,
                                           localtime.tm_min,
                                           localtime.tm_sec,
-                                          (duration_cast<us_t>(src.time_since_epoch() % seconds(1))).count());
+                                          us.count());
     }
-    PYBIND11_TYPE_CASTER(type, _("datetime.datetime"));
+    PYBIND11_TYPE_CASTER(type, const_name("datetime.datetime"));
 };
 
 // Other clocks that are not the system clock are not measured as datetime.datetime objects
 // since they are not measured on calendar time. So instead we just make them timedeltas
 // Or if they have passed us a time as a float we convert that
-template <typename Clock, typename Duration> class type_caster<std::chrono::time_point<Clock, Duration>>
-: public duration_caster<std::chrono::time_point<Clock, Duration>> {
-};
-
-template <typename Rep, typename Period> class type_caster<std::chrono::duration<Rep, Period>>
-: public duration_caster<std::chrono::duration<Rep, Period>> {
-};
+template <typename Clock, typename Duration>
+class type_caster<std::chrono::time_point<Clock, Duration>>
+    : public duration_caster<std::chrono::time_point<Clock, Duration>> {};
+
+template <typename Rep, typename Period>
+class type_caster<std::chrono::duration<Rep, Period>>
+    : public duration_caster<std::chrono::duration<Rep, Period>> {};
 
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/complex.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/complex.h`

 * *Files 8% similar despite different names*

```diff
@@ -6,60 +6,69 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "pybind11.h"
+
 #include <complex>
 
 /// glibc defines I as a macro which breaks things, e.g., boost template names
 #ifdef I
-#  undef I
+#    undef I
 #endif
 
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
-template <typename T> struct format_descriptor<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {
+template <typename T>
+struct format_descriptor<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {
     static constexpr const char c = format_descriptor<T>::c;
-    static constexpr const char value[3] = { 'Z', c, '\0' };
+    static constexpr const char value[3] = {'Z', c, '\0'};
     static std::string format() { return std::string(value); }
 };
 
 #ifndef PYBIND11_CPP17
 
-template <typename T> constexpr const char format_descriptor<
-    std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>>::value[3];
+template <typename T>
+constexpr const char
+    format_descriptor<std::complex<T>,
+                      detail::enable_if_t<std::is_floating_point<T>::value>>::value[3];
 
 #endif
 
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(detail)
 
-template <typename T> struct is_fmt_numeric<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {
+template <typename T>
+struct is_fmt_numeric<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {
     static constexpr bool value = true;
     static constexpr int index = is_fmt_numeric<T>::index + 3;
 };
 
-template <typename T> class type_caster<std::complex<T>> {
+template <typename T>
+class type_caster<std::complex<T>> {
 public:
     bool load(handle src, bool convert) {
-        if (!src)
+        if (!src) {
             return false;
-        if (!convert && !PyComplex_Check(src.ptr()))
+        }
+        if (!convert && !PyComplex_Check(src.ptr())) {
             return false;
+        }
         Py_complex result = PyComplex_AsCComplex(src.ptr());
         if (result.real == -1.0 && PyErr_Occurred()) {
             PyErr_Clear();
             return false;
         }
         value = std::complex<T>((T) result.real, (T) result.imag);
         return true;
     }
 
-    static handle cast(const std::complex<T> &src, return_value_policy /* policy */, handle /* parent */) {
+    static handle
+    cast(const std::complex<T> &src, return_value_policy /* policy */, handle /* parent */) {
         return PyComplex_FromDoubles((double) src.real(), (double) src.imag());
     }
 
-    PYBIND11_TYPE_CASTER(std::complex<T>, _("complex"));
+    PYBIND11_TYPE_CASTER(std::complex<T>, const_name("complex"));
 };
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/detail/class.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/detail/class.h`

 * *Files 11% similar despite different names*

```diff
@@ -8,26 +8,39 @@
 */
 
 #pragma once
 
 #include "../attr.h"
 #include "../options.h"
 
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_BEGIN(detail)
 
-#if PY_VERSION_HEX >= 0x03030000
-#  define PYBIND11_BUILTIN_QUALNAME
-#  define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)
+#if !defined(PYPY_VERSION)
+#    define PYBIND11_BUILTIN_QUALNAME
+#    define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)
 #else
-// In pre-3.3 Python, we still set __qualname__ so that we can produce reliable function type
-// signatures; in 3.3+ this macro expands to nothing:
-#  define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj) setattr((PyObject *) obj, "__qualname__", nameobj)
+// In PyPy, we still set __qualname__ so that we can produce reliable function type
+// signatures; in CPython this macro expands to nothing:
+#    define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)                                             \
+        setattr((PyObject *) obj, "__qualname__", nameobj)
 #endif
 
+inline std::string get_fully_qualified_tp_name(PyTypeObject *type) {
+#if !defined(PYPY_VERSION)
+    return type->tp_name;
+#else
+    auto module_name = handle((PyObject *) type).attr("__module__").cast<std::string>();
+    if (module_name == PYBIND11_BUILTINS_MODULE)
+        return type->tp_name;
+    else
+        return std::move(module_name) + "." + type->tp_name;
+#endif
+}
+
 inline PyTypeObject *type_incref(PyTypeObject *type) {
     Py_INCREF(type);
     return type;
 }
 
 #if !defined(PYPY_VERSION)
 
@@ -38,43 +51,55 @@
 
 /// `pybind11_static_property.__set__()`: Just like the above `__get__()`.
 extern "C" inline int pybind11_static_set(PyObject *self, PyObject *obj, PyObject *value) {
     PyObject *cls = PyType_Check(obj) ? obj : (PyObject *) Py_TYPE(obj);
     return PyProperty_Type.tp_descr_set(self, cls, value);
 }
 
+// Forward declaration to use in `make_static_property_type()`
+inline void enable_dynamic_attributes(PyHeapTypeObject *heap_type);
+
 /** A `static_property` is the same as a `property` but the `__get__()` and `__set__()`
     methods are modified to always use the object type instead of a concrete instance.
     Return value: New reference. */
 inline PyTypeObject *make_static_property_type() {
     constexpr auto *name = "pybind11_static_property";
     auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));
 
     /* Danger zone: from now (and until PyType_Ready), make sure to
        issue no Python C API calls which could potentially invoke the
        garbage collector (the GC will call type_traverse(), which will in
        turn find the newly constructed type in an invalid state) */
-    auto heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
-    if (!heap_type)
+    auto *heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
+    if (!heap_type) {
         pybind11_fail("make_static_property_type(): error allocating type!");
+    }
 
     heap_type->ht_name = name_obj.inc_ref().ptr();
-#ifdef PYBIND11_BUILTIN_QUALNAME
+#    ifdef PYBIND11_BUILTIN_QUALNAME
     heap_type->ht_qualname = name_obj.inc_ref().ptr();
-#endif
+#    endif
 
-    auto type = &heap_type->ht_type;
+    auto *type = &heap_type->ht_type;
     type->tp_name = name;
     type->tp_base = type_incref(&PyProperty_Type);
     type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
     type->tp_descr_get = pybind11_static_get;
     type->tp_descr_set = pybind11_static_set;
 
-    if (PyType_Ready(type) < 0)
+    if (PyType_Ready(type) < 0) {
         pybind11_fail("make_static_property_type(): failure in PyType_Ready()!");
+    }
+
+#    if PY_VERSION_HEX >= 0x030C0000
+    // PRE 3.12 FEATURE FREEZE. PLEASE REVIEW AFTER FREEZE.
+    // Since Python-3.12 property-derived types are required to
+    // have dynamic attributes (to set `__doc__`)
+    enable_dynamic_attributes(heap_type);
+#    endif
 
     setattr((PyObject *) type, "__module__", str("pybind11_builtins"));
     PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);
 
     return type;
 }
 
@@ -82,47 +107,50 @@
 
 /** PyPy has some issues with the above C API, so we evaluate Python code instead.
     This function will only be called once so performance isn't really a concern.
     Return value: New reference. */
 inline PyTypeObject *make_static_property_type() {
     auto d = dict();
     PyObject *result = PyRun_String(R"(\
-        class pybind11_static_property(property):
-            def __get__(self, obj, cls):
-                return property.__get__(self, cls, cls)
-
-            def __set__(self, obj, value):
-                cls = obj if isinstance(obj, type) else type(obj)
-                property.__set__(self, cls, value)
-        )", Py_file_input, d.ptr(), d.ptr()
-    );
+class pybind11_static_property(property):
+    def __get__(self, obj, cls):
+        return property.__get__(self, cls, cls)
+
+    def __set__(self, obj, value):
+        cls = obj if isinstance(obj, type) else type(obj)
+        property.__set__(self, cls, value)
+)",
+                                    Py_file_input,
+                                    d.ptr(),
+                                    d.ptr());
     if (result == nullptr)
         throw error_already_set();
     Py_DECREF(result);
     return (PyTypeObject *) d["pybind11_static_property"].cast<object>().release().ptr();
 }
 
 #endif // PYPY
 
 /** Types with static properties need to handle `Type.static_prop = x` in a specific way.
     By default, Python replaces the `static_property` itself, but for wrapped C++ types
     we need to call `static_property.__set__()` in order to propagate the new value to
     the underlying C++ data structure. */
-extern "C" inline int pybind11_meta_setattro(PyObject* obj, PyObject* name, PyObject* value) {
+extern "C" inline int pybind11_meta_setattro(PyObject *obj, PyObject *name, PyObject *value) {
     // Use `_PyType_Lookup()` instead of `PyObject_GetAttr()` in order to get the raw
     // descriptor (`property`) instead of calling `tp_descr_get` (`property.__get__()`).
     PyObject *descr = _PyType_Lookup((PyTypeObject *) obj, name);
 
     // The following assignment combinations are possible:
     //   1. `Type.static_prop = value`             --> descr_set: `Type.static_prop.__set__(value)`
     //   2. `Type.static_prop = other_static_prop` --> setattro:  replace existing `static_prop`
     //   3. `Type.regular_attribute = value`       --> setattro:  regular attribute assignment
-    const auto static_prop = (PyObject *) get_internals().static_property_type;
-    const auto call_descr_set = descr && PyObject_IsInstance(descr, static_prop)
-                                && !PyObject_IsInstance(value, static_prop);
+    auto *const static_prop = (PyObject *) get_internals().static_property_type;
+    const auto call_descr_set = (descr != nullptr) && (value != nullptr)
+                                && (PyObject_IsInstance(descr, static_prop) != 0)
+                                && (PyObject_IsInstance(value, static_prop) == 0);
     if (call_descr_set) {
         // Call `static_property.__set__()` instead of replacing the `static_property`.
 #if !defined(PYPY_VERSION)
         return Py_TYPE(descr)->tp_descr_set(descr, obj, value);
 #else
         if (PyObject *result = PyObject_CallMethod(descr, "__set__", "OO", obj, value)) {
             Py_DECREF(result);
@@ -133,84 +161,153 @@
 #endif
     } else {
         // Replace existing attribute.
         return PyType_Type.tp_setattro(obj, name, value);
     }
 }
 
-#if PY_MAJOR_VERSION >= 3
 /**
  * Python 3's PyInstanceMethod_Type hides itself via its tp_descr_get, which prevents aliasing
  * methods via cls.attr("m2") = cls.attr("m1"): instead the tp_descr_get returns a plain function,
  * when called on a class, or a PyMethod, when called on an instance.  Override that behaviour here
  * to do a special case bypass for PyInstanceMethod_Types.
  */
 extern "C" inline PyObject *pybind11_meta_getattro(PyObject *obj, PyObject *name) {
     PyObject *descr = _PyType_Lookup((PyTypeObject *) obj, name);
     if (descr && PyInstanceMethod_Check(descr)) {
         Py_INCREF(descr);
         return descr;
     }
-    else {
-        return PyType_Type.tp_getattro(obj, name);
+    return PyType_Type.tp_getattro(obj, name);
+}
+
+/// metaclass `__call__` function that is used to create all pybind11 objects.
+extern "C" inline PyObject *pybind11_meta_call(PyObject *type, PyObject *args, PyObject *kwargs) {
+
+    // use the default metaclass call to create/initialize the object
+    PyObject *self = PyType_Type.tp_call(type, args, kwargs);
+    if (self == nullptr) {
+        return nullptr;
     }
+
+    // This must be a pybind11 instance
+    auto *instance = reinterpret_cast<detail::instance *>(self);
+
+    // Ensure that the base __init__ function(s) were called
+    for (const auto &vh : values_and_holders(instance)) {
+        if (!vh.holder_constructed()) {
+            PyErr_Format(PyExc_TypeError,
+                         "%.200s.__init__() must be called when overriding __init__",
+                         get_fully_qualified_tp_name(vh.type->type).c_str());
+            Py_DECREF(self);
+            return nullptr;
+        }
+    }
+
+    return self;
+}
+
+/// Cleanup the type-info for a pybind11-registered type.
+extern "C" inline void pybind11_meta_dealloc(PyObject *obj) {
+    auto *type = (PyTypeObject *) obj;
+    auto &internals = get_internals();
+
+    // A pybind11-registered type will:
+    // 1) be found in internals.registered_types_py
+    // 2) have exactly one associated `detail::type_info`
+    auto found_type = internals.registered_types_py.find(type);
+    if (found_type != internals.registered_types_py.end() && found_type->second.size() == 1
+        && found_type->second[0]->type == type) {
+
+        auto *tinfo = found_type->second[0];
+        auto tindex = std::type_index(*tinfo->cpptype);
+        internals.direct_conversions.erase(tindex);
+
+        if (tinfo->module_local) {
+            get_local_internals().registered_types_cpp.erase(tindex);
+        } else {
+            internals.registered_types_cpp.erase(tindex);
+        }
+        internals.registered_types_py.erase(tinfo->type);
+
+        // Actually just `std::erase_if`, but that's only available in C++20
+        auto &cache = internals.inactive_override_cache;
+        for (auto it = cache.begin(), last = cache.end(); it != last;) {
+            if (it->first == (PyObject *) tinfo->type) {
+                it = cache.erase(it);
+            } else {
+                ++it;
+            }
+        }
+
+        delete tinfo;
+    }
+
+    PyType_Type.tp_dealloc(obj);
 }
-#endif
 
 /** This metaclass is assigned by default to all pybind11 types and is required in order
     for static properties to function correctly. Users may override this using `py::metaclass`.
     Return value: New reference. */
-inline PyTypeObject* make_default_metaclass() {
+inline PyTypeObject *make_default_metaclass() {
     constexpr auto *name = "pybind11_type";
     auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));
 
     /* Danger zone: from now (and until PyType_Ready), make sure to
        issue no Python C API calls which could potentially invoke the
        garbage collector (the GC will call type_traverse(), which will in
        turn find the newly constructed type in an invalid state) */
-    auto heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
-    if (!heap_type)
+    auto *heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
+    if (!heap_type) {
         pybind11_fail("make_default_metaclass(): error allocating metaclass!");
+    }
 
     heap_type->ht_name = name_obj.inc_ref().ptr();
 #ifdef PYBIND11_BUILTIN_QUALNAME
     heap_type->ht_qualname = name_obj.inc_ref().ptr();
 #endif
 
-    auto type = &heap_type->ht_type;
+    auto *type = &heap_type->ht_type;
     type->tp_name = name;
     type->tp_base = type_incref(&PyType_Type);
     type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
 
+    type->tp_call = pybind11_meta_call;
+
     type->tp_setattro = pybind11_meta_setattro;
-#if PY_MAJOR_VERSION >= 3
     type->tp_getattro = pybind11_meta_getattro;
-#endif
 
-    if (PyType_Ready(type) < 0)
+    type->tp_dealloc = pybind11_meta_dealloc;
+
+    if (PyType_Ready(type) < 0) {
         pybind11_fail("make_default_metaclass(): failure in PyType_Ready()!");
+    }
 
     setattr((PyObject *) type, "__module__", str("pybind11_builtins"));
     PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);
 
     return type;
 }
 
 /// For multiple inheritance types we need to recursively register/deregister base pointers for any
 /// base classes with pointers that are difference from the instance value pointer so that we can
-/// correctly recognize an offset base class pointer. This calls a function with any offset base ptrs.
-inline void traverse_offset_bases(void *valueptr, const detail::type_info *tinfo, instance *self,
-        bool (*f)(void * /*parentptr*/, instance * /*self*/)) {
+/// correctly recognize an offset base class pointer. This calls a function with any offset base
+/// ptrs.
+inline void traverse_offset_bases(void *valueptr,
+                                  const detail::type_info *tinfo,
+                                  instance *self,
+                                  bool (*f)(void * /*parentptr*/, instance * /*self*/)) {
     for (handle h : reinterpret_borrow<tuple>(tinfo->type->tp_bases)) {
-        if (auto parent_tinfo = get_type_info((PyTypeObject *) h.ptr())) {
+        if (auto *parent_tinfo = get_type_info((PyTypeObject *) h.ptr())) {
             for (auto &c : parent_tinfo->implicit_casts) {
                 if (c.first == tinfo->cpptype) {
                     auto *parentptr = c.second(valueptr);
-                    if (parentptr != valueptr)
+                    if (parentptr != valueptr) {
                         f(parentptr, self);
+                    }
                     traverse_offset_bases(parentptr, parent_tinfo, self, f);
                     break;
                 }
             }
         }
     }
 }
@@ -219,139 +316,150 @@
     get_internals().registered_instances.emplace(ptr, self);
     return true; // unused, but gives the same signature as the deregister func
 }
 inline bool deregister_instance_impl(void *ptr, instance *self) {
     auto &registered_instances = get_internals().registered_instances;
     auto range = registered_instances.equal_range(ptr);
     for (auto it = range.first; it != range.second; ++it) {
-        if (Py_TYPE(self) == Py_TYPE(it->second)) {
+        if (self == it->second) {
             registered_instances.erase(it);
             return true;
         }
     }
     return false;
 }
 
 inline void register_instance(instance *self, void *valptr, const type_info *tinfo) {
     register_instance_impl(valptr, self);
-    if (!tinfo->simple_ancestors)
+    if (!tinfo->simple_ancestors) {
         traverse_offset_bases(valptr, tinfo, self, register_instance_impl);
+    }
 }
 
 inline bool deregister_instance(instance *self, void *valptr, const type_info *tinfo) {
     bool ret = deregister_instance_impl(valptr, self);
-    if (!tinfo->simple_ancestors)
+    if (!tinfo->simple_ancestors) {
         traverse_offset_bases(valptr, tinfo, self, deregister_instance_impl);
+    }
     return ret;
 }
 
-/// Instance creation function for all pybind11 types. It allocates the internal instance layout for
-/// holding C++ objects and holders.  Allocation is done lazily (the first time the instance is cast
-/// to a reference or pointer), and initialization is done by an `__init__` function.
+/// Instance creation function for all pybind11 types. It allocates the internal instance layout
+/// for holding C++ objects and holders.  Allocation is done lazily (the first time the instance is
+/// cast to a reference or pointer), and initialization is done by an `__init__` function.
 inline PyObject *make_new_instance(PyTypeObject *type) {
 #if defined(PYPY_VERSION)
-    // PyPy gets tp_basicsize wrong (issue 2482) under multiple inheritance when the first inherited
-    // object is a a plain Python type (i.e. not derived from an extension type).  Fix it.
+    // PyPy gets tp_basicsize wrong (issue 2482) under multiple inheritance when the first
+    // inherited object is a plain Python type (i.e. not derived from an extension type).  Fix it.
     ssize_t instance_size = static_cast<ssize_t>(sizeof(instance));
     if (type->tp_basicsize < instance_size) {
         type->tp_basicsize = instance_size;
     }
 #endif
     PyObject *self = type->tp_alloc(type, 0);
-    auto inst = reinterpret_cast<instance *>(self);
+    auto *inst = reinterpret_cast<instance *>(self);
     // Allocate the value/holder internals:
     inst->allocate_layout();
 
-    inst->owned = true;
-
     return self;
 }
 
 /// Instance creation function for all pybind11 types. It only allocates space for the
 /// C++ object, but doesn't call the constructor -- an `__init__` function must do that.
 extern "C" inline PyObject *pybind11_object_new(PyTypeObject *type, PyObject *, PyObject *) {
     return make_new_instance(type);
 }
 
 /// An `__init__` function constructs the C++ object. Users should provide at least one
 /// of these using `py::init` or directly with `.def(__init__, ...)`. Otherwise, the
 /// following default function will be used which simply throws an exception.
 extern "C" inline int pybind11_object_init(PyObject *self, PyObject *, PyObject *) {
     PyTypeObject *type = Py_TYPE(self);
-    std::string msg;
-#if defined(PYPY_VERSION)
-    msg += handle((PyObject *) type).attr("__module__").cast<std::string>() + ".";
-#endif
-    msg += type->tp_name;
-    msg += ": No constructor defined!";
+    std::string msg = get_fully_qualified_tp_name(type) + ": No constructor defined!";
     PyErr_SetString(PyExc_TypeError, msg.c_str());
     return -1;
 }
 
 inline void add_patient(PyObject *nurse, PyObject *patient) {
     auto &internals = get_internals();
-    auto instance = reinterpret_cast<detail::instance *>(nurse);
+    auto *instance = reinterpret_cast<detail::instance *>(nurse);
     instance->has_patients = true;
     Py_INCREF(patient);
     internals.patients[nurse].push_back(patient);
 }
 
 inline void clear_patients(PyObject *self) {
-    auto instance = reinterpret_cast<detail::instance *>(self);
+    auto *instance = reinterpret_cast<detail::instance *>(self);
     auto &internals = get_internals();
     auto pos = internals.patients.find(self);
     assert(pos != internals.patients.end());
     // Clearing the patients can cause more Python code to run, which
     // can invalidate the iterator. Extract the vector of patients
     // from the unordered_map first.
     auto patients = std::move(pos->second);
     internals.patients.erase(pos);
     instance->has_patients = false;
-    for (PyObject *&patient : patients)
+    for (PyObject *&patient : patients) {
         Py_CLEAR(patient);
+    }
 }
 
 /// Clears all internal data from the instance and removes it from registered instances in
 /// preparation for deallocation.
 inline void clear_instance(PyObject *self) {
-    auto instance = reinterpret_cast<detail::instance *>(self);
+    auto *instance = reinterpret_cast<detail::instance *>(self);
 
     // Deallocate any values/holders, if present:
     for (auto &v_h : values_and_holders(instance)) {
         if (v_h) {
 
             // We have to deregister before we call dealloc because, for virtual MI types, we still
             // need to be able to get the parent pointers.
-            if (v_h.instance_registered() && !deregister_instance(instance, v_h.value_ptr(), v_h.type))
-                pybind11_fail("pybind11_object_dealloc(): Tried to deallocate unregistered instance!");
+            if (v_h.instance_registered()
+                && !deregister_instance(instance, v_h.value_ptr(), v_h.type)) {
+                pybind11_fail(
+                    "pybind11_object_dealloc(): Tried to deallocate unregistered instance!");
+            }
 
-            if (instance->owned || v_h.holder_constructed())
+            if (instance->owned || v_h.holder_constructed()) {
                 v_h.type->dealloc(v_h);
+            }
         }
     }
     // Deallocate the value/holder layout internals:
     instance->deallocate_layout();
 
-    if (instance->weakrefs)
+    if (instance->weakrefs) {
         PyObject_ClearWeakRefs(self);
+    }
 
     PyObject **dict_ptr = _PyObject_GetDictPtr(self);
-    if (dict_ptr)
+    if (dict_ptr) {
         Py_CLEAR(*dict_ptr);
+    }
 
-    if (instance->has_patients)
+    if (instance->has_patients) {
         clear_patients(self);
+    }
 }
 
 /// Instance destructor function for all pybind11 types. It calls `type_info.dealloc`
 /// to destroy the C++ object itself, while the rest is Python bookkeeping.
 extern "C" inline void pybind11_object_dealloc(PyObject *self) {
+    auto *type = Py_TYPE(self);
+
+    // If this is a GC tracked object, untrack it first
+    // Note that the track call is implicitly done by the
+    // default tp_alloc, which we never override.
+    if (PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC) != 0) {
+        PyObject_GC_UnTrack(self);
+    }
+
     clear_instance(self);
 
-    auto type = Py_TYPE(self);
     type->tp_free(self);
 
 #if PY_VERSION_HEX < 0x03080000
     // `type->tp_dealloc != pybind11_object_dealloc` means that we're being called
     // as part of a derived type's dealloc, in which case we're not allowed to decref
     // the type here. For cross-module compatibility, we shouldn't compare directly
     // with `pybind11_object_dealloc`, but with the common one stashed in internals.
@@ -361,281 +469,275 @@
 #else
     // This was not needed before Python 3.8 (Python issue 35810)
     // https://github.com/pybind/pybind11/issues/1946
     Py_DECREF(type);
 #endif
 }
 
+std::string error_string();
+
 /** Create the type which can be used as a common base for all classes.  This is
     needed in order to satisfy Python's requirements for multiple inheritance.
     Return value: New reference. */
 inline PyObject *make_object_base_type(PyTypeObject *metaclass) {
     constexpr auto *name = "pybind11_object";
     auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));
 
     /* Danger zone: from now (and until PyType_Ready), make sure to
        issue no Python C API calls which could potentially invoke the
        garbage collector (the GC will call type_traverse(), which will in
        turn find the newly constructed type in an invalid state) */
-    auto heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);
-    if (!heap_type)
+    auto *heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);
+    if (!heap_type) {
         pybind11_fail("make_object_base_type(): error allocating type!");
+    }
 
     heap_type->ht_name = name_obj.inc_ref().ptr();
 #ifdef PYBIND11_BUILTIN_QUALNAME
     heap_type->ht_qualname = name_obj.inc_ref().ptr();
 #endif
 
-    auto type = &heap_type->ht_type;
+    auto *type = &heap_type->ht_type;
     type->tp_name = name;
     type->tp_base = type_incref(&PyBaseObject_Type);
     type->tp_basicsize = static_cast<ssize_t>(sizeof(instance));
     type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
 
     type->tp_new = pybind11_object_new;
     type->tp_init = pybind11_object_init;
     type->tp_dealloc = pybind11_object_dealloc;
 
     /* Support weak references (needed for the keep_alive feature) */
     type->tp_weaklistoffset = offsetof(instance, weakrefs);
 
-    if (PyType_Ready(type) < 0)
-        pybind11_fail("PyType_Ready failed in make_object_base_type():" + error_string());
+    if (PyType_Ready(type) < 0) {
+        pybind11_fail("PyType_Ready failed in make_object_base_type(): " + error_string());
+    }
 
     setattr((PyObject *) type, "__module__", str("pybind11_builtins"));
     PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);
 
     assert(!PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));
     return (PyObject *) heap_type;
 }
 
-/// dynamic_attr: Support for `d = instance.__dict__`.
-extern "C" inline PyObject *pybind11_get_dict(PyObject *self, void *) {
-    PyObject *&dict = *_PyObject_GetDictPtr(self);
-    if (!dict)
-        dict = PyDict_New();
-    Py_XINCREF(dict);
-    return dict;
-}
-
-/// dynamic_attr: Support for `instance.__dict__ = dict()`.
-extern "C" inline int pybind11_set_dict(PyObject *self, PyObject *new_dict, void *) {
-    if (!PyDict_Check(new_dict)) {
-        PyErr_Format(PyExc_TypeError, "__dict__ must be set to a dictionary, not a '%.200s'",
-                     Py_TYPE(new_dict)->tp_name);
-        return -1;
-    }
-    PyObject *&dict = *_PyObject_GetDictPtr(self);
-    Py_INCREF(new_dict);
-    Py_CLEAR(dict);
-    dict = new_dict;
-    return 0;
-}
-
 /// dynamic_attr: Allow the garbage collector to traverse the internal instance `__dict__`.
 extern "C" inline int pybind11_traverse(PyObject *self, visitproc visit, void *arg) {
     PyObject *&dict = *_PyObject_GetDictPtr(self);
     Py_VISIT(dict);
+// https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_traverse
+#if PY_VERSION_HEX >= 0x03090000
+    Py_VISIT(Py_TYPE(self));
+#endif
     return 0;
 }
 
 /// dynamic_attr: Allow the GC to clear the dictionary.
 extern "C" inline int pybind11_clear(PyObject *self) {
     PyObject *&dict = *_PyObject_GetDictPtr(self);
     Py_CLEAR(dict);
     return 0;
 }
 
 /// Give instances of this type a `__dict__` and opt into garbage collection.
 inline void enable_dynamic_attributes(PyHeapTypeObject *heap_type) {
-    auto type = &heap_type->ht_type;
-#if defined(PYPY_VERSION)
-    pybind11_fail(std::string(type->tp_name) + ": dynamic attributes are "
-                                               "currently not supported in "
-                                               "conjunction with PyPy!");
-#endif
+    auto *type = &heap_type->ht_type;
     type->tp_flags |= Py_TPFLAGS_HAVE_GC;
-    type->tp_dictoffset = type->tp_basicsize; // place dict at the end
-    type->tp_basicsize += (ssize_t)sizeof(PyObject *); // and allocate enough space for it
+#if PY_VERSION_HEX < 0x030B0000
+    type->tp_dictoffset = type->tp_basicsize;           // place dict at the end
+    type->tp_basicsize += (ssize_t) sizeof(PyObject *); // and allocate enough space for it
+#else
+    type->tp_flags |= Py_TPFLAGS_MANAGED_DICT;
+#endif
     type->tp_traverse = pybind11_traverse;
     type->tp_clear = pybind11_clear;
 
-    static PyGetSetDef getset[] = {
-        {const_cast<char*>("__dict__"), pybind11_get_dict, pybind11_set_dict, nullptr, nullptr},
-        {nullptr, nullptr, nullptr, nullptr, nullptr}
-    };
+    static PyGetSetDef getset[] = {{
+#if PY_VERSION_HEX < 0x03070000
+                                       const_cast<char *>("__dict__"),
+#else
+                                       "__dict__",
+#endif
+                                       PyObject_GenericGetDict,
+                                       PyObject_GenericSetDict,
+                                       nullptr,
+                                       nullptr},
+                                   {nullptr, nullptr, nullptr, nullptr, nullptr}};
     type->tp_getset = getset;
 }
 
 /// buffer_protocol: Fill in the view as specified by flags.
 extern "C" inline int pybind11_getbuffer(PyObject *obj, Py_buffer *view, int flags) {
     // Look for a `get_buffer` implementation in this type's info or any bases (following MRO).
     type_info *tinfo = nullptr;
     for (auto type : reinterpret_borrow<tuple>(Py_TYPE(obj)->tp_mro)) {
         tinfo = get_type_info((PyTypeObject *) type.ptr());
-        if (tinfo && tinfo->get_buffer)
+        if (tinfo && tinfo->get_buffer) {
             break;
+        }
     }
     if (view == nullptr || !tinfo || !tinfo->get_buffer) {
-        if (view)
+        if (view) {
             view->obj = nullptr;
+        }
         PyErr_SetString(PyExc_BufferError, "pybind11_getbuffer(): Internal error");
         return -1;
     }
     std::memset(view, 0, sizeof(Py_buffer));
     buffer_info *info = tinfo->get_buffer(obj, tinfo->get_buffer_data);
+    if ((flags & PyBUF_WRITABLE) == PyBUF_WRITABLE && info->readonly) {
+        delete info;
+        // view->obj = nullptr;  // Was just memset to 0, so not necessary
+        PyErr_SetString(PyExc_BufferError, "Writable buffer requested for readonly storage");
+        return -1;
+    }
     view->obj = obj;
     view->ndim = 1;
     view->internal = info;
     view->buf = info->ptr;
     view->itemsize = info->itemsize;
     view->len = view->itemsize;
-    for (auto s : info->shape)
+    for (auto s : info->shape) {
         view->len *= s;
-    view->readonly = info->readonly;
-    if ((flags & PyBUF_WRITABLE) == PyBUF_WRITABLE && info->readonly) {
-        if (view)
-            view->obj = nullptr;
-        PyErr_SetString(PyExc_BufferError, "Writable buffer requested for readonly storage");
-        return -1;
     }
-    if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT)
+    view->readonly = static_cast<int>(info->readonly);
+    if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT) {
         view->format = const_cast<char *>(info->format.c_str());
+    }
     if ((flags & PyBUF_STRIDES) == PyBUF_STRIDES) {
         view->ndim = (int) info->ndim;
-        view->strides = &info->strides[0];
-        view->shape = &info->shape[0];
+        view->strides = info->strides.data();
+        view->shape = info->shape.data();
     }
     Py_INCREF(view->obj);
     return 0;
 }
 
 /// buffer_protocol: Release the resources of the buffer.
 extern "C" inline void pybind11_releasebuffer(PyObject *, Py_buffer *view) {
     delete (buffer_info *) view->internal;
 }
 
 /// Give this type a buffer interface.
 inline void enable_buffer_protocol(PyHeapTypeObject *heap_type) {
     heap_type->ht_type.tp_as_buffer = &heap_type->as_buffer;
-#if PY_MAJOR_VERSION < 3
-    heap_type->ht_type.tp_flags |= Py_TPFLAGS_HAVE_NEWBUFFER;
-#endif
 
     heap_type->as_buffer.bf_getbuffer = pybind11_getbuffer;
     heap_type->as_buffer.bf_releasebuffer = pybind11_releasebuffer;
 }
 
 /** Create a brand new Python type according to the `type_record` specification.
     Return value: New reference. */
-inline PyObject* make_new_python_type(const type_record &rec) {
+inline PyObject *make_new_python_type(const type_record &rec) {
     auto name = reinterpret_steal<object>(PYBIND11_FROM_STRING(rec.name));
 
     auto qualname = name;
     if (rec.scope && !PyModule_Check(rec.scope.ptr()) && hasattr(rec.scope, "__qualname__")) {
-#if PY_MAJOR_VERSION >= 3
         qualname = reinterpret_steal<object>(
             PyUnicode_FromFormat("%U.%U", rec.scope.attr("__qualname__").ptr(), name.ptr()));
-#else
-        qualname = str(rec.scope.attr("__qualname__").cast<std::string>() + "." + rec.name);
-#endif
     }
 
-    object module;
+    object module_;
     if (rec.scope) {
-        if (hasattr(rec.scope, "__module__"))
-            module = rec.scope.attr("__module__");
-        else if (hasattr(rec.scope, "__name__"))
-            module = rec.scope.attr("__name__");
+        if (hasattr(rec.scope, "__module__")) {
+            module_ = rec.scope.attr("__module__");
+        } else if (hasattr(rec.scope, "__name__")) {
+            module_ = rec.scope.attr("__name__");
+        }
     }
 
-    auto full_name = c_str(
+    const auto *full_name = c_str(
 #if !defined(PYPY_VERSION)
-        module ? str(module).cast<std::string>() + "." + rec.name :
+        module_ ? str(module_).cast<std::string>() + "." + rec.name :
 #endif
-        rec.name);
+                rec.name);
 
     char *tp_doc = nullptr;
     if (rec.doc && options::show_user_defined_docstrings()) {
         /* Allocate memory for docstring (using PyObject_MALLOC, since
            Python will free this later on) */
-        size_t size = strlen(rec.doc) + 1;
+        size_t size = std::strlen(rec.doc) + 1;
         tp_doc = (char *) PyObject_MALLOC(size);
-        memcpy((void *) tp_doc, rec.doc, size);
+        std::memcpy((void *) tp_doc, rec.doc, size);
     }
 
     auto &internals = get_internals();
     auto bases = tuple(rec.bases);
-    auto base = (bases.size() == 0) ? internals.instance_base
-                                    : bases[0].ptr();
+    auto *base = (bases.empty()) ? internals.instance_base : bases[0].ptr();
 
     /* Danger zone: from now (and until PyType_Ready), make sure to
        issue no Python C API calls which could potentially invoke the
        garbage collector (the GC will call type_traverse(), which will in
        turn find the newly constructed type in an invalid state) */
-    auto metaclass = rec.metaclass.ptr() ? (PyTypeObject *) rec.metaclass.ptr()
-                                         : internals.default_metaclass;
+    auto *metaclass
+        = rec.metaclass.ptr() ? (PyTypeObject *) rec.metaclass.ptr() : internals.default_metaclass;
 
-    auto heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);
-    if (!heap_type)
+    auto *heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);
+    if (!heap_type) {
         pybind11_fail(std::string(rec.name) + ": Unable to create type object!");
+    }
 
     heap_type->ht_name = name.release().ptr();
 #ifdef PYBIND11_BUILTIN_QUALNAME
     heap_type->ht_qualname = qualname.inc_ref().ptr();
 #endif
 
-    auto type = &heap_type->ht_type;
+    auto *type = &heap_type->ht_type;
     type->tp_name = full_name;
     type->tp_doc = tp_doc;
-    type->tp_base = type_incref((PyTypeObject *)base);
+    type->tp_base = type_incref((PyTypeObject *) base);
     type->tp_basicsize = static_cast<ssize_t>(sizeof(instance));
-    if (bases.size() > 0)
+    if (!bases.empty()) {
         type->tp_bases = bases.release().ptr();
+    }
 
     /* Don't inherit base __init__ */
     type->tp_init = pybind11_object_init;
 
     /* Supported protocols */
     type->tp_as_number = &heap_type->as_number;
     type->tp_as_sequence = &heap_type->as_sequence;
     type->tp_as_mapping = &heap_type->as_mapping;
-#if PY_VERSION_HEX >= 0x03050000
     type->tp_as_async = &heap_type->as_async;
-#endif
 
     /* Flags */
     type->tp_flags |= Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE;
-#if PY_MAJOR_VERSION < 3
-    type->tp_flags |= Py_TPFLAGS_CHECKTYPES;
-#endif
-    if (!rec.is_final)
+    if (!rec.is_final) {
         type->tp_flags |= Py_TPFLAGS_BASETYPE;
+    }
 
-    if (rec.dynamic_attr)
+    if (rec.dynamic_attr) {
         enable_dynamic_attributes(heap_type);
+    }
 
-    if (rec.buffer_protocol)
+    if (rec.buffer_protocol) {
         enable_buffer_protocol(heap_type);
+    }
 
-    if (PyType_Ready(type) < 0)
-        pybind11_fail(std::string(rec.name) + ": PyType_Ready failed (" + error_string() + ")!");
+    if (rec.custom_type_setup_callback) {
+        rec.custom_type_setup_callback(heap_type);
+    }
 
-    assert(rec.dynamic_attr ? PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC)
-                            : !PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));
+    if (PyType_Ready(type) < 0) {
+        pybind11_fail(std::string(rec.name) + ": PyType_Ready failed: " + error_string());
+    }
+
+    assert(!rec.dynamic_attr || PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));
 
     /* Register type with the parent scope */
-    if (rec.scope)
+    if (rec.scope) {
         setattr(rec.scope, rec.name, (PyObject *) type);
-    else
+    } else {
         Py_INCREF(type); // Keep it alive forever (reference leak)
+    }
 
-    if (module) // Needed by pydoc
-        setattr((PyObject *) type, "__module__", module);
+    if (module_) { // Needed by pydoc
+        setattr((PyObject *) type, "__module__", module_);
+    }
 
     PYBIND11_SET_OLDPY_QUALNAME(type, qualname);
 
     return (PyObject *) type;
 }
 
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/detail/common.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/detail/common.h`

 * *Files 18% similar despite different names*

```diff
@@ -5,313 +5,488 @@
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
-#if !defined(NAMESPACE_BEGIN)
-#  define NAMESPACE_BEGIN(name) namespace name {
+#define PYBIND11_VERSION_MAJOR 2
+#define PYBIND11_VERSION_MINOR 11
+#define PYBIND11_VERSION_PATCH 0.dev1
+
+// Similar to Python's convention: https://docs.python.org/3/c-api/apiabiversion.html
+// Additional convention: 0xD = dev
+#define PYBIND11_VERSION_HEX 0x020B00D1
+
+// Define some generic pybind11 helper macros for warning management.
+//
+// Note that compiler-specific push/pop pairs are baked into the
+// PYBIND11_NAMESPACE_BEGIN/PYBIND11_NAMESPACE_END pair of macros. Therefore manual
+// PYBIND11_WARNING_PUSH/PYBIND11_WARNING_POP are usually only needed in `#include` sections.
+//
+// If you find you need to suppress a warning, please try to make the suppression as local as
+// possible using these macros. Please also be sure to push/pop with the pybind11 macros. Please
+// only use compiler specifics if you need to check specific versions, e.g. Apple Clang vs. vanilla
+// Clang.
+#if defined(_MSC_VER)
+#    define PYBIND11_COMPILER_MSVC
+#    define PYBIND11_PRAGMA(...) __pragma(__VA_ARGS__)
+#    define PYBIND11_WARNING_PUSH PYBIND11_PRAGMA(warning(push))
+#    define PYBIND11_WARNING_POP PYBIND11_PRAGMA(warning(pop))
+#elif defined(__INTEL_COMPILER)
+#    define PYBIND11_COMPILER_INTEL
+#    define PYBIND11_PRAGMA(...) _Pragma(#__VA_ARGS__)
+#    define PYBIND11_WARNING_PUSH PYBIND11_PRAGMA(warning push)
+#    define PYBIND11_WARNING_POP PYBIND11_PRAGMA(warning pop)
+#elif defined(__clang__)
+#    define PYBIND11_COMPILER_CLANG
+#    define PYBIND11_PRAGMA(...) _Pragma(#__VA_ARGS__)
+#    define PYBIND11_WARNING_PUSH PYBIND11_PRAGMA(clang diagnostic push)
+#    define PYBIND11_WARNING_POP PYBIND11_PRAGMA(clang diagnostic push)
+#elif defined(__GNUC__)
+#    define PYBIND11_COMPILER_GCC
+#    define PYBIND11_PRAGMA(...) _Pragma(#__VA_ARGS__)
+#    define PYBIND11_WARNING_PUSH PYBIND11_PRAGMA(GCC diagnostic push)
+#    define PYBIND11_WARNING_POP PYBIND11_PRAGMA(GCC diagnostic pop)
 #endif
-#if !defined(NAMESPACE_END)
-#  define NAMESPACE_END(name) }
+
+#ifdef PYBIND11_COMPILER_MSVC
+#    define PYBIND11_WARNING_DISABLE_MSVC(name) PYBIND11_PRAGMA(warning(disable : name))
+#else
+#    define PYBIND11_WARNING_DISABLE_MSVC(name)
 #endif
 
+#ifdef PYBIND11_COMPILER_CLANG
+#    define PYBIND11_WARNING_DISABLE_CLANG(name) PYBIND11_PRAGMA(clang diagnostic ignored name)
+#else
+#    define PYBIND11_WARNING_DISABLE_CLANG(name)
+#endif
+
+#ifdef PYBIND11_COMPILER_GCC
+#    define PYBIND11_WARNING_DISABLE_GCC(name) PYBIND11_PRAGMA(GCC diagnostic ignored name)
+#else
+#    define PYBIND11_WARNING_DISABLE_GCC(name)
+#endif
+
+#ifdef PYBIND11_COMPILER_INTEL
+#    define PYBIND11_WARNING_DISABLE_INTEL(name) PYBIND11_PRAGMA(warning disable name)
+#else
+#    define PYBIND11_WARNING_DISABLE_INTEL(name)
+#endif
+
+#define PYBIND11_NAMESPACE_BEGIN(name)                                                            \
+    namespace name {                                                                              \
+    PYBIND11_WARNING_PUSH
+
+#define PYBIND11_NAMESPACE_END(name)                                                              \
+    PYBIND11_WARNING_POP                                                                          \
+    }
+
 // Robust support for some features and loading modules compiled against different pybind versions
-// requires forcing hidden visibility on pybind code, so we enforce this by setting the attribute on
-// the main `pybind11` namespace.
+// requires forcing hidden visibility on pybind code, so we enforce this by setting the attribute
+// on the main `pybind11` namespace.
 #if !defined(PYBIND11_NAMESPACE)
-#  ifdef __GNUG__
-#    define PYBIND11_NAMESPACE pybind11 __attribute__((visibility("hidden")))
-#  else
-#    define PYBIND11_NAMESPACE pybind11
-#  endif
+#    ifdef __GNUG__
+#        define PYBIND11_NAMESPACE pybind11 __attribute__((visibility("hidden")))
+#    else
+#        define PYBIND11_NAMESPACE pybind11
+#    endif
 #endif
 
-#if !(defined(_MSC_VER) && __cplusplus == 199711L) && !defined(__INTEL_COMPILER)
-#  if __cplusplus >= 201402L
-#    define PYBIND11_CPP14
-#    if __cplusplus >= 201703L
-#      define PYBIND11_CPP17
+#if !(defined(_MSC_VER) && __cplusplus == 199711L)
+#    if __cplusplus >= 201402L
+#        define PYBIND11_CPP14
+#        if __cplusplus >= 201703L
+#            define PYBIND11_CPP17
+#            if __cplusplus >= 202002L
+#                define PYBIND11_CPP20
+// Please update tests/pybind11_tests.cpp `cpp_std()` when adding a macro here.
+#            endif
+#        endif
 #    endif
-#  endif
 #elif defined(_MSC_VER) && __cplusplus == 199711L
-// MSVC sets _MSVC_LANG rather than __cplusplus (supposedly until the standard is fully implemented)
-// Unless you use the /Zc:__cplusplus flag on Visual Studio 2017 15.7 Preview 3 or newer
-#  if _MSVC_LANG >= 201402L
-#    define PYBIND11_CPP14
-#    if _MSVC_LANG > 201402L && _MSC_VER >= 1910
-#      define PYBIND11_CPP17
+// MSVC sets _MSVC_LANG rather than __cplusplus (supposedly until the standard is fully
+// implemented). Unless you use the /Zc:__cplusplus flag on Visual Studio 2017 15.7 Preview 3
+// or newer.
+#    if _MSVC_LANG >= 201402L
+#        define PYBIND11_CPP14
+#        if _MSVC_LANG > 201402L
+#            define PYBIND11_CPP17
+#            if _MSVC_LANG >= 202002L
+#                define PYBIND11_CPP20
+#            endif
+#        endif
 #    endif
-#  endif
 #endif
 
 // Compiler version assertions
 #if defined(__INTEL_COMPILER)
-#  if __INTEL_COMPILER < 1700
-#    error pybind11 requires Intel C++ compiler v17 or newer
-#  endif
+#    if __INTEL_COMPILER < 1800
+#        error pybind11 requires Intel C++ compiler v18 or newer
+#    elif __INTEL_COMPILER < 1900 && defined(PYBIND11_CPP14)
+#        error pybind11 supports only C++11 with Intel C++ compiler v18. Use v19 or newer for C++14.
+#    endif
+/* The following pragma cannot be pop'ed:
+   https://community.intel.com/t5/Intel-C-Compiler/Inline-and-no-inline-warning/td-p/1216764 */
+#    pragma warning disable 2196 // warning #2196: routine is both "inline" and "noinline"
 #elif defined(__clang__) && !defined(__apple_build_version__)
-#  if __clang_major__ < 3 || (__clang_major__ == 3 && __clang_minor__ < 3)
-#    error pybind11 requires clang 3.3 or newer
-#  endif
+#    if __clang_major__ < 3 || (__clang_major__ == 3 && __clang_minor__ < 3)
+#        error pybind11 requires clang 3.3 or newer
+#    endif
 #elif defined(__clang__)
 // Apple changes clang version macros to its Xcode version; the first Xcode release based on
 // (upstream) clang 3.3 was Xcode 5:
-#  if __clang_major__ < 5
-#    error pybind11 requires Xcode/clang 5.0 or newer
-#  endif
+#    if __clang_major__ < 5
+#        error pybind11 requires Xcode/clang 5.0 or newer
+#    endif
 #elif defined(__GNUG__)
-#  if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8)
-#    error pybind11 requires gcc 4.8 or newer
-#  endif
+#    if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8)
+#        error pybind11 requires gcc 4.8 or newer
+#    endif
 #elif defined(_MSC_VER)
-// Pybind hits various compiler bugs in 2015u2 and earlier, and also makes use of some stl features
-// (e.g. std::negation) added in 2015u3:
-#  if _MSC_FULL_VER < 190024210
-#    error pybind11 requires MSVC 2015 update 3 or newer
-#  endif
+#    if _MSC_VER < 1910
+#        error pybind11 2.10+ requires MSVC 2017 or newer
+#    endif
 #endif
 
 #if !defined(PYBIND11_EXPORT)
-#  if defined(WIN32) || defined(_WIN32)
-#    define PYBIND11_EXPORT __declspec(dllexport)
-#  else
-#    define PYBIND11_EXPORT __attribute__ ((visibility("default")))
-#  endif
+#    if defined(WIN32) || defined(_WIN32)
+#        define PYBIND11_EXPORT __declspec(dllexport)
+#    else
+#        define PYBIND11_EXPORT __attribute__((visibility("default")))
+#    endif
 #endif
 
-#if defined(_MSC_VER)
-#  define PYBIND11_NOINLINE __declspec(noinline)
+#if !defined(PYBIND11_EXPORT_EXCEPTION)
+#    if defined(__apple_build_version__)
+#        define PYBIND11_EXPORT_EXCEPTION PYBIND11_EXPORT
+#    else
+#        define PYBIND11_EXPORT_EXCEPTION
+#    endif
+#endif
+
+// For CUDA, GCC7, GCC8:
+// PYBIND11_NOINLINE_FORCED is incompatible with `-Wattributes -Werror`.
+// When defining PYBIND11_NOINLINE_FORCED, it is best to also use `-Wno-attributes`.
+// However, the measured shared-library size saving when using noinline are only
+// 1.7% for CUDA, -0.2% for GCC7, and 0.0% for GCC8 (using -DCMAKE_BUILD_TYPE=MinSizeRel,
+// the default under pybind11/tests).
+#if !defined(PYBIND11_NOINLINE_FORCED)                                                            \
+    && (defined(__CUDACC__) || (defined(__GNUC__) && (__GNUC__ == 7 || __GNUC__ == 8)))
+#    define PYBIND11_NOINLINE_DISABLED
+#endif
+
+// The PYBIND11_NOINLINE macro is for function DEFINITIONS.
+// In contrast, FORWARD DECLARATIONS should never use this macro:
+// https://stackoverflow.com/questions/9317473/forward-declaration-of-inline-functions
+#if defined(PYBIND11_NOINLINE_DISABLED) // Option for maximum portability and experimentation.
+#    define PYBIND11_NOINLINE inline
+#elif defined(_MSC_VER)
+#    define PYBIND11_NOINLINE __declspec(noinline) inline
 #else
-#  define PYBIND11_NOINLINE __attribute__ ((noinline))
+#    define PYBIND11_NOINLINE __attribute__((noinline)) inline
 #endif
 
-#if defined(PYBIND11_CPP14)
-#  define PYBIND11_DEPRECATED(reason) [[deprecated(reason)]]
+#if defined(__MINGW32__)
+// For unknown reasons all PYBIND11_DEPRECATED member trigger a warning when declared
+// whether it is used or not
+#    define PYBIND11_DEPRECATED(reason)
+#elif defined(PYBIND11_CPP14)
+#    define PYBIND11_DEPRECATED(reason) [[deprecated(reason)]]
 #else
-#  define PYBIND11_DEPRECATED(reason) __attribute__((deprecated(reason)))
+#    define PYBIND11_DEPRECATED(reason) __attribute__((deprecated(reason)))
 #endif
 
-#define PYBIND11_VERSION_MAJOR 2
-#define PYBIND11_VERSION_MINOR 5
-#define PYBIND11_VERSION_PATCH dev1
+#if defined(PYBIND11_CPP17)
+#    define PYBIND11_MAYBE_UNUSED [[maybe_unused]]
+#elif defined(_MSC_VER) && !defined(__clang__)
+#    define PYBIND11_MAYBE_UNUSED
+#else
+#    define PYBIND11_MAYBE_UNUSED __attribute__((__unused__))
+#endif
+
+/* Don't let Python.h #define (v)snprintf as macro because they are implemented
+   properly in Visual Studio since 2015. */
+#if defined(_MSC_VER)
+#    define HAVE_SNPRINTF 1
+#endif
 
 /// Include Python header, disable linking to pythonX_d.lib on Windows in debug mode
 #if defined(_MSC_VER)
-#  if (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION < 4)
-#    define HAVE_ROUND 1
-#  endif
-#  pragma warning(push)
-#  pragma warning(disable: 4510 4610 4512 4005)
-#  if defined(_DEBUG) && !defined(Py_DEBUG)
-#    define PYBIND11_DEBUG_MARKER
-#    undef _DEBUG
-#  endif
+PYBIND11_WARNING_PUSH
+PYBIND11_WARNING_DISABLE_MSVC(4505)
+// C4505: 'PySlice_GetIndicesEx': unreferenced local function has been removed (PyPy only)
+#    if defined(_DEBUG) && !defined(Py_DEBUG)
+// Workaround for a VS 2022 issue.
+// NOTE: This workaround knowingly violates the Python.h include order requirement:
+// https://docs.python.org/3/c-api/intro.html#include-files
+// See https://github.com/pybind/pybind11/pull/3497 for full context.
+#        include <yvals.h>
+#        if _MSVC_STL_VERSION >= 143
+#            include <crtdefs.h>
+#        endif
+#        define PYBIND11_DEBUG_MARKER
+#        undef _DEBUG
+#    endif
+#endif
+
+// https://en.cppreference.com/w/c/chrono/localtime
+#if defined(__STDC_LIB_EXT1__) && !defined(__STDC_WANT_LIB_EXT1__)
+#    define __STDC_WANT_LIB_EXT1__
+#endif
+
+#ifdef __has_include
+// std::optional (but including it in c++14 mode isn't allowed)
+#    if defined(PYBIND11_CPP17) && __has_include(<optional>)
+#        define PYBIND11_HAS_OPTIONAL 1
+#    endif
+// std::experimental::optional (but not allowed in c++11 mode)
+#    if defined(PYBIND11_CPP14) && (__has_include(<experimental/optional>) && \
+                                 !__has_include(<optional>))
+#        define PYBIND11_HAS_EXP_OPTIONAL 1
+#    endif
+// std::variant
+#    if defined(PYBIND11_CPP17) && __has_include(<variant>)
+#        define PYBIND11_HAS_VARIANT 1
+#    endif
+#elif defined(_MSC_VER) && defined(PYBIND11_CPP17)
+#    define PYBIND11_HAS_OPTIONAL 1
+#    define PYBIND11_HAS_VARIANT 1
+#endif
+
+#if defined(PYBIND11_CPP17)
+#    if defined(__has_include)
+#        if __has_include(<string_view>)
+#            define PYBIND11_HAS_STRING_VIEW
+#        endif
+#    elif defined(_MSC_VER)
+#        define PYBIND11_HAS_STRING_VIEW
+#    endif
 #endif
 
 #include <Python.h>
+// Reminder: WITH_THREAD is always defined if PY_VERSION_HEX >= 0x03070000
+#if PY_VERSION_HEX < 0x03060000
+#    error "PYTHON < 3.6 IS UNSUPPORTED. pybind11 v2.9 was the last to support Python 2 and 3.5."
+#endif
 #include <frameobject.h>
 #include <pythread.h>
 
 /* Python #defines overrides on all sorts of core functions, which
    tends to weak havok in C++ codebases that expect these to work
    like regular functions (potentially with several overloads) */
 #if defined(isalnum)
-#  undef isalnum
-#  undef isalpha
-#  undef islower
-#  undef isspace
-#  undef isupper
-#  undef tolower
-#  undef toupper
+#    undef isalnum
+#    undef isalpha
+#    undef islower
+#    undef isspace
+#    undef isupper
+#    undef tolower
+#    undef toupper
 #endif
 
 #if defined(copysign)
-#  undef copysign
+#    undef copysign
+#endif
+
+#if defined(PYPY_VERSION) && !defined(PYBIND11_SIMPLE_GIL_MANAGEMENT)
+#    define PYBIND11_SIMPLE_GIL_MANAGEMENT
 #endif
 
 #if defined(_MSC_VER)
-#  if defined(PYBIND11_DEBUG_MARKER)
-#    define _DEBUG
-#    undef PYBIND11_DEBUG_MARKER
-#  endif
-#  pragma warning(pop)
+#    if defined(PYBIND11_DEBUG_MARKER)
+#        define _DEBUG
+#        undef PYBIND11_DEBUG_MARKER
+#    endif
+PYBIND11_WARNING_POP
 #endif
 
 #include <cstddef>
 #include <cstring>
+#include <exception>
 #include <forward_list>
-#include <vector>
-#include <string>
-#include <stdexcept>
-#include <unordered_set>
-#include <unordered_map>
 #include <memory>
-#include <typeindex>
+#include <stdexcept>
+#include <string>
 #include <type_traits>
+#include <typeindex>
+#include <unordered_map>
+#include <unordered_set>
+#include <vector>
+#if defined(__has_include)
+#    if __has_include(<version>)
+#        include <version>
+#    endif
+#endif
+
+// Must be after including <version> or one of the other headers specified by the standard
+#if defined(__cpp_lib_char8_t) && __cpp_lib_char8_t >= 201811L
+#    define PYBIND11_HAS_U8STRING
+#endif
+
+// See description of PR #4246:
+#if !defined(NDEBUG) && !defined(PY_ASSERT_GIL_HELD_INCREF_DECREF)                                \
+    && !(defined(PYPY_VERSION)                                                                    \
+         && defined(_MSC_VER)) /* PyPy Windows: pytest hangs indefinitely at the end of the       \
+                                  process (see PR #4268) */                                       \
+    && !defined(PYBIND11_ASSERT_GIL_HELD_INCREF_DECREF)
+#    define PYBIND11_ASSERT_GIL_HELD_INCREF_DECREF
+#endif
+
+// #define PYBIND11_STR_LEGACY_PERMISSIVE
+// If DEFINED, pybind11::str can hold PyUnicodeObject or PyBytesObject
+//             (probably surprising and never documented, but this was the
+//             legacy behavior until and including v2.6.x). As a side-effect,
+//             pybind11::isinstance<str>() is true for both pybind11::str and
+//             pybind11::bytes.
+// If UNDEFINED, pybind11::str can only hold PyUnicodeObject, and
+//               pybind11::isinstance<str>() is true only for pybind11::str.
+//               However, for Python 2 only (!), the pybind11::str caster
+//               implicitly decoded bytes to PyUnicodeObject. This was to ease
+//               the transition from the legacy behavior to the non-permissive
+//               behavior.
 
-#if PY_MAJOR_VERSION >= 3 /// Compatibility macros for various Python versions
+/// Compatibility macros for Python 2 / Python 3 versions TODO: remove
 #define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyInstanceMethod_New(ptr)
 #define PYBIND11_INSTANCE_METHOD_CHECK PyInstanceMethod_Check
 #define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyInstanceMethod_GET_FUNCTION
 #define PYBIND11_BYTES_CHECK PyBytes_Check
 #define PYBIND11_BYTES_FROM_STRING PyBytes_FromString
 #define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyBytes_FromStringAndSize
 #define PYBIND11_BYTES_AS_STRING_AND_SIZE PyBytes_AsStringAndSize
 #define PYBIND11_BYTES_AS_STRING PyBytes_AsString
 #define PYBIND11_BYTES_SIZE PyBytes_Size
 #define PYBIND11_LONG_CHECK(o) PyLong_Check(o)
 #define PYBIND11_LONG_AS_LONGLONG(o) PyLong_AsLongLong(o)
-#define PYBIND11_LONG_FROM_SIGNED(o) PyLong_FromSsize_t((ssize_t) o)
-#define PYBIND11_LONG_FROM_UNSIGNED(o) PyLong_FromSize_t((size_t) o)
+#define PYBIND11_LONG_FROM_SIGNED(o) PyLong_FromSsize_t((ssize_t) (o))
+#define PYBIND11_LONG_FROM_UNSIGNED(o) PyLong_FromSize_t((size_t) (o))
 #define PYBIND11_BYTES_NAME "bytes"
 #define PYBIND11_STRING_NAME "str"
 #define PYBIND11_SLICE_OBJECT PyObject
 #define PYBIND11_FROM_STRING PyUnicode_FromString
 #define PYBIND11_STR_TYPE ::pybind11::str
 #define PYBIND11_BOOL_ATTR "__bool__"
 #define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_bool)
-// Providing a separate declaration to make Clang's -Wmissing-prototypes happy
-#define PYBIND11_PLUGIN_IMPL(name) \
-    extern "C" PYBIND11_EXPORT PyObject *PyInit_##name();   \
+#define PYBIND11_BUILTINS_MODULE "builtins"
+// Providing a separate declaration to make Clang's -Wmissing-prototypes happy.
+// See comment for PYBIND11_MODULE below for why this is marked "maybe unused".
+#define PYBIND11_PLUGIN_IMPL(name)                                                                \
+    extern "C" PYBIND11_MAYBE_UNUSED PYBIND11_EXPORT PyObject *PyInit_##name();                   \
     extern "C" PYBIND11_EXPORT PyObject *PyInit_##name()
 
-#else
-#define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyMethod_New(ptr, nullptr, class_)
-#define PYBIND11_INSTANCE_METHOD_CHECK PyMethod_Check
-#define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyMethod_GET_FUNCTION
-#define PYBIND11_BYTES_CHECK PyString_Check
-#define PYBIND11_BYTES_FROM_STRING PyString_FromString
-#define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyString_FromStringAndSize
-#define PYBIND11_BYTES_AS_STRING_AND_SIZE PyString_AsStringAndSize
-#define PYBIND11_BYTES_AS_STRING PyString_AsString
-#define PYBIND11_BYTES_SIZE PyString_Size
-#define PYBIND11_LONG_CHECK(o) (PyInt_Check(o) || PyLong_Check(o))
-#define PYBIND11_LONG_AS_LONGLONG(o) (PyInt_Check(o) ? (long long) PyLong_AsLong(o) : PyLong_AsLongLong(o))
-#define PYBIND11_LONG_FROM_SIGNED(o) PyInt_FromSsize_t((ssize_t) o) // Returns long if needed.
-#define PYBIND11_LONG_FROM_UNSIGNED(o) PyInt_FromSize_t((size_t) o) // Returns long if needed.
-#define PYBIND11_BYTES_NAME "str"
-#define PYBIND11_STRING_NAME "unicode"
-#define PYBIND11_SLICE_OBJECT PySliceObject
-#define PYBIND11_FROM_STRING PyString_FromString
-#define PYBIND11_STR_TYPE ::pybind11::bytes
-#define PYBIND11_BOOL_ATTR "__nonzero__"
-#define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_nonzero)
-// Providing a separate PyInit decl to make Clang's -Wmissing-prototypes happy
-#define PYBIND11_PLUGIN_IMPL(name) \
-    static PyObject *pybind11_init_wrapper();               \
-    extern "C" PYBIND11_EXPORT void init##name();           \
-    extern "C" PYBIND11_EXPORT void init##name() {          \
-        (void)pybind11_init_wrapper();                      \
-    }                                                       \
-    PyObject *pybind11_init_wrapper()
-#endif
-
-#if PY_VERSION_HEX >= 0x03050000 && PY_VERSION_HEX < 0x03050200
-extern "C" {
-    struct _Py_atomic_address { void *value; };
-    PyAPI_DATA(_Py_atomic_address) _PyThreadState_Current;
-}
-#endif
-
 #define PYBIND11_TRY_NEXT_OVERLOAD ((PyObject *) 1) // special failure return code
 #define PYBIND11_STRINGIFY(x) #x
 #define PYBIND11_TOSTRING(x) PYBIND11_STRINGIFY(x)
 #define PYBIND11_CONCAT(first, second) first##second
-#define PYBIND11_ENSURE_INTERNALS_READY \
-    pybind11::detail::get_internals();
+#define PYBIND11_ENSURE_INTERNALS_READY pybind11::detail::get_internals();
 
-#define PYBIND11_CHECK_PYTHON_VERSION \
-    {                                                                          \
-        const char *compiled_ver = PYBIND11_TOSTRING(PY_MAJOR_VERSION)         \
-            "." PYBIND11_TOSTRING(PY_MINOR_VERSION);                           \
-        const char *runtime_ver = Py_GetVersion();                             \
-        size_t len = std::strlen(compiled_ver);                                \
-        if (std::strncmp(runtime_ver, compiled_ver, len) != 0                  \
-                || (runtime_ver[len] >= '0' && runtime_ver[len] <= '9')) {     \
-            PyErr_Format(PyExc_ImportError,                                    \
-                "Python version mismatch: module was compiled for Python %s, " \
-                "but the interpreter version is incompatible: %s.",            \
-                compiled_ver, runtime_ver);                                    \
-            return nullptr;                                                    \
-        }                                                                      \
+#define PYBIND11_CHECK_PYTHON_VERSION                                                             \
+    {                                                                                             \
+        const char *compiled_ver                                                                  \
+            = PYBIND11_TOSTRING(PY_MAJOR_VERSION) "." PYBIND11_TOSTRING(PY_MINOR_VERSION);        \
+        const char *runtime_ver = Py_GetVersion();                                                \
+        size_t len = std::strlen(compiled_ver);                                                   \
+        if (std::strncmp(runtime_ver, compiled_ver, len) != 0                                     \
+            || (runtime_ver[len] >= '0' && runtime_ver[len] <= '9')) {                            \
+            PyErr_Format(PyExc_ImportError,                                                       \
+                         "Python version mismatch: module was compiled for Python %s, "           \
+                         "but the interpreter version is incompatible: %s.",                      \
+                         compiled_ver,                                                            \
+                         runtime_ver);                                                            \
+            return nullptr;                                                                       \
+        }                                                                                         \
     }
 
-#define PYBIND11_CATCH_INIT_EXCEPTIONS \
-        catch (pybind11::error_already_set &e) {                               \
-            PyErr_SetString(PyExc_ImportError, e.what());                      \
-            return nullptr;                                                    \
-        } catch (const std::exception &e) {                                    \
-            PyErr_SetString(PyExc_ImportError, e.what());                      \
-            return nullptr;                                                    \
-        }                                                                      \
+#define PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \
+    catch (pybind11::error_already_set & e) {                                                     \
+        pybind11::raise_from(e, PyExc_ImportError, "initialization failed");                      \
+        return nullptr;                                                                           \
+    }                                                                                             \
+    catch (const std::exception &e) {                                                             \
+        PyErr_SetString(PyExc_ImportError, e.what());                                             \
+        return nullptr;                                                                           \
+    }
 
 /** \rst
     ***Deprecated in favor of PYBIND11_MODULE***
 
     This macro creates the entry point that will be invoked when the Python interpreter
-    imports a plugin library. Please create a `module` in the function body and return
+    imports a plugin library. Please create a `module_` in the function body and return
     the pointer to its underlying Python object at the end.
 
     .. code-block:: cpp
 
         PYBIND11_PLUGIN(example) {
-            pybind11::module m("example", "pybind11 example plugin");
+            pybind11::module_ m("example", "pybind11 example plugin");
             /// Set up bindings here
             return m.ptr();
         }
 \endrst */
-#define PYBIND11_PLUGIN(name)                                                  \
-    PYBIND11_DEPRECATED("PYBIND11_PLUGIN is deprecated, use PYBIND11_MODULE")  \
-    static PyObject *pybind11_init();                                          \
-    PYBIND11_PLUGIN_IMPL(name) {                                               \
-        PYBIND11_CHECK_PYTHON_VERSION                                          \
-        PYBIND11_ENSURE_INTERNALS_READY                                        \
-        try {                                                                  \
-            return pybind11_init();                                            \
-        } PYBIND11_CATCH_INIT_EXCEPTIONS                                       \
-    }                                                                          \
+#define PYBIND11_PLUGIN(name)                                                                     \
+    PYBIND11_DEPRECATED("PYBIND11_PLUGIN is deprecated, use PYBIND11_MODULE")                     \
+    static PyObject *pybind11_init();                                                             \
+    PYBIND11_PLUGIN_IMPL(name) {                                                                  \
+        PYBIND11_CHECK_PYTHON_VERSION                                                             \
+        PYBIND11_ENSURE_INTERNALS_READY                                                           \
+        try {                                                                                     \
+            return pybind11_init();                                                               \
+        }                                                                                         \
+        PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \
+    }                                                                                             \
     PyObject *pybind11_init()
 
 /** \rst
     This macro creates the entry point that will be invoked when the Python interpreter
-    imports an extension module. The module name is given as the fist argument and it
+    imports an extension module. The module name is given as the first argument and it
     should not be in quotes. The second macro argument defines a variable of type
-    `py::module` which can be used to initialize the module.
+    `py::module_` which can be used to initialize the module.
+
+    The entry point is marked as "maybe unused" to aid dead-code detection analysis:
+    since the entry point is typically only looked up at runtime and not referenced
+    during translation, it would otherwise appear as unused ("dead") code.
 
     .. code-block:: cpp
 
         PYBIND11_MODULE(example, m) {
             m.doc() = "pybind11 example module";
 
             // Add bindings here
             m.def("foo", []() {
                 return "Hello, World!";
             });
         }
 \endrst */
-#define PYBIND11_MODULE(name, variable)                                        \
-    static void PYBIND11_CONCAT(pybind11_init_, name)(pybind11::module &);     \
-    PYBIND11_PLUGIN_IMPL(name) {                                               \
-        PYBIND11_CHECK_PYTHON_VERSION                                          \
-        PYBIND11_ENSURE_INTERNALS_READY                                        \
-        auto m = pybind11::module(PYBIND11_TOSTRING(name));                    \
-        try {                                                                  \
-            PYBIND11_CONCAT(pybind11_init_, name)(m);                          \
-            return m.ptr();                                                    \
-        } PYBIND11_CATCH_INIT_EXCEPTIONS                                       \
-    }                                                                          \
-    void PYBIND11_CONCAT(pybind11_init_, name)(pybind11::module &variable)
-
+#define PYBIND11_MODULE(name, variable)                                                           \
+    static ::pybind11::module_::module_def PYBIND11_CONCAT(pybind11_module_def_, name)            \
+        PYBIND11_MAYBE_UNUSED;                                                                    \
+    PYBIND11_MAYBE_UNUSED                                                                         \
+    static void PYBIND11_CONCAT(pybind11_init_, name)(::pybind11::module_ &);                     \
+    PYBIND11_PLUGIN_IMPL(name) {                                                                  \
+        PYBIND11_CHECK_PYTHON_VERSION                                                             \
+        PYBIND11_ENSURE_INTERNALS_READY                                                           \
+        auto m = ::pybind11::module_::create_extension_module(                                    \
+            PYBIND11_TOSTRING(name), nullptr, &PYBIND11_CONCAT(pybind11_module_def_, name));      \
+        try {                                                                                     \
+            PYBIND11_CONCAT(pybind11_init_, name)(m);                                             \
+            return m.ptr();                                                                       \
+        }                                                                                         \
+        PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \
+    }                                                                                             \
+    void PYBIND11_CONCAT(pybind11_init_, name)(::pybind11::module_ & (variable))
 
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 using ssize_t = Py_ssize_t;
-using size_t  = std::size_t;
+using size_t = std::size_t;
+
+template <typename IntType>
+inline ssize_t ssize_t_cast(const IntType &val) {
+    static_assert(sizeof(IntType) <= sizeof(ssize_t), "Implicit narrowing is not permitted.");
+    return static_cast<ssize_t>(val);
+}
 
 /// Approach used to cast a previously unknown C++ instance into a Python object
 enum class return_value_policy : uint8_t {
     /** This is the default return value policy, which falls back to the policy
         return_value_policy::take_ownership when the return value is a pointer.
         Otherwise, it uses return_value::move or return_value::copy for rvalue
         and lvalue references, respectively. See below for a description of what
@@ -322,15 +497,15 @@
         value is a pointer. This is the default conversion policy for function
         arguments when calling Python functions manually from C++ code (i.e. via
         handle::operator()). You probably won't need to use this. */
     automatic_reference,
 
     /** Reference an existing object (i.e. do not create a new copy) and take
         ownership. Python will call the destructor and delete operator when the
-        object’s reference count reaches zero. Undefined behavior ensues when
+        object's reference count reaches zero. Undefined behavior ensues when
         the C++ side does the same.. */
     take_ownership,
 
     /** Create a new copy of the returned object, which will be owned by
         Python. This policy is comparably safe because the lifetimes of the two
         instances are decoupled. */
     copy,
@@ -338,49 +513,53 @@
     /** Use std::move to move the return value contents into a new instance
         that will be owned by Python. This policy is comparably safe because the
         lifetimes of the two instances (move source and destination) are
         decoupled. */
     move,
 
     /** Reference an existing object, but do not take ownership. The C++ side
-        is responsible for managing the object’s lifetime and deallocating it
+        is responsible for managing the object's lifetime and deallocating it
         when it is no longer used. Warning: undefined behavior will ensue when
         the C++ side deletes an object that is still referenced and used by
         Python. */
     reference,
 
     /** This policy only applies to methods and properties. It references the
         object without taking ownership similar to the above
         return_value_policy::reference policy. In contrast to that policy, the
-        function or property’s implicit this argument (called the parent) is
+        function or property's implicit this argument (called the parent) is
         considered to be the the owner of the return value (the child).
         pybind11 then couples the lifetime of the parent to the child via a
         reference relationship that ensures that the parent cannot be garbage
         collected while Python is still using the child. More advanced
         variations of this scheme are also possible using combinations of
         return_value_policy::reference and the keep_alive call policy */
     reference_internal
 };
 
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(detail)
 
-inline static constexpr int log2(size_t n, int k = 0) { return (n <= 1) ? k : log2(n >> 1, k + 1); }
+inline static constexpr int log2(size_t n, int k = 0) {
+    return (n <= 1) ? k : log2(n >> 1, k + 1);
+}
 
 // Returns the size as a multiple of sizeof(void *), rounded up.
-inline static constexpr size_t size_in_ptrs(size_t s) { return 1 + ((s - 1) >> log2(sizeof(void *))); }
+inline static constexpr size_t size_in_ptrs(size_t s) {
+    return 1 + ((s - 1) >> log2(sizeof(void *)));
+}
 
 /**
  * The space to allocate for simple layout instance holders (see below) in multiple of the size of
  * a pointer (e.g.  2 means 16 bytes on 64-bit architectures).  The default is the minimum required
  * to holder either a std::unique_ptr or std::shared_ptr (which is almost always
  * sizeof(std::shared_ptr<T>)).
  */
 constexpr size_t instance_simple_holder_in_ptrs() {
     static_assert(sizeof(std::shared_ptr<int>) >= sizeof(std::unique_ptr<int>),
-            "pybind assumes std::shared_ptrs are at least as big as std::unique_ptrs");
+                  "pybind assumes std::shared_ptrs are at least as big as std::unique_ptrs");
     return size_in_ptrs(sizeof(std::shared_ptr<int>));
 }
 
 // Forward declarations
 struct type_info;
 struct value_and_holder;
 
@@ -400,421 +579,667 @@
     /// Weak references
     PyObject *weakrefs;
     /// If true, the pointer is owned which means we're free to manage it with a holder.
     bool owned : 1;
     /**
      * An instance has two possible value/holder layouts.
      *
-     * Simple layout (when this flag is true), means the `simple_value_holder` is set with a pointer
-     * and the holder object governing that pointer, i.e. [val1*][holder].  This layout is applied
-     * whenever there is no python-side multiple inheritance of bound C++ types *and* the type's
-     * holder will fit in the default space (which is large enough to hold either a std::unique_ptr
-     * or std::shared_ptr).
+     * Simple layout (when this flag is true), means the `simple_value_holder` is set with a
+     * pointer and the holder object governing that pointer, i.e. [val1*][holder].  This layout is
+     * applied whenever there is no python-side multiple inheritance of bound C++ types *and* the
+     * type's holder will fit in the default space (which is large enough to hold either a
+     * std::unique_ptr or std::shared_ptr).
      *
-     * Non-simple layout applies when using custom holders that require more space than `shared_ptr`
-     * (which is typically the size of two pointers), or when multiple inheritance is used on the
-     * python side.  Non-simple layout allocates the required amount of memory to have multiple
-     * bound C++ classes as parents.  Under this layout, `nonsimple.values_and_holders` is set to a
-     * pointer to allocated space of the required space to hold a sequence of value pointers and
-     * holders followed `status`, a set of bit flags (1 byte each), i.e.
-     * [val1*][holder1][val2*][holder2]...[bb...]  where each [block] is rounded up to a multiple of
-     * `sizeof(void *)`.  `nonsimple.status` is, for convenience, a pointer to the
-     * beginning of the [bb...] block (but not independently allocated).
+     * Non-simple layout applies when using custom holders that require more space than
+     * `shared_ptr` (which is typically the size of two pointers), or when multiple inheritance is
+     * used on the python side.  Non-simple layout allocates the required amount of memory to have
+     * multiple bound C++ classes as parents.  Under this layout, `nonsimple.values_and_holders` is
+     * set to a pointer to allocated space of the required space to hold a sequence of value
+     * pointers and holders followed `status`, a set of bit flags (1 byte each), i.e.
+     * [val1*][holder1][val2*][holder2]...[bb...]  where each [block] is rounded up to a multiple
+     * of `sizeof(void *)`.  `nonsimple.status` is, for convenience, a pointer to the beginning of
+     * the [bb...] block (but not independently allocated).
      *
      * Status bits indicate whether the associated holder is constructed (&
      * status_holder_constructed) and whether the value pointer is registered (&
      * status_instance_registered) in `registered_instances`.
      */
     bool simple_layout : 1;
     /// For simple layout, tracks whether the holder has been constructed
     bool simple_holder_constructed : 1;
     /// For simple layout, tracks whether the instance is registered in `registered_instances`
     bool simple_instance_registered : 1;
     /// If true, get_internals().patients has an entry for this object
     bool has_patients : 1;
 
-    /// Initializes all of the above type/values/holders data (but not the instance values themselves)
+    /// Initializes all of the above type/values/holders data (but not the instance values
+    /// themselves)
     void allocate_layout();
 
     /// Destroys/deallocates all of the above
     void deallocate_layout();
 
     /// Returns the value_and_holder wrapper for the given type (or the first, if `find_type`
     /// omitted).  Returns a default-constructed (with `.inst = nullptr`) object on failure if
     /// `throw_if_missing` is false.
-    value_and_holder get_value_and_holder(const type_info *find_type = nullptr, bool throw_if_missing = true);
+    value_and_holder get_value_and_holder(const type_info *find_type = nullptr,
+                                          bool throw_if_missing = true);
 
     /// Bit values for the non-simple status flags
-    static constexpr uint8_t status_holder_constructed  = 1;
+    static constexpr uint8_t status_holder_constructed = 1;
     static constexpr uint8_t status_instance_registered = 2;
 };
 
-static_assert(std::is_standard_layout<instance>::value, "Internal error: `pybind11::detail::instance` is not standard layout!");
+static_assert(std::is_standard_layout<instance>::value,
+              "Internal error: `pybind11::detail::instance` is not standard layout!");
 
 /// from __cpp_future__ import (convenient aliases from C++14/17)
-#if defined(PYBIND11_CPP14) && (!defined(_MSC_VER) || _MSC_VER >= 1910)
-using std::enable_if_t;
+#if defined(PYBIND11_CPP14)
 using std::conditional_t;
+using std::enable_if_t;
 using std::remove_cv_t;
 using std::remove_reference_t;
 #else
-template <bool B, typename T = void> using enable_if_t = typename std::enable_if<B, T>::type;
-template <bool B, typename T, typename F> using conditional_t = typename std::conditional<B, T, F>::type;
-template <typename T> using remove_cv_t = typename std::remove_cv<T>::type;
-template <typename T> using remove_reference_t = typename std::remove_reference<T>::type;
+template <bool B, typename T = void>
+using enable_if_t = typename std::enable_if<B, T>::type;
+template <bool B, typename T, typename F>
+using conditional_t = typename std::conditional<B, T, F>::type;
+template <typename T>
+using remove_cv_t = typename std::remove_cv<T>::type;
+template <typename T>
+using remove_reference_t = typename std::remove_reference<T>::type;
+#endif
+
+#if defined(PYBIND11_CPP20)
+using std::remove_cvref;
+using std::remove_cvref_t;
+#else
+template <class T>
+struct remove_cvref {
+    using type = remove_cv_t<remove_reference_t<T>>;
+};
+template <class T>
+using remove_cvref_t = typename remove_cvref<T>::type;
 #endif
 
 /// Index sequences
 #if defined(PYBIND11_CPP14)
 using std::index_sequence;
 using std::make_index_sequence;
 #else
-template<size_t ...> struct index_sequence  { };
-template<size_t N, size_t ...S> struct make_index_sequence_impl : make_index_sequence_impl <N - 1, N - 1, S...> { };
-template<size_t ...S> struct make_index_sequence_impl <0, S...> { typedef index_sequence<S...> type; };
-template<size_t N> using make_index_sequence = typename make_index_sequence_impl<N>::type;
+template <size_t...>
+struct index_sequence {};
+template <size_t N, size_t... S>
+struct make_index_sequence_impl : make_index_sequence_impl<N - 1, N - 1, S...> {};
+template <size_t... S>
+struct make_index_sequence_impl<0, S...> {
+    using type = index_sequence<S...>;
+};
+template <size_t N>
+using make_index_sequence = typename make_index_sequence_impl<N>::type;
 #endif
 
 /// Make an index sequence of the indices of true arguments
-template <typename ISeq, size_t, bool...> struct select_indices_impl { using type = ISeq; };
-template <size_t... IPrev, size_t I, bool B, bool... Bs> struct select_indices_impl<index_sequence<IPrev...>, I, B, Bs...>
-    : select_indices_impl<conditional_t<B, index_sequence<IPrev..., I>, index_sequence<IPrev...>>, I + 1, Bs...> {};
-template <bool... Bs> using select_indices = typename select_indices_impl<index_sequence<>, 0, Bs...>::type;
+template <typename ISeq, size_t, bool...>
+struct select_indices_impl {
+    using type = ISeq;
+};
+template <size_t... IPrev, size_t I, bool B, bool... Bs>
+struct select_indices_impl<index_sequence<IPrev...>, I, B, Bs...>
+    : select_indices_impl<conditional_t<B, index_sequence<IPrev..., I>, index_sequence<IPrev...>>,
+                          I + 1,
+                          Bs...> {};
+template <bool... Bs>
+using select_indices = typename select_indices_impl<index_sequence<>, 0, Bs...>::type;
 
 /// Backports of std::bool_constant and std::negation to accommodate older compilers
-template <bool B> using bool_constant = std::integral_constant<bool, B>;
-template <typename T> struct negation : bool_constant<!T::value> { };
+template <bool B>
+using bool_constant = std::integral_constant<bool, B>;
+template <typename T>
+struct negation : bool_constant<!T::value> {};
 
-template <typename...> struct void_t_impl { using type = void; };
-template <typename... Ts> using void_t = typename void_t_impl<Ts...>::type;
+// PGI/Intel cannot detect operator delete with the "compatible" void_t impl, so
+// using the new one (C++14 defect, so generally works on newer compilers, even
+// if not in C++17 mode)
+#if defined(__PGIC__) || defined(__INTEL_COMPILER)
+template <typename...>
+using void_t = void;
+#else
+template <typename...>
+struct void_t_impl {
+    using type = void;
+};
+template <typename... Ts>
+using void_t = typename void_t_impl<Ts...>::type;
+#endif
 
 /// Compile-time all/any/none of that check the boolean value of all template types
 #if defined(__cpp_fold_expressions) && !(defined(_MSC_VER) && (_MSC_VER < 1916))
-template <class... Ts> using all_of = bool_constant<(Ts::value && ...)>;
-template <class... Ts> using any_of = bool_constant<(Ts::value || ...)>;
+template <class... Ts>
+using all_of = bool_constant<(Ts::value && ...)>;
+template <class... Ts>
+using any_of = bool_constant<(Ts::value || ...)>;
 #elif !defined(_MSC_VER)
-template <bool...> struct bools {};
-template <class... Ts> using all_of = std::is_same<
-    bools<Ts::value..., true>,
-    bools<true, Ts::value...>>;
-template <class... Ts> using any_of = negation<all_of<negation<Ts>...>>;
+template <bool...>
+struct bools {};
+template <class... Ts>
+using all_of = std::is_same<bools<Ts::value..., true>, bools<true, Ts::value...>>;
+template <class... Ts>
+using any_of = negation<all_of<negation<Ts>...>>;
 #else
 // MSVC has trouble with the above, but supports std::conjunction, which we can use instead (albeit
 // at a slight loss of compilation efficiency).
-template <class... Ts> using all_of = std::conjunction<Ts...>;
-template <class... Ts> using any_of = std::disjunction<Ts...>;
-#endif
-template <class... Ts> using none_of = negation<any_of<Ts...>>;
-
-template <class T, template<class> class... Predicates> using satisfies_all_of = all_of<Predicates<T>...>;
-template <class T, template<class> class... Predicates> using satisfies_any_of = any_of<Predicates<T>...>;
-template <class T, template<class> class... Predicates> using satisfies_none_of = none_of<Predicates<T>...>;
+template <class... Ts>
+using all_of = std::conjunction<Ts...>;
+template <class... Ts>
+using any_of = std::disjunction<Ts...>;
+#endif
+template <class... Ts>
+using none_of = negation<any_of<Ts...>>;
+
+template <class T, template <class> class... Predicates>
+using satisfies_all_of = all_of<Predicates<T>...>;
+template <class T, template <class> class... Predicates>
+using satisfies_any_of = any_of<Predicates<T>...>;
+template <class T, template <class> class... Predicates>
+using satisfies_none_of = none_of<Predicates<T>...>;
 
 /// Strip the class from a method type
-template <typename T> struct remove_class { };
-template <typename C, typename R, typename... A> struct remove_class<R (C::*)(A...)> { typedef R type(A...); };
-template <typename C, typename R, typename... A> struct remove_class<R (C::*)(A...) const> { typedef R type(A...); };
-
+template <typename T>
+struct remove_class {};
+template <typename C, typename R, typename... A>
+struct remove_class<R (C::*)(A...)> {
+    using type = R(A...);
+};
+template <typename C, typename R, typename... A>
+struct remove_class<R (C::*)(A...) const> {
+    using type = R(A...);
+};
+#ifdef __cpp_noexcept_function_type
+template <typename C, typename R, typename... A>
+struct remove_class<R (C::*)(A...) noexcept> {
+    using type = R(A...);
+};
+template <typename C, typename R, typename... A>
+struct remove_class<R (C::*)(A...) const noexcept> {
+    using type = R(A...);
+};
+#endif
 /// Helper template to strip away type modifiers
-template <typename T> struct intrinsic_type                       { typedef T type; };
-template <typename T> struct intrinsic_type<const T>              { typedef typename intrinsic_type<T>::type type; };
-template <typename T> struct intrinsic_type<T*>                   { typedef typename intrinsic_type<T>::type type; };
-template <typename T> struct intrinsic_type<T&>                   { typedef typename intrinsic_type<T>::type type; };
-template <typename T> struct intrinsic_type<T&&>                  { typedef typename intrinsic_type<T>::type type; };
-template <typename T, size_t N> struct intrinsic_type<const T[N]> { typedef typename intrinsic_type<T>::type type; };
-template <typename T, size_t N> struct intrinsic_type<T[N]>       { typedef typename intrinsic_type<T>::type type; };
-template <typename T> using intrinsic_t = typename intrinsic_type<T>::type;
+template <typename T>
+struct intrinsic_type {
+    using type = T;
+};
+template <typename T>
+struct intrinsic_type<const T> {
+    using type = typename intrinsic_type<T>::type;
+};
+template <typename T>
+struct intrinsic_type<T *> {
+    using type = typename intrinsic_type<T>::type;
+};
+template <typename T>
+struct intrinsic_type<T &> {
+    using type = typename intrinsic_type<T>::type;
+};
+template <typename T>
+struct intrinsic_type<T &&> {
+    using type = typename intrinsic_type<T>::type;
+};
+template <typename T, size_t N>
+struct intrinsic_type<const T[N]> {
+    using type = typename intrinsic_type<T>::type;
+};
+template <typename T, size_t N>
+struct intrinsic_type<T[N]> {
+    using type = typename intrinsic_type<T>::type;
+};
+template <typename T>
+using intrinsic_t = typename intrinsic_type<T>::type;
 
 /// Helper type to replace 'void' in some expressions
-struct void_type { };
+struct void_type {};
 
 /// Helper template which holds a list of types
-template <typename...> struct type_list { };
+template <typename...>
+struct type_list {};
 
 /// Compile-time integer sum
 #ifdef __cpp_fold_expressions
-template <typename... Ts> constexpr size_t constexpr_sum(Ts... ns) { return (0 + ... + size_t{ns}); }
+template <typename... Ts>
+constexpr size_t constexpr_sum(Ts... ns) {
+    return (0 + ... + size_t{ns});
+}
 #else
 constexpr size_t constexpr_sum() { return 0; }
 template <typename T, typename... Ts>
-constexpr size_t constexpr_sum(T n, Ts... ns) { return size_t{n} + constexpr_sum(ns...); }
+constexpr size_t constexpr_sum(T n, Ts... ns) {
+    return size_t{n} + constexpr_sum(ns...);
+}
 #endif
 
-NAMESPACE_BEGIN(constexpr_impl)
+PYBIND11_NAMESPACE_BEGIN(constexpr_impl)
 /// Implementation details for constexpr functions
 constexpr int first(int i) { return i; }
 template <typename T, typename... Ts>
-constexpr int first(int i, T v, Ts... vs) { return v ? i : first(i + 1, vs...); }
+constexpr int first(int i, T v, Ts... vs) {
+    return v ? i : first(i + 1, vs...);
+}
 
 constexpr int last(int /*i*/, int result) { return result; }
 template <typename T, typename... Ts>
-constexpr int last(int i, int result, T v, Ts... vs) { return last(i + 1, v ? i : result, vs...); }
-NAMESPACE_END(constexpr_impl)
+constexpr int last(int i, int result, T v, Ts... vs) {
+    return last(i + 1, v ? i : result, vs...);
+}
+PYBIND11_NAMESPACE_END(constexpr_impl)
 
-/// Return the index of the first type in Ts which satisfies Predicate<T>.  Returns sizeof...(Ts) if
-/// none match.
-template <template<typename> class Predicate, typename... Ts>
-constexpr int constexpr_first() { return constexpr_impl::first(0, Predicate<Ts>::value...); }
+/// Return the index of the first type in Ts which satisfies Predicate<T>.
+/// Returns sizeof...(Ts) if none match.
+template <template <typename> class Predicate, typename... Ts>
+constexpr int constexpr_first() {
+    return constexpr_impl::first(0, Predicate<Ts>::value...);
+}
 
 /// Return the index of the last type in Ts which satisfies Predicate<T>, or -1 if none match.
-template <template<typename> class Predicate, typename... Ts>
-constexpr int constexpr_last() { return constexpr_impl::last(0, -1, Predicate<Ts>::value...); }
+template <template <typename> class Predicate, typename... Ts>
+constexpr int constexpr_last() {
+    return constexpr_impl::last(0, -1, Predicate<Ts>::value...);
+}
 
 /// Return the Nth element from the parameter pack
 template <size_t N, typename T, typename... Ts>
-struct pack_element { using type = typename pack_element<N - 1, Ts...>::type; };
+struct pack_element {
+    using type = typename pack_element<N - 1, Ts...>::type;
+};
 template <typename T, typename... Ts>
-struct pack_element<0, T, Ts...> { using type = T; };
+struct pack_element<0, T, Ts...> {
+    using type = T;
+};
 
 /// Return the one and only type which matches the predicate, or Default if none match.
 /// If more than one type matches the predicate, fail at compile-time.
-template <template<typename> class Predicate, typename Default, typename... Ts>
+template <template <typename> class Predicate, typename Default, typename... Ts>
 struct exactly_one {
     static constexpr auto found = constexpr_sum(Predicate<Ts>::value...);
     static_assert(found <= 1, "Found more than one type matching the predicate");
 
     static constexpr auto index = found ? constexpr_first<Predicate, Ts...>() : 0;
     using type = conditional_t<found, typename pack_element<index, Ts...>::type, Default>;
 };
-template <template<typename> class P, typename Default>
-struct exactly_one<P, Default> { using type = Default; };
+template <template <typename> class P, typename Default>
+struct exactly_one<P, Default> {
+    using type = Default;
+};
 
-template <template<typename> class Predicate, typename Default, typename... Ts>
+template <template <typename> class Predicate, typename Default, typename... Ts>
 using exactly_one_t = typename exactly_one<Predicate, Default, Ts...>::type;
 
 /// Defer the evaluation of type T until types Us are instantiated
-template <typename T, typename... /*Us*/> struct deferred_type { using type = T; };
-template <typename T, typename... Us> using deferred_t = typename deferred_type<T, Us...>::type;
+template <typename T, typename... /*Us*/>
+struct deferred_type {
+    using type = T;
+};
+template <typename T, typename... Us>
+using deferred_t = typename deferred_type<T, Us...>::type;
 
 /// Like is_base_of, but requires a strict base (i.e. `is_strict_base_of<T, T>::value == false`,
 /// unlike `std::is_base_of`)
-template <typename Base, typename Derived> using is_strict_base_of = bool_constant<
-    std::is_base_of<Base, Derived>::value && !std::is_same<Base, Derived>::value>;
-
-/// Like is_base_of, but also requires that the base type is accessible (i.e. that a Derived pointer
-/// can be converted to a Base pointer)
-template <typename Base, typename Derived> using is_accessible_base_of = bool_constant<
-    std::is_base_of<Base, Derived>::value && std::is_convertible<Derived *, Base *>::value>;
+template <typename Base, typename Derived>
+using is_strict_base_of
+    = bool_constant<std::is_base_of<Base, Derived>::value && !std::is_same<Base, Derived>::value>;
+
+/// Like is_base_of, but also requires that the base type is accessible (i.e. that a Derived
+/// pointer can be converted to a Base pointer) For unions, `is_base_of<T, T>::value` is False, so
+/// we need to check `is_same` as well.
+template <typename Base, typename Derived>
+using is_accessible_base_of
+    = bool_constant<(std::is_same<Base, Derived>::value || std::is_base_of<Base, Derived>::value)
+                    && std::is_convertible<Derived *, Base *>::value>;
 
-template <template<typename...> class Base>
+template <template <typename...> class Base>
 struct is_template_base_of_impl {
-    template <typename... Us> static std::true_type check(Base<Us...> *);
+    template <typename... Us>
+    static std::true_type check(Base<Us...> *);
     static std::false_type check(...);
 };
 
 /// Check if a template is the base of a type. For example:
 /// `is_template_base_of<Base, T>` is true if `struct T : Base<U> {}` where U can be anything
-template <template<typename...> class Base, typename T>
+template <template <typename...> class Base, typename T>
+// Sadly, all MSVC versions incl. 2022 need the workaround, even in C++20 mode.
+// See also: https://github.com/pybind/pybind11/pull/3741
 #if !defined(_MSC_VER)
-using is_template_base_of = decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T>*)nullptr));
-#else // MSVC2015 has trouble with decltype in template aliases
-struct is_template_base_of : decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T>*)nullptr)) { };
+using is_template_base_of
+    = decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T> *) nullptr));
+#else
+struct is_template_base_of
+    : decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T> *) nullptr)) {
+};
 #endif
 
 /// Check if T is an instantiation of the template `Class`. For example:
 /// `is_instantiation<shared_ptr, T>` is true if `T == shared_ptr<U>` where U can be anything.
-template <template<typename...> class Class, typename T>
-struct is_instantiation : std::false_type { };
-template <template<typename...> class Class, typename... Us>
-struct is_instantiation<Class, Class<Us...>> : std::true_type { };
+template <template <typename...> class Class, typename T>
+struct is_instantiation : std::false_type {};
+template <template <typename...> class Class, typename... Us>
+struct is_instantiation<Class, Class<Us...>> : std::true_type {};
 
 /// Check if T is std::shared_ptr<U> where U can be anything
-template <typename T> using is_shared_ptr = is_instantiation<std::shared_ptr, T>;
+template <typename T>
+using is_shared_ptr = is_instantiation<std::shared_ptr, T>;
 
 /// Check if T looks like an input iterator
-template <typename T, typename = void> struct is_input_iterator : std::false_type {};
+template <typename T, typename = void>
+struct is_input_iterator : std::false_type {};
 template <typename T>
-struct is_input_iterator<T, void_t<decltype(*std::declval<T &>()), decltype(++std::declval<T &>())>>
+struct is_input_iterator<T,
+                         void_t<decltype(*std::declval<T &>()), decltype(++std::declval<T &>())>>
     : std::true_type {};
 
-template <typename T> using is_function_pointer = bool_constant<
-    std::is_pointer<T>::value && std::is_function<typename std::remove_pointer<T>::type>::value>;
-
-template <typename F> struct strip_function_object {
+template <typename T>
+using is_function_pointer
+    = bool_constant<std::is_pointer<T>::value
+                    && std::is_function<typename std::remove_pointer<T>::type>::value>;
+
+template <typename F>
+struct strip_function_object {
+    // If you are encountering an
+    // 'error: name followed by "::" must be a class or namespace name'
+    // with the Intel compiler and a noexcept function here,
+    // try to use noexcept(true) instead of plain noexcept.
     using type = typename remove_class<decltype(&F::operator())>::type;
 };
 
 // Extracts the function signature from a function, function pointer or lambda.
 template <typename Function, typename F = remove_reference_t<Function>>
 using function_signature_t = conditional_t<
     std::is_function<F>::value,
     F,
-    typename conditional_t<
-        std::is_pointer<F>::value || std::is_member_pointer<F>::value,
-        std::remove_pointer<F>,
-        strip_function_object<F>
-    >::type
->;
+    typename conditional_t<std::is_pointer<F>::value || std::is_member_pointer<F>::value,
+                           std::remove_pointer<F>,
+                           strip_function_object<F>>::type>;
 
 /// Returns true if the type looks like a lambda: that is, isn't a function, pointer or member
 /// pointer.  Note that this can catch all sorts of other things, too; this is intended to be used
 /// in a place where passing a lambda makes sense.
-template <typename T> using is_lambda = satisfies_none_of<remove_reference_t<T>,
-        std::is_function, std::is_pointer, std::is_member_pointer>;
-
-/// Ignore that a variable is unused in compiler warnings
-inline void ignore_unused(const int *) { }
+template <typename T>
+using is_lambda = satisfies_none_of<remove_reference_t<T>,
+                                    std::is_function,
+                                    std::is_pointer,
+                                    std::is_member_pointer>;
 
+// [workaround(intel)] Internal error on fold expression
 /// Apply a function over each element of a parameter pack
-#ifdef __cpp_fold_expressions
-#define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) (((PATTERN), void()), ...)
+#if defined(__cpp_fold_expressions) && !defined(__INTEL_COMPILER)
+// Intel compiler produces an internal error on this fold expression (tested with ICC 19.0.2)
+#    define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) (((PATTERN), void()), ...)
 #else
 using expand_side_effects = bool[];
-#define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) pybind11::detail::expand_side_effects{ ((PATTERN), void(), false)..., false }
+#    define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN)                                                 \
+        (void) pybind11::detail::expand_side_effects { ((PATTERN), void(), false)..., false }
 #endif
 
-NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(detail)
 
 /// C++ bindings of builtin Python exceptions
-class builtin_exception : public std::runtime_error {
+class PYBIND11_EXPORT_EXCEPTION builtin_exception : public std::runtime_error {
 public:
     using std::runtime_error::runtime_error;
     /// Set the error using the Python C API
     virtual void set_error() const = 0;
 };
 
-#define PYBIND11_RUNTIME_EXCEPTION(name, type) \
-    class name : public builtin_exception { public: \
-        using builtin_exception::builtin_exception; \
-        name() : name("") { } \
-        void set_error() const override { PyErr_SetString(type, what()); } \
+#define PYBIND11_RUNTIME_EXCEPTION(name, type)                                                    \
+    class PYBIND11_EXPORT_EXCEPTION name : public builtin_exception {                             \
+    public:                                                                                       \
+        using builtin_exception::builtin_exception;                                               \
+        name() : name("") {}                                                                      \
+        void set_error() const override { PyErr_SetString(type, what()); }                        \
     };
 
 PYBIND11_RUNTIME_EXCEPTION(stop_iteration, PyExc_StopIteration)
 PYBIND11_RUNTIME_EXCEPTION(index_error, PyExc_IndexError)
 PYBIND11_RUNTIME_EXCEPTION(key_error, PyExc_KeyError)
 PYBIND11_RUNTIME_EXCEPTION(value_error, PyExc_ValueError)
 PYBIND11_RUNTIME_EXCEPTION(type_error, PyExc_TypeError)
 PYBIND11_RUNTIME_EXCEPTION(buffer_error, PyExc_BufferError)
 PYBIND11_RUNTIME_EXCEPTION(import_error, PyExc_ImportError)
-PYBIND11_RUNTIME_EXCEPTION(cast_error, PyExc_RuntimeError) /// Thrown when pybind11::cast or handle::call fail due to a type casting error
+PYBIND11_RUNTIME_EXCEPTION(attribute_error, PyExc_AttributeError)
+PYBIND11_RUNTIME_EXCEPTION(cast_error, PyExc_RuntimeError) /// Thrown when pybind11::cast or
+                                                           /// handle::call fail due to a type
+                                                           /// casting error
 PYBIND11_RUNTIME_EXCEPTION(reference_cast_error, PyExc_RuntimeError) /// Used internally
 
-[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const char *reason) { throw std::runtime_error(reason); }
-[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const std::string &reason) { throw std::runtime_error(reason); }
+[[noreturn]] PYBIND11_NOINLINE void pybind11_fail(const char *reason) {
+    assert(!PyErr_Occurred());
+    throw std::runtime_error(reason);
+}
+[[noreturn]] PYBIND11_NOINLINE void pybind11_fail(const std::string &reason) {
+    assert(!PyErr_Occurred());
+    throw std::runtime_error(reason);
+}
 
-template <typename T, typename SFINAE = void> struct format_descriptor { };
+template <typename T, typename SFINAE = void>
+struct format_descriptor {};
 
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(detail)
 // Returns the index of the given type in the type char array below, and in the list in numpy.h
 // The order here is: bool; 8 ints ((signed,unsigned)x(8,16,32,64)bits); float,double,long double;
 // complex float,double,long double.  Note that the long double types only participate when long
 // double is actually longer than double (it isn't under MSVC).
 // NB: not only the string below but also complex.h and numpy.h rely on this order.
-template <typename T, typename SFINAE = void> struct is_fmt_numeric { static constexpr bool value = false; };
-template <typename T> struct is_fmt_numeric<T, enable_if_t<std::is_arithmetic<T>::value>> {
+template <typename T, typename SFINAE = void>
+struct is_fmt_numeric {
+    static constexpr bool value = false;
+};
+template <typename T>
+struct is_fmt_numeric<T, enable_if_t<std::is_arithmetic<T>::value>> {
     static constexpr bool value = true;
-    static constexpr int index = std::is_same<T, bool>::value ? 0 : 1 + (
-        std::is_integral<T>::value ? detail::log2(sizeof(T))*2 + std::is_unsigned<T>::value : 8 + (
-        std::is_same<T, double>::value ? 1 : std::is_same<T, long double>::value ? 2 : 0));
+    static constexpr int index
+        = std::is_same<T, bool>::value
+              ? 0
+              : 1
+                    + (std::is_integral<T>::value
+                           ? detail::log2(sizeof(T)) * 2 + std::is_unsigned<T>::value
+                           : 8
+                                 + (std::is_same<T, double>::value        ? 1
+                                    : std::is_same<T, long double>::value ? 2
+                                                                          : 0));
 };
-NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(detail)
 
-template <typename T> struct format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>> {
+template <typename T>
+struct format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>> {
     static constexpr const char c = "?bBhHiIqQfdg"[detail::is_fmt_numeric<T>::index];
-    static constexpr const char value[2] = { c, '\0' };
+    static constexpr const char value[2] = {c, '\0'};
     static std::string format() { return std::string(1, c); }
 };
 
 #if !defined(PYBIND11_CPP17)
 
-template <typename T> constexpr const char format_descriptor<
-    T, detail::enable_if_t<std::is_arithmetic<T>::value>>::value[2];
+template <typename T>
+constexpr const char
+    format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>>::value[2];
 
 #endif
 
 /// RAII wrapper that temporarily clears any Python error state
 struct error_scope {
     PyObject *type, *value, *trace;
     error_scope() { PyErr_Fetch(&type, &value, &trace); }
+    error_scope(const error_scope &) = delete;
+    error_scope &operator=(const error_scope &) = delete;
     ~error_scope() { PyErr_Restore(type, value, trace); }
 };
 
 /// Dummy destructor wrapper that can be used to expose classes with a private destructor
-struct nodelete { template <typename T> void operator()(T*) { } };
+struct nodelete {
+    template <typename T>
+    void operator()(T *) {}
+};
 
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(detail)
 template <typename... Args>
 struct overload_cast_impl {
-    constexpr overload_cast_impl() {} // MSVC 2015 needs this
-
     template <typename Return>
-    constexpr auto operator()(Return (*pf)(Args...)) const noexcept
-                              -> decltype(pf) { return pf; }
+    constexpr auto operator()(Return (*pf)(Args...)) const noexcept -> decltype(pf) {
+        return pf;
+    }
 
     template <typename Return, typename Class>
     constexpr auto operator()(Return (Class::*pmf)(Args...), std::false_type = {}) const noexcept
-                              -> decltype(pmf) { return pmf; }
+        -> decltype(pmf) {
+        return pmf;
+    }
 
     template <typename Return, typename Class>
     constexpr auto operator()(Return (Class::*pmf)(Args...) const, std::true_type) const noexcept
-                              -> decltype(pmf) { return pmf; }
+        -> decltype(pmf) {
+        return pmf;
+    }
 };
-NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(detail)
 
 // overload_cast requires variable templates: C++14
 #if defined(PYBIND11_CPP14)
-#define PYBIND11_OVERLOAD_CAST 1
+#    define PYBIND11_OVERLOAD_CAST 1
 /// Syntax sugar for resolving overloaded function pointers:
 ///  - regular: static_cast<Return (Class::*)(Arg0, Arg1, Arg2)>(&Class::func)
 ///  - sweet:   overload_cast<Arg0, Arg1, Arg2>(&Class::func)
 template <typename... Args>
-static constexpr detail::overload_cast_impl<Args...> overload_cast = {};
-// MSVC 2015 only accepts this particular initialization syntax for this variable template.
+static constexpr detail::overload_cast_impl<Args...> overload_cast{};
 #endif
 
 /// Const member function selector for overload_cast
 ///  - regular: static_cast<Return (Class::*)(Arg) const>(&Class::func)
 ///  - sweet:   overload_cast<Arg>(&Class::func, const_)
 static constexpr auto const_ = std::true_type{};
 
 #if !defined(PYBIND11_CPP14) // no overload_cast: providing something that static_assert-fails:
-template <typename... Args> struct overload_cast {
+template <typename... Args>
+struct overload_cast {
     static_assert(detail::deferred_t<std::false_type, Args...>::value,
                   "pybind11::overload_cast<...> requires compiling in C++14 mode");
 };
 #endif // overload_cast
 
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(detail)
 
 // Adaptor for converting arbitrary container arguments into a vector; implicitly convertible from
 // any standard container (or C-style array) supporting std::begin/std::end, any singleton
 // arithmetic type (if T is arithmetic), or explicitly constructible from an iterator pair.
 template <typename T>
 class any_container {
     std::vector<T> v;
+
 public:
     any_container() = default;
 
     // Can construct from a pair of iterators
     template <typename It, typename = enable_if_t<is_input_iterator<It>::value>>
-    any_container(It first, It last) : v(first, last) { }
+    any_container(It first, It last) : v(first, last) {}
 
-    // Implicit conversion constructor from any arbitrary container type with values convertible to T
-    template <typename Container, typename = enable_if_t<std::is_convertible<decltype(*std::begin(std::declval<const Container &>())), T>::value>>
-    any_container(const Container &c) : any_container(std::begin(c), std::end(c)) { }
+    // Implicit conversion constructor from any arbitrary container type
+    // with values convertible to T
+    template <typename Container,
+              typename = enable_if_t<
+                  std::is_convertible<decltype(*std::begin(std::declval<const Container &>())),
+                                      T>::value>>
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    any_container(const Container &c) : any_container(std::begin(c), std::end(c)) {}
 
-    // initializer_list's aren't deducible, so don't get matched by the above template; we need this
-    // to explicitly allow implicit conversion from one:
+    // initializer_list's aren't deducible, so don't get matched by the above template;
+    // we need this to explicitly allow implicit conversion from one:
     template <typename TIn, typename = enable_if_t<std::is_convertible<TIn, T>::value>>
-    any_container(const std::initializer_list<TIn> &c) : any_container(c.begin(), c.end()) { }
+    any_container(const std::initializer_list<TIn> &c) : any_container(c.begin(), c.end()) {}
 
     // Avoid copying if given an rvalue vector of the correct type.
-    any_container(std::vector<T> &&v) : v(std::move(v)) { }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    any_container(std::vector<T> &&v) : v(std::move(v)) {}
 
     // Moves the vector out of an rvalue any_container
+    // NOLINTNEXTLINE(google-explicit-constructor)
     operator std::vector<T> &&() && { return std::move(v); }
 
     // Dereferencing obtains a reference to the underlying vector
     std::vector<T> &operator*() { return v; }
     const std::vector<T> &operator*() const { return v; }
 
     // -> lets you call methods on the underlying vector
     std::vector<T> *operator->() { return &v; }
     const std::vector<T> *operator->() const { return &v; }
 };
 
-NAMESPACE_END(detail)
+// Forward-declaration; see detail/class.h
+std::string get_fully_qualified_tp_name(PyTypeObject *);
+
+template <typename T>
+inline static std::shared_ptr<T>
+try_get_shared_from_this(std::enable_shared_from_this<T> *holder_value_ptr) {
+// Pre C++17, this code path exploits undefined behavior, but is known to work on many platforms.
+// Use at your own risk!
+// See also https://en.cppreference.com/w/cpp/memory/enable_shared_from_this, and in particular
+// the `std::shared_ptr<Good> gp1 = not_so_good.getptr();` and `try`-`catch` parts of the example.
+#if defined(__cpp_lib_enable_shared_from_this) && (!defined(_MSC_VER) || _MSC_VER >= 1912)
+    return holder_value_ptr->weak_from_this().lock();
+#else
+    try {
+        return holder_value_ptr->shared_from_this();
+    } catch (const std::bad_weak_ptr &) {
+        return nullptr;
+    }
+#endif
+}
+
+// For silencing "unused" compiler warnings in special situations.
+template <typename... Args>
+#if defined(_MSC_VER) && _MSC_VER < 1920 // MSVC 2017
+constexpr
+#endif
+    inline void
+    silence_unused_warnings(Args &&...) {
+}
+
+// MSVC warning C4100: Unreferenced formal parameter
+#if defined(_MSC_VER) && _MSC_VER <= 1916
+#    define PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(...)                                         \
+        detail::silence_unused_warnings(__VA_ARGS__)
+#else
+#    define PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(...)
+#endif
 
+// GCC -Wunused-but-set-parameter  All GCC versions (as of July 2021).
+#if defined(__GNUG__) && !defined(__clang__) && !defined(__INTEL_COMPILER)
+#    define PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(...)                       \
+        detail::silence_unused_warnings(__VA_ARGS__)
+#else
+#    define PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(...)
+#endif
 
+#if defined(__clang__)                                                                            \
+    && (defined(__apple_build_version__) /* AppleClang 13.0.0.13000029 was the only data point    \
+                                            available. */                                         \
+        || (__clang_major__ >= 7                                                                  \
+            && __clang_major__ <= 12) /* Clang 3, 5, 13, 14, 15 do not generate the warning. */   \
+    )
+#    define PYBIND11_DETECTED_CLANG_WITH_MISLEADING_CALL_STD_MOVE_EXPLICITLY_WARNING
+// Example:
+// tests/test_kwargs_and_defaults.cpp:46:68: error: local variable 'args' will be copied despite
+// being returned by name [-Werror,-Wreturn-std-move]
+//     m.def("args_function", [](py::args args) -> py::tuple { return args; });
+//                                                                    ^~~~
+// test_kwargs_and_defaults.cpp:46:68: note: call 'std::move' explicitly to avoid copying
+//     m.def("args_function", [](py::args args) -> py::tuple { return args; });
+//                                                                    ^~~~
+//                                                                    std::move(args)
+#endif
+
+// Pybind offers detailed error messages by default for all builts that are debug (through the
+// negation of NDEBUG). This can also be manually enabled by users, for any builds, through
+// defining PYBIND11_DETAILED_ERROR_MESSAGES. This information is primarily useful for those
+// who are writing (as opposed to merely using) libraries that use pybind11.
+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES) && !defined(NDEBUG)
+#    define PYBIND11_DETAILED_ERROR_MESSAGES
+#endif
 
-NAMESPACE_END(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/detail/init.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/detail/init.h`

 * *Files 9% similar despite different names*

```diff
@@ -7,109 +7,132 @@
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "class.h"
 
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+
+PYBIND11_WARNING_DISABLE_MSVC(4127)
+
+PYBIND11_NAMESPACE_BEGIN(detail)
 
 template <>
 class type_caster<value_and_holder> {
 public:
     bool load(handle h, bool) {
         value = reinterpret_cast<value_and_holder *>(h.ptr());
         return true;
     }
 
-    template <typename> using cast_op_type = value_and_holder &;
-    operator value_and_holder &() { return *value; }
-    static constexpr auto name = _<value_and_holder>();
+    template <typename>
+    using cast_op_type = value_and_holder &;
+    explicit operator value_and_holder &() { return *value; }
+    static constexpr auto name = const_name<value_and_holder>();
 
 private:
     value_and_holder *value = nullptr;
 };
 
-NAMESPACE_BEGIN(initimpl)
+PYBIND11_NAMESPACE_BEGIN(initimpl)
 
 inline void no_nullptr(void *ptr) {
-    if (!ptr) throw type_error("pybind11::init(): factory function returned nullptr");
+    if (!ptr) {
+        throw type_error("pybind11::init(): factory function returned nullptr");
+    }
 }
 
 // Implementing functions for all forms of py::init<...> and py::init(...)
-template <typename Class> using Cpp = typename Class::type;
-template <typename Class> using Alias = typename Class::type_alias;
-template <typename Class> using Holder = typename Class::holder_type;
+template <typename Class>
+using Cpp = typename Class::type;
+template <typename Class>
+using Alias = typename Class::type_alias;
+template <typename Class>
+using Holder = typename Class::holder_type;
 
-template <typename Class> using is_alias_constructible = std::is_constructible<Alias<Class>, Cpp<Class> &&>;
+template <typename Class>
+using is_alias_constructible = std::is_constructible<Alias<Class>, Cpp<Class> &&>;
 
 // Takes a Cpp pointer and returns true if it actually is a polymorphic Alias instance.
 template <typename Class, enable_if_t<Class::has_alias, int> = 0>
 bool is_alias(Cpp<Class> *ptr) {
     return dynamic_cast<Alias<Class> *>(ptr) != nullptr;
 }
 // Failing fallback version of the above for a no-alias class (always returns false)
 template <typename /*Class*/>
-constexpr bool is_alias(void *) { return false; }
+constexpr bool is_alias(void *) {
+    return false;
+}
 
 // Constructs and returns a new object; if the given arguments don't map to a constructor, we fall
 // back to brace aggregate initiailization so that for aggregate initialization can be used with
 // py::init, e.g.  `py::init<int, int>` to initialize a `struct T { int a; int b; }`.  For
 // non-aggregate types, we need to use an ordinary T(...) constructor (invoking as `T{...}` usually
 // works, but will not do the expected thing when `T` has an `initializer_list<T>` constructor).
-template <typename Class, typename... Args, detail::enable_if_t<std::is_constructible<Class, Args...>::value, int> = 0>
-inline Class *construct_or_initialize(Args &&...args) { return new Class(std::forward<Args>(args)...); }
-template <typename Class, typename... Args, detail::enable_if_t<!std::is_constructible<Class, Args...>::value, int> = 0>
-inline Class *construct_or_initialize(Args &&...args) { return new Class{std::forward<Args>(args)...}; }
+template <typename Class,
+          typename... Args,
+          detail::enable_if_t<std::is_constructible<Class, Args...>::value, int> = 0>
+inline Class *construct_or_initialize(Args &&...args) {
+    return new Class(std::forward<Args>(args)...);
+}
+template <typename Class,
+          typename... Args,
+          detail::enable_if_t<!std::is_constructible<Class, Args...>::value, int> = 0>
+inline Class *construct_or_initialize(Args &&...args) {
+    return new Class{std::forward<Args>(args)...};
+}
 
 // Attempts to constructs an alias using a `Alias(Cpp &&)` constructor.  This allows types with
 // an alias to provide only a single Cpp factory function as long as the Alias can be
 // constructed from an rvalue reference of the base Cpp type.  This means that Alias classes
 // can, when appropriate, simply define a `Alias(Cpp &&)` constructor rather than needing to
 // inherit all the base class constructors.
 template <typename Class>
 void construct_alias_from_cpp(std::true_type /*is_alias_constructible*/,
-                              value_and_holder &v_h, Cpp<Class> &&base) {
+                              value_and_holder &v_h,
+                              Cpp<Class> &&base) {
     v_h.value_ptr() = new Alias<Class>(std::move(base));
 }
 template <typename Class>
 [[noreturn]] void construct_alias_from_cpp(std::false_type /*!is_alias_constructible*/,
-                                           value_and_holder &, Cpp<Class> &&) {
+                                           value_and_holder &,
+                                           Cpp<Class> &&) {
     throw type_error("pybind11::init(): unable to convert returned instance to required "
                      "alias class: no `Alias<Class>(Class &&)` constructor available");
 }
 
 // Error-generating fallback for factories that don't match one of the below construction
 // mechanisms.
 template <typename Class>
 void construct(...) {
     static_assert(!std::is_same<Class, Class>::value /* always false */,
-            "pybind11::init(): init function must return a compatible pointer, "
-            "holder, or value");
+                  "pybind11::init(): init function must return a compatible pointer, "
+                  "holder, or value");
 }
 
 // Pointer return v1: the factory function returns a class pointer for a registered class.
 // If we don't need an alias (because this class doesn't have one, or because the final type is
 // inherited on the Python side) we can simply take over ownership.  Otherwise we need to try to
 // construct an Alias from the returned base instance.
 template <typename Class>
 void construct(value_and_holder &v_h, Cpp<Class> *ptr, bool need_alias) {
+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);
     no_nullptr(ptr);
     if (Class::has_alias && need_alias && !is_alias<Class>(ptr)) {
         // We're going to try to construct an alias by moving the cpp type.  Whether or not
         // that succeeds, we still need to destroy the original cpp pointer (either the
         // moved away leftover, if the alias construction works, or the value itself if we
         // throw an error), but we can't just call `delete ptr`: it might have a special
         // deleter, or might be shared_from_this.  So we construct a holder around it as if
         // it was a normal instance, then steal the holder away into a local variable; thus
         // the holder and destruction happens when we leave the C++ scope, and the holder
         // class gets to handle the destruction however it likes.
         v_h.value_ptr() = ptr;
-        v_h.set_instance_registered(true); // To prevent init_instance from registering it
+        v_h.set_instance_registered(true);          // To prevent init_instance from registering it
         v_h.type->init_instance(v_h.inst, nullptr); // Set up the holder
         Holder<Class> temp_holder(std::move(v_h.holder<Holder<Class>>())); // Steal the holder
         v_h.type->dealloc(v_h); // Destroys the moved-out holder remains, resets value ptr to null
         v_h.set_instance_registered(false);
 
         construct_alias_from_cpp<Class>(is_alias_constructible<Class>{}, v_h, std::move(*ptr));
     } else {
@@ -124,212 +147,288 @@
 void construct(value_and_holder &v_h, Alias<Class> *alias_ptr, bool) {
     no_nullptr(alias_ptr);
     v_h.value_ptr() = static_cast<Cpp<Class> *>(alias_ptr);
 }
 
 // Holder return: copy its pointer, and move or copy the returned holder into the new instance's
 // holder.  This also handles types like std::shared_ptr<T> and std::unique_ptr<T> where T is a
-// derived type (through those holder's implicit conversion from derived class holder constructors).
+// derived type (through those holder's implicit conversion from derived class holder
+// constructors).
 template <typename Class>
 void construct(value_and_holder &v_h, Holder<Class> holder, bool need_alias) {
+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);
     auto *ptr = holder_helper<Holder<Class>>::get(holder);
+    no_nullptr(ptr);
     // If we need an alias, check that the held pointer is actually an alias instance
-    if (Class::has_alias && need_alias && !is_alias<Class>(ptr))
+    if (Class::has_alias && need_alias && !is_alias<Class>(ptr)) {
         throw type_error("pybind11::init(): construction failed: returned holder-wrapped instance "
                          "is not an alias instance");
+    }
 
     v_h.value_ptr() = ptr;
     v_h.type->init_instance(v_h.inst, &holder);
 }
 
 // return-by-value version 1: returning a cpp class by value.  If the class has an alias and an
 // alias is required the alias must have an `Alias(Cpp &&)` constructor so that we can construct
 // the alias from the base when needed (i.e. because of Python-side inheritance).  When we don't
 // need it, we simply move-construct the cpp value into a new instance.
 template <typename Class>
 void construct(value_and_holder &v_h, Cpp<Class> &&result, bool need_alias) {
-    static_assert(std::is_move_constructible<Cpp<Class>>::value,
-        "pybind11::init() return-by-value factory function requires a movable class");
-    if (Class::has_alias && need_alias)
+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);
+    static_assert(is_move_constructible<Cpp<Class>>::value,
+                  "pybind11::init() return-by-value factory function requires a movable class");
+    if (Class::has_alias && need_alias) {
         construct_alias_from_cpp<Class>(is_alias_constructible<Class>{}, v_h, std::move(result));
-    else
+    } else {
         v_h.value_ptr() = new Cpp<Class>(std::move(result));
+    }
 }
 
 // return-by-value version 2: returning a value of the alias type itself.  We move-construct an
 // Alias instance (even if no the python-side inheritance is involved).  The is intended for
 // cases where Alias initialization is always desired.
 template <typename Class>
 void construct(value_and_holder &v_h, Alias<Class> &&result, bool) {
-    static_assert(std::is_move_constructible<Alias<Class>>::value,
+    static_assert(
+        is_move_constructible<Alias<Class>>::value,
         "pybind11::init() return-by-alias-value factory function requires a movable alias class");
     v_h.value_ptr() = new Alias<Class>(std::move(result));
 }
 
 // Implementing class for py::init<...>()
 template <typename... Args>
 struct constructor {
     template <typename Class, typename... Extra, enable_if_t<!Class::has_alias, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
-            v_h.value_ptr() = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);
-        }, is_new_style_constructor(), extra...);
+    static void execute(Class &cl, const Extra &...extra) {
+        cl.def(
+            "__init__",
+            [](value_and_holder &v_h, Args... args) {
+                v_h.value_ptr() = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);
+            },
+            is_new_style_constructor(),
+            extra...);
     }
 
-    template <typename Class, typename... Extra,
-              enable_if_t<Class::has_alias &&
-                          std::is_constructible<Cpp<Class>, Args...>::value, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
-            if (Py_TYPE(v_h.inst) == v_h.type->type)
-                v_h.value_ptr() = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);
-            else
-                v_h.value_ptr() = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
-        }, is_new_style_constructor(), extra...);
+    template <
+        typename Class,
+        typename... Extra,
+        enable_if_t<Class::has_alias && std::is_constructible<Cpp<Class>, Args...>::value, int>
+        = 0>
+    static void execute(Class &cl, const Extra &...extra) {
+        cl.def(
+            "__init__",
+            [](value_and_holder &v_h, Args... args) {
+                if (Py_TYPE(v_h.inst) == v_h.type->type) {
+                    v_h.value_ptr()
+                        = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);
+                } else {
+                    v_h.value_ptr()
+                        = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
+                }
+            },
+            is_new_style_constructor(),
+            extra...);
     }
 
-    template <typename Class, typename... Extra,
-              enable_if_t<Class::has_alias &&
-                          !std::is_constructible<Cpp<Class>, Args...>::value, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
-            v_h.value_ptr() = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
-        }, is_new_style_constructor(), extra...);
+    template <
+        typename Class,
+        typename... Extra,
+        enable_if_t<Class::has_alias && !std::is_constructible<Cpp<Class>, Args...>::value, int>
+        = 0>
+    static void execute(Class &cl, const Extra &...extra) {
+        cl.def(
+            "__init__",
+            [](value_and_holder &v_h, Args... args) {
+                v_h.value_ptr()
+                    = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
+            },
+            is_new_style_constructor(),
+            extra...);
     }
 };
 
 // Implementing class for py::init_alias<...>()
-template <typename... Args> struct alias_constructor {
-    template <typename Class, typename... Extra,
-              enable_if_t<Class::has_alias && std::is_constructible<Alias<Class>, Args...>::value, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
-            v_h.value_ptr() = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
-        }, is_new_style_constructor(), extra...);
+template <typename... Args>
+struct alias_constructor {
+    template <
+        typename Class,
+        typename... Extra,
+        enable_if_t<Class::has_alias && std::is_constructible<Alias<Class>, Args...>::value, int>
+        = 0>
+    static void execute(Class &cl, const Extra &...extra) {
+        cl.def(
+            "__init__",
+            [](value_and_holder &v_h, Args... args) {
+                v_h.value_ptr()
+                    = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
+            },
+            is_new_style_constructor(),
+            extra...);
     }
 };
 
 // Implementation class for py::init(Func) and py::init(Func, AliasFunc)
-template <typename CFunc, typename AFunc = void_type (*)(),
-          typename = function_signature_t<CFunc>, typename = function_signature_t<AFunc>>
+template <typename CFunc,
+          typename AFunc = void_type (*)(),
+          typename = function_signature_t<CFunc>,
+          typename = function_signature_t<AFunc>>
 struct factory;
 
 // Specialization for py::init(Func)
 template <typename Func, typename Return, typename... Args>
 struct factory<Func, void_type (*)(), Return(Args...)> {
     remove_reference_t<Func> class_factory;
 
-    factory(Func &&f) : class_factory(std::forward<Func>(f)) { }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    factory(Func &&f) : class_factory(std::forward<Func>(f)) {}
 
     // The given class either has no alias or has no separate alias factory;
     // this always constructs the class itself.  If the class is registered with an alias
     // type and an alias instance is needed (i.e. because the final type is a Python class
     // inheriting from the C++ type) the returned value needs to either already be an alias
     // instance, or the alias needs to be constructible from a `Class &&` argument.
     template <typename Class, typename... Extra>
     void execute(Class &cl, const Extra &...extra) && {
-        #if defined(PYBIND11_CPP14)
-        cl.def("__init__", [func = std::move(class_factory)]
-        #else
+#if defined(PYBIND11_CPP14)
+        cl.def(
+            "__init__",
+            [func = std::move(class_factory)]
+#else
         auto &func = class_factory;
-        cl.def("__init__", [func]
-        #endif
-        (value_and_holder &v_h, Args... args) {
-            construct<Class>(v_h, func(std::forward<Args>(args)...),
-                             Py_TYPE(v_h.inst) != v_h.type->type);
-        }, is_new_style_constructor(), extra...);
+        cl.def(
+            "__init__",
+            [func]
+#endif
+            (value_and_holder &v_h, Args... args) {
+                construct<Class>(
+                    v_h, func(std::forward<Args>(args)...), Py_TYPE(v_h.inst) != v_h.type->type);
+            },
+            is_new_style_constructor(),
+            extra...);
     }
 };
 
 // Specialization for py::init(Func, AliasFunc)
-template <typename CFunc, typename AFunc,
-          typename CReturn, typename... CArgs, typename AReturn, typename... AArgs>
+template <typename CFunc,
+          typename AFunc,
+          typename CReturn,
+          typename... CArgs,
+          typename AReturn,
+          typename... AArgs>
 struct factory<CFunc, AFunc, CReturn(CArgs...), AReturn(AArgs...)> {
     static_assert(sizeof...(CArgs) == sizeof...(AArgs),
                   "pybind11::init(class_factory, alias_factory): class and alias factories "
                   "must have identical argument signatures");
     static_assert(all_of<std::is_same<CArgs, AArgs>...>::value,
                   "pybind11::init(class_factory, alias_factory): class and alias factories "
                   "must have identical argument signatures");
 
     remove_reference_t<CFunc> class_factory;
     remove_reference_t<AFunc> alias_factory;
 
     factory(CFunc &&c, AFunc &&a)
-        : class_factory(std::forward<CFunc>(c)), alias_factory(std::forward<AFunc>(a)) { }
+        : class_factory(std::forward<CFunc>(c)), alias_factory(std::forward<AFunc>(a)) {}
 
     // The class factory is called when the `self` type passed to `__init__` is the direct
     // class (i.e. not inherited), the alias factory when `self` is a Python-side subtype.
     template <typename Class, typename... Extra>
-    void execute(Class &cl, const Extra&... extra) && {
-        static_assert(Class::has_alias, "The two-argument version of `py::init()` can "
-                                        "only be used if the class has an alias");
-        #if defined(PYBIND11_CPP14)
-        cl.def("__init__", [class_func = std::move(class_factory), alias_func = std::move(alias_factory)]
-        #else
+    void execute(Class &cl, const Extra &...extra) && {
+        static_assert(Class::has_alias,
+                      "The two-argument version of `py::init()` can "
+                      "only be used if the class has an alias");
+#if defined(PYBIND11_CPP14)
+        cl.def(
+            "__init__",
+            [class_func = std::move(class_factory), alias_func = std::move(alias_factory)]
+#else
         auto &class_func = class_factory;
         auto &alias_func = alias_factory;
-        cl.def("__init__", [class_func, alias_func]
-        #endif
-        (value_and_holder &v_h, CArgs... args) {
-            if (Py_TYPE(v_h.inst) == v_h.type->type)
-                // If the instance type equals the registered type we don't have inheritance, so
-                // don't need the alias and can construct using the class function:
-                construct<Class>(v_h, class_func(std::forward<CArgs>(args)...), false);
-            else
-                construct<Class>(v_h, alias_func(std::forward<CArgs>(args)...), true);
-        }, is_new_style_constructor(), extra...);
+        cl.def(
+            "__init__",
+            [class_func, alias_func]
+#endif
+            (value_and_holder &v_h, CArgs... args) {
+                if (Py_TYPE(v_h.inst) == v_h.type->type) {
+                    // If the instance type equals the registered type we don't have inheritance,
+                    // so don't need the alias and can construct using the class function:
+                    construct<Class>(v_h, class_func(std::forward<CArgs>(args)...), false);
+                } else {
+                    construct<Class>(v_h, alias_func(std::forward<CArgs>(args)...), true);
+                }
+            },
+            is_new_style_constructor(),
+            extra...);
     }
 };
 
 /// Set just the C++ state. Same as `__init__`.
 template <typename Class, typename T>
 void setstate(value_and_holder &v_h, T &&result, bool need_alias) {
     construct<Class>(v_h, std::forward<T>(result), need_alias);
 }
 
 /// Set both the C++ and Python states
-template <typename Class, typename T, typename O,
+template <typename Class,
+          typename T,
+          typename O,
           enable_if_t<std::is_convertible<O, handle>::value, int> = 0>
 void setstate(value_and_holder &v_h, std::pair<T, O> &&result, bool need_alias) {
     construct<Class>(v_h, std::move(result.first), need_alias);
-    setattr((PyObject *) v_h.inst, "__dict__", result.second);
+    auto d = handle(result.second);
+    if (PyDict_Check(d.ptr()) && PyDict_Size(d.ptr()) == 0) {
+        // Skipping setattr below, to not force use of py::dynamic_attr() for Class unnecessarily.
+        // See PR #2972 for details.
+        return;
+    }
+    setattr((PyObject *) v_h.inst, "__dict__", d);
 }
 
 /// Implementation for py::pickle(GetState, SetState)
-template <typename Get, typename Set,
-          typename = function_signature_t<Get>, typename = function_signature_t<Set>>
+template <typename Get,
+          typename Set,
+          typename = function_signature_t<Get>,
+          typename = function_signature_t<Set>>
 struct pickle_factory;
 
-template <typename Get, typename Set,
-          typename RetState, typename Self, typename NewInstance, typename ArgState>
+template <typename Get,
+          typename Set,
+          typename RetState,
+          typename Self,
+          typename NewInstance,
+          typename ArgState>
 struct pickle_factory<Get, Set, RetState(Self), NewInstance(ArgState)> {
     static_assert(std::is_same<intrinsic_t<RetState>, intrinsic_t<ArgState>>::value,
                   "The type returned by `__getstate__` must be the same "
                   "as the argument accepted by `__setstate__`");
 
     remove_reference_t<Get> get;
     remove_reference_t<Set> set;
 
-    pickle_factory(Get get, Set set)
-        : get(std::forward<Get>(get)), set(std::forward<Set>(set)) { }
+    pickle_factory(Get get, Set set) : get(std::forward<Get>(get)), set(std::forward<Set>(set)) {}
 
     template <typename Class, typename... Extra>
     void execute(Class &cl, const Extra &...extra) && {
         cl.def("__getstate__", std::move(get));
 
 #if defined(PYBIND11_CPP14)
-        cl.def("__setstate__", [func = std::move(set)]
+        cl.def(
+            "__setstate__",
+            [func = std::move(set)]
 #else
         auto &func = set;
-        cl.def("__setstate__", [func]
+        cl.def(
+            "__setstate__",
+            [func]
 #endif
-        (value_and_holder &v_h, ArgState state) {
-            setstate<Class>(v_h, func(std::forward<ArgState>(state)),
-                            Py_TYPE(v_h.inst) != v_h.type->type);
-        }, is_new_style_constructor(), extra...);
+            (value_and_holder &v_h, ArgState state) {
+                setstate<Class>(
+                    v_h, func(std::forward<ArgState>(state)), Py_TYPE(v_h.inst) != v_h.type->type);
+            },
+            is_new_style_constructor(),
+            extra...);
     }
 };
 
-NAMESPACE_END(initimpl)
-NAMESPACE_END(detail)
-NAMESPACE_END(pybind11)
+PYBIND11_NAMESPACE_END(initimpl)
+PYBIND11_NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/detail/typeid.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/detail/typeid.h`

 * *Files 15% similar despite different names*

```diff
@@ -9,47 +9,57 @@
 
 #pragma once
 
 #include <cstdio>
 #include <cstdlib>
 
 #if defined(__GNUG__)
-#include <cxxabi.h>
+#    include <cxxabi.h>
 #endif
 
 #include "common.h"
 
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_BEGIN(detail)
+
 /// Erase all occurrences of a substring
 inline void erase_all(std::string &string, const std::string &search) {
     for (size_t pos = 0;;) {
         pos = string.find(search, pos);
-        if (pos == std::string::npos) break;
+        if (pos == std::string::npos) {
+            break;
+        }
         string.erase(pos, search.length());
     }
 }
 
-PYBIND11_NOINLINE inline void clean_type_id(std::string &name) {
+PYBIND11_NOINLINE void clean_type_id(std::string &name) {
 #if defined(__GNUG__)
     int status = 0;
-    std::unique_ptr<char, void (*)(void *)> res {
-        abi::__cxa_demangle(name.c_str(), nullptr, nullptr, &status), std::free };
-    if (status == 0)
+    std::unique_ptr<char, void (*)(void *)> res{
+        abi::__cxa_demangle(name.c_str(), nullptr, nullptr, &status), std::free};
+    if (status == 0) {
         name = res.get();
+    }
 #else
     detail::erase_all(name, "class ");
     detail::erase_all(name, "struct ");
     detail::erase_all(name, "enum ");
 #endif
     detail::erase_all(name, "pybind11::");
 }
-NAMESPACE_END(detail)
 
-/// Return a string representation of a C++ type
-template <typename T> static std::string type_id() {
-    std::string name(typeid(T).name());
+inline std::string clean_type_id(const char *typeid_name) {
+    std::string name(typeid_name);
     detail::clean_type_id(name);
     return name;
 }
 
-NAMESPACE_END(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_END(detail)
+
+/// Return a string representation of a C++ type
+template <typename T>
+static std::string type_id() {
+    return detail::clean_type_id(typeid(T).name());
+}
+
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/eigen.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/eigen/matrix.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,230 +1,266 @@
 /*
-    pybind11/eigen.h: Transparent conversion for dense and sparse Eigen matrices
+    pybind11/eigen/matrix.h: Transparent conversion for dense and sparse Eigen matrices
 
     Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
-#include "numpy.h"
+#include "../numpy.h"
 
-#if defined(__INTEL_COMPILER)
-#  pragma warning(disable: 1682) // implicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem)
-#elif defined(__GNUG__) || defined(__clang__)
-#  pragma GCC diagnostic push
-#  pragma GCC diagnostic ignored "-Wconversion"
-#  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-#  ifdef __clang__
-//   Eigen generates a bunch of implicit-copy-constructor-is-deprecated warnings with -Wdeprecated
-//   under Clang, so disable that warning here:
-#    pragma GCC diagnostic ignored "-Wdeprecated"
-#  endif
-#  if __GNUC__ >= 7
-#    pragma GCC diagnostic ignored "-Wint-in-bool-context"
-#  endif
-#endif
-
-#if defined(_MSC_VER)
-#  pragma warning(push)
-#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#  pragma warning(disable: 4996) // warning C4996: std::unary_negate is deprecated in C++17
+/* HINT: To suppress warnings originating from the Eigen headers, use -isystem.
+   See also:
+       https://stackoverflow.com/questions/2579576/i-dir-vs-isystem-dir
+       https://stackoverflow.com/questions/1741816/isystem-for-ms-visual-studio-c-compiler
+*/
+PYBIND11_WARNING_PUSH
+PYBIND11_WARNING_DISABLE_MSVC(5054) // https://github.com/pybind/pybind11/pull/3741
+//       C5054: operator '&': deprecated between enumerations of different types
+#if defined(__MINGW32__)
+PYBIND11_WARNING_DISABLE_GCC("-Wmaybe-uninitialized")
 #endif
 
 #include <Eigen/Core>
 #include <Eigen/SparseCore>
 
+PYBIND11_WARNING_POP
+
 // Eigen prior to 3.2.7 doesn't have proper move constructors--but worse, some classes get implicit
 // move constructors that break things.  We could detect this an explicitly copy, but an extra copy
 // of matrices seems highly undesirable.
-static_assert(EIGEN_VERSION_AT_LEAST(3,2,7), "Eigen support in pybind11 requires Eigen >= 3.2.7");
+static_assert(EIGEN_VERSION_AT_LEAST(3, 2, 7),
+              "Eigen matrix support in pybind11 requires Eigen >= 3.2.7");
 
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+
+PYBIND11_WARNING_DISABLE_MSVC(4127)
 
 // Provide a convenience alias for easier pass-by-ref usage with fully dynamic strides:
 using EigenDStride = Eigen::Stride<Eigen::Dynamic, Eigen::Dynamic>;
-template <typename MatrixType> using EigenDRef = Eigen::Ref<MatrixType, 0, EigenDStride>;
-template <typename MatrixType> using EigenDMap = Eigen::Map<MatrixType, 0, EigenDStride>;
+template <typename MatrixType>
+using EigenDRef = Eigen::Ref<MatrixType, 0, EigenDStride>;
+template <typename MatrixType>
+using EigenDMap = Eigen::Map<MatrixType, 0, EigenDStride>;
 
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(detail)
 
-#if EIGEN_VERSION_AT_LEAST(3,3,0)
+#if EIGEN_VERSION_AT_LEAST(3, 3, 0)
 using EigenIndex = Eigen::Index;
+template <typename Scalar, int Flags, typename StorageIndex>
+using EigenMapSparseMatrix = Eigen::Map<Eigen::SparseMatrix<Scalar, Flags, StorageIndex>>;
 #else
 using EigenIndex = EIGEN_DEFAULT_DENSE_INDEX_TYPE;
+template <typename Scalar, int Flags, typename StorageIndex>
+using EigenMapSparseMatrix = Eigen::MappedSparseMatrix<Scalar, Flags, StorageIndex>;
 #endif
 
 // Matches Eigen::Map, Eigen::Ref, blocks, etc:
-template <typename T> using is_eigen_dense_map = all_of<is_template_base_of<Eigen::DenseBase, T>, std::is_base_of<Eigen::MapBase<T, Eigen::ReadOnlyAccessors>, T>>;
-template <typename T> using is_eigen_mutable_map = std::is_base_of<Eigen::MapBase<T, Eigen::WriteAccessors>, T>;
-template <typename T> using is_eigen_dense_plain = all_of<negation<is_eigen_dense_map<T>>, is_template_base_of<Eigen::PlainObjectBase, T>>;
-template <typename T> using is_eigen_sparse = is_template_base_of<Eigen::SparseMatrixBase, T>;
+template <typename T>
+using is_eigen_dense_map = all_of<is_template_base_of<Eigen::DenseBase, T>,
+                                  std::is_base_of<Eigen::MapBase<T, Eigen::ReadOnlyAccessors>, T>>;
+template <typename T>
+using is_eigen_mutable_map = std::is_base_of<Eigen::MapBase<T, Eigen::WriteAccessors>, T>;
+template <typename T>
+using is_eigen_dense_plain
+    = all_of<negation<is_eigen_dense_map<T>>, is_template_base_of<Eigen::PlainObjectBase, T>>;
+template <typename T>
+using is_eigen_sparse = is_template_base_of<Eigen::SparseMatrixBase, T>;
 // Test for objects inheriting from EigenBase<Derived> that aren't captured by the above.  This
 // basically covers anything that can be assigned to a dense matrix but that don't have a typical
 // matrix data layout that can be copied from their .data().  For example, DiagonalMatrix and
 // SelfAdjointView fall into this category.
-template <typename T> using is_eigen_other = all_of<
-    is_template_base_of<Eigen::EigenBase, T>,
-    negation<any_of<is_eigen_dense_map<T>, is_eigen_dense_plain<T>, is_eigen_sparse<T>>>
->;
+template <typename T>
+using is_eigen_other
+    = all_of<is_template_base_of<Eigen::EigenBase, T>,
+             negation<any_of<is_eigen_dense_map<T>, is_eigen_dense_plain<T>, is_eigen_sparse<T>>>>;
 
 // Captures numpy/eigen conformability status (returned by EigenProps::conformable()):
-template <bool EigenRowMajor> struct EigenConformable {
+template <bool EigenRowMajor>
+struct EigenConformable {
     bool conformable = false;
     EigenIndex rows = 0, cols = 0;
-    EigenDStride stride{0, 0};      // Only valid if negativestrides is false!
-    bool negativestrides = false;   // If true, do not use stride!
+    EigenDStride stride{0, 0};    // Only valid if negativestrides is false!
+    bool negativestrides = false; // If true, do not use stride!
 
+    // NOLINTNEXTLINE(google-explicit-constructor)
     EigenConformable(bool fits = false) : conformable{fits} {}
     // Matrix type:
-    EigenConformable(EigenIndex r, EigenIndex c,
-            EigenIndex rstride, EigenIndex cstride) :
-        conformable{true}, rows{r}, cols{c} {
-        // TODO: when Eigen bug #747 is fixed, remove the tests for non-negativity. http://eigen.tuxfamily.org/bz/show_bug.cgi?id=747
-        if (rstride < 0 || cstride < 0) {
-            negativestrides = true;
-        } else {
-            stride = {EigenRowMajor ? rstride : cstride /* outer stride */,
-                      EigenRowMajor ? cstride : rstride /* inner stride */ };
-        }
-    }
+    EigenConformable(EigenIndex r, EigenIndex c, EigenIndex rstride, EigenIndex cstride)
+        : conformable{true}, rows{r}, cols{c},
+          // TODO: when Eigen bug #747 is fixed, remove the tests for non-negativity.
+          // http://eigen.tuxfamily.org/bz/show_bug.cgi?id=747
+          stride{EigenRowMajor ? (rstride > 0 ? rstride : 0)
+                               : (cstride > 0 ? cstride : 0) /* outer stride */,
+                 EigenRowMajor ? (cstride > 0 ? cstride : 0)
+                               : (rstride > 0 ? rstride : 0) /* inner stride */},
+          negativestrides{rstride < 0 || cstride < 0} {}
     // Vector type:
     EigenConformable(EigenIndex r, EigenIndex c, EigenIndex stride)
-        : EigenConformable(r, c, r == 1 ? c*stride : stride, c == 1 ? r : r*stride) {}
+        : EigenConformable(r, c, r == 1 ? c * stride : stride, c == 1 ? r : r * stride) {}
 
-    template <typename props> bool stride_compatible() const {
+    template <typename props>
+    bool stride_compatible() const {
         // To have compatible strides, we need (on both dimensions) one of fully dynamic strides,
-        // matching strides, or a dimension size of 1 (in which case the stride value is irrelevant)
-        return
-            !negativestrides &&
-            (props::inner_stride == Eigen::Dynamic || props::inner_stride == stride.inner() ||
-                (EigenRowMajor ? cols : rows) == 1) &&
-            (props::outer_stride == Eigen::Dynamic || props::outer_stride == stride.outer() ||
-                (EigenRowMajor ? rows : cols) == 1);
+        // matching strides, or a dimension size of 1 (in which case the stride value is
+        // irrelevant). Alternatively, if any dimension size is 0, the strides are not relevant
+        // (and numpy ≥ 1.23 sets the strides to 0 in that case, so we need to check explicitly).
+        if (negativestrides) {
+            return false;
+        }
+        if (rows == 0 || cols == 0) {
+            return true;
+        }
+        return (props::inner_stride == Eigen::Dynamic || props::inner_stride == stride.inner()
+                || (EigenRowMajor ? cols : rows) == 1)
+               && (props::outer_stride == Eigen::Dynamic || props::outer_stride == stride.outer()
+                   || (EigenRowMajor ? rows : cols) == 1);
     }
+    // NOLINTNEXTLINE(google-explicit-constructor)
     operator bool() const { return conformable; }
 };
 
-template <typename Type> struct eigen_extract_stride { using type = Type; };
+template <typename Type>
+struct eigen_extract_stride {
+    using type = Type;
+};
 template <typename PlainObjectType, int MapOptions, typename StrideType>
-struct eigen_extract_stride<Eigen::Map<PlainObjectType, MapOptions, StrideType>> { using type = StrideType; };
+struct eigen_extract_stride<Eigen::Map<PlainObjectType, MapOptions, StrideType>> {
+    using type = StrideType;
+};
 template <typename PlainObjectType, int Options, typename StrideType>
-struct eigen_extract_stride<Eigen::Ref<PlainObjectType, Options, StrideType>> { using type = StrideType; };
+struct eigen_extract_stride<Eigen::Ref<PlainObjectType, Options, StrideType>> {
+    using type = StrideType;
+};
 
 // Helper struct for extracting information from an Eigen type
-template <typename Type_> struct EigenProps {
+template <typename Type_>
+struct EigenProps {
     using Type = Type_;
     using Scalar = typename Type::Scalar;
     using StrideType = typename eigen_extract_stride<Type>::type;
-    static constexpr EigenIndex
-        rows = Type::RowsAtCompileTime,
-        cols = Type::ColsAtCompileTime,
-        size = Type::SizeAtCompileTime;
-    static constexpr bool
-        row_major = Type::IsRowMajor,
-        vector = Type::IsVectorAtCompileTime, // At least one dimension has fixed size 1
-        fixed_rows = rows != Eigen::Dynamic,
-        fixed_cols = cols != Eigen::Dynamic,
-        fixed = size != Eigen::Dynamic, // Fully-fixed size
-        dynamic = !fixed_rows && !fixed_cols; // Fully-dynamic size
-
-    template <EigenIndex i, EigenIndex ifzero> using if_zero = std::integral_constant<EigenIndex, i == 0 ? ifzero : i>;
-    static constexpr EigenIndex inner_stride = if_zero<StrideType::InnerStrideAtCompileTime, 1>::value,
-                                outer_stride = if_zero<StrideType::OuterStrideAtCompileTime,
-                                                       vector ? size : row_major ? cols : rows>::value;
-    static constexpr bool dynamic_stride = inner_stride == Eigen::Dynamic && outer_stride == Eigen::Dynamic;
-    static constexpr bool requires_row_major = !dynamic_stride && !vector && (row_major ? inner_stride : outer_stride) == 1;
-    static constexpr bool requires_col_major = !dynamic_stride && !vector && (row_major ? outer_stride : inner_stride) == 1;
+    static constexpr EigenIndex rows = Type::RowsAtCompileTime, cols = Type::ColsAtCompileTime,
+                                size = Type::SizeAtCompileTime;
+    static constexpr bool row_major = Type::IsRowMajor,
+                          vector
+                          = Type::IsVectorAtCompileTime, // At least one dimension has fixed size 1
+        fixed_rows = rows != Eigen::Dynamic, fixed_cols = cols != Eigen::Dynamic,
+                          fixed = size != Eigen::Dynamic, // Fully-fixed size
+        dynamic = !fixed_rows && !fixed_cols;             // Fully-dynamic size
+
+    template <EigenIndex i, EigenIndex ifzero>
+    using if_zero = std::integral_constant<EigenIndex, i == 0 ? ifzero : i>;
+    static constexpr EigenIndex inner_stride
+        = if_zero<StrideType::InnerStrideAtCompileTime, 1>::value,
+        outer_stride = if_zero < StrideType::OuterStrideAtCompileTime,
+        vector      ? size
+        : row_major ? cols
+                    : rows > ::value;
+    static constexpr bool dynamic_stride
+        = inner_stride == Eigen::Dynamic && outer_stride == Eigen::Dynamic;
+    static constexpr bool requires_row_major
+        = !dynamic_stride && !vector && (row_major ? inner_stride : outer_stride) == 1;
+    static constexpr bool requires_col_major
+        = !dynamic_stride && !vector && (row_major ? outer_stride : inner_stride) == 1;
 
     // Takes an input array and determines whether we can make it fit into the Eigen type.  If
     // the array is a vector, we attempt to fit it into either an Eigen 1xN or Nx1 vector
     // (preferring the latter if it will fit in either, i.e. for a fully dynamic matrix type).
     static EigenConformable<row_major> conformable(const array &a) {
         const auto dims = a.ndim();
-        if (dims < 1 || dims > 2)
+        if (dims < 1 || dims > 2) {
             return false;
+        }
 
         if (dims == 2) { // Matrix type: require exact match (or dynamic)
 
-            EigenIndex
-                np_rows = a.shape(0),
-                np_cols = a.shape(1),
-                np_rstride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar)),
-                np_cstride = a.strides(1) / static_cast<ssize_t>(sizeof(Scalar));
-            if ((fixed_rows && np_rows != rows) || (fixed_cols && np_cols != cols))
+            EigenIndex np_rows = a.shape(0), np_cols = a.shape(1),
+                       np_rstride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar)),
+                       np_cstride = a.strides(1) / static_cast<ssize_t>(sizeof(Scalar));
+            if ((fixed_rows && np_rows != rows) || (fixed_cols && np_cols != cols)) {
                 return false;
+            }
 
             return {np_rows, np_cols, np_rstride, np_cstride};
         }
 
-        // Otherwise we're storing an n-vector.  Only one of the strides will be used, but whichever
-        // is used, we want the (single) numpy stride value.
+        // Otherwise we're storing an n-vector.  Only one of the strides will be used, but
+        // whichever is used, we want the (single) numpy stride value.
         const EigenIndex n = a.shape(0),
-              stride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar));
+                         stride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar));
 
         if (vector) { // Eigen type is a compile-time vector
-            if (fixed && size != n)
+            if (fixed && size != n) {
                 return false; // Vector size mismatch
+            }
             return {rows == 1 ? 1 : n, cols == 1 ? 1 : n, stride};
         }
-        else if (fixed) {
+        if (fixed) {
             // The type has a fixed size, but is not a vector: abort
             return false;
         }
-        else if (fixed_cols) {
+        if (fixed_cols) {
             // Since this isn't a vector, cols must be != 1.  We allow this only if it exactly
             // equals the number of elements (rows is Dynamic, and so 1 row is allowed).
-            if (cols != n) return false;
+            if (cols != n) {
+                return false;
+            }
             return {1, n, stride};
+        } // Otherwise it's either fully dynamic, or column dynamic; both become a column vector
+        if (fixed_rows && rows != n) {
+            return false;
         }
-        else {
-            // Otherwise it's either fully dynamic, or column dynamic; both become a column vector
-            if (fixed_rows && rows != n) return false;
-            return {n, 1, stride};
-        }
+        return {n, 1, stride};
     }
 
-    static constexpr bool show_writeable = is_eigen_dense_map<Type>::value && is_eigen_mutable_map<Type>::value;
+    static constexpr bool show_writeable
+        = is_eigen_dense_map<Type>::value && is_eigen_mutable_map<Type>::value;
     static constexpr bool show_order = is_eigen_dense_map<Type>::value;
     static constexpr bool show_c_contiguous = show_order && requires_row_major;
-    static constexpr bool show_f_contiguous = !show_c_contiguous && show_order && requires_col_major;
+    static constexpr bool show_f_contiguous
+        = !show_c_contiguous && show_order && requires_col_major;
 
-    static constexpr auto descriptor =
-        _("numpy.ndarray[") + npy_format_descriptor<Scalar>::name +
-        _("[")  + _<fixed_rows>(_<(size_t) rows>(), _("m")) +
-        _(", ") + _<fixed_cols>(_<(size_t) cols>(), _("n")) +
-        _("]") +
-        // For a reference type (e.g. Ref<MatrixXd>) we have other constraints that might need to be
-        // satisfied: writeable=True (for a mutable reference), and, depending on the map's stride
-        // options, possibly f_contiguous or c_contiguous.  We include them in the descriptor output
-        // to provide some hint as to why a TypeError is occurring (otherwise it can be confusing to
-        // see that a function accepts a 'numpy.ndarray[float64[3,2]]' and an error message that you
-        // *gave* a numpy.ndarray of the right type and dimensions.
-        _<show_writeable>(", flags.writeable", "") +
-        _<show_c_contiguous>(", flags.c_contiguous", "") +
-        _<show_f_contiguous>(", flags.f_contiguous", "") +
-        _("]");
+    static constexpr auto descriptor
+        = const_name("numpy.ndarray[") + npy_format_descriptor<Scalar>::name + const_name("[")
+          + const_name<fixed_rows>(const_name<(size_t) rows>(), const_name("m")) + const_name(", ")
+          + const_name<fixed_cols>(const_name<(size_t) cols>(), const_name("n")) + const_name("]")
+          +
+          // For a reference type (e.g. Ref<MatrixXd>) we have other constraints that might need to
+          // be satisfied: writeable=True (for a mutable reference), and, depending on the map's
+          // stride options, possibly f_contiguous or c_contiguous.  We include them in the
+          // descriptor output to provide some hint as to why a TypeError is occurring (otherwise
+          // it can be confusing to see that a function accepts a 'numpy.ndarray[float64[3,2]]' and
+          // an error message that you *gave* a numpy.ndarray of the right type and dimensions.
+          const_name<show_writeable>(", flags.writeable", "")
+          + const_name<show_c_contiguous>(", flags.c_contiguous", "")
+          + const_name<show_f_contiguous>(", flags.f_contiguous", "") + const_name("]");
 };
 
 // Casts an Eigen type to numpy array.  If given a base, the numpy array references the src data,
 // otherwise it'll make a copy.  writeable lets you turn off the writeable flag for the array.
-template <typename props> handle eigen_array_cast(typename props::Type const &src, handle base = handle(), bool writeable = true) {
+template <typename props>
+handle
+eigen_array_cast(typename props::Type const &src, handle base = handle(), bool writeable = true) {
     constexpr ssize_t elem_size = sizeof(typename props::Scalar);
     array a;
-    if (props::vector)
-        a = array({ src.size() }, { elem_size * src.innerStride() }, src.data(), base);
-    else
-        a = array({ src.rows(), src.cols() }, { elem_size * src.rowStride(), elem_size * src.colStride() },
-                  src.data(), base);
+    if (props::vector) {
+        a = array({src.size()}, {elem_size * src.innerStride()}, src.data(), base);
+    } else {
+        a = array({src.rows(), src.cols()},
+                  {elem_size * src.rowStride(), elem_size * src.colStride()},
+                  src.data(),
+                  base);
+    }
 
-    if (!writeable)
+    if (!writeable) {
         array_proxy(a.ptr())->flags &= ~detail::npy_api::NPY_ARRAY_WRITEABLE_;
+    }
 
     return a.release();
 }
 
 // Takes an lvalue ref to some Eigen type and a (python) base object, creating a numpy array that
 // reference the Eigen object's data with `base` as the python-registered base class (if omitted,
 // the base will be set to None, and lifetime management is up to the caller).  The numpy array is
@@ -232,68 +268,74 @@
 template <typename props, typename Type>
 handle eigen_ref_array(Type &src, handle parent = none()) {
     // none here is to get past array's should-we-copy detection, which currently always
     // copies when there is no base.  Setting the base to None should be harmless.
     return eigen_array_cast<props>(src, parent, !std::is_const<Type>::value);
 }
 
-// Takes a pointer to some dense, plain Eigen type, builds a capsule around it, then returns a numpy
-// array that references the encapsulated data with a python-side reference to the capsule to tie
-// its destruction to that of any dependent python objects.  Const-ness is determined by whether or
-// not the Type of the pointer given is const.
+// Takes a pointer to some dense, plain Eigen type, builds a capsule around it, then returns a
+// numpy array that references the encapsulated data with a python-side reference to the capsule to
+// tie its destruction to that of any dependent python objects.  Const-ness is determined by
+// whether or not the Type of the pointer given is const.
 template <typename props, typename Type, typename = enable_if_t<is_eigen_dense_plain<Type>::value>>
 handle eigen_encapsulate(Type *src) {
     capsule base(src, [](void *o) { delete static_cast<Type *>(o); });
     return eigen_ref_array<props>(*src, base);
 }
 
 // Type caster for regular, dense matrix types (e.g. MatrixXd), but not maps/refs/etc. of dense
 // types.
-template<typename Type>
+template <typename Type>
 struct type_caster<Type, enable_if_t<is_eigen_dense_plain<Type>::value>> {
     using Scalar = typename Type::Scalar;
     using props = EigenProps<Type>;
 
     bool load(handle src, bool convert) {
         // If we're in no-convert mode, only load if given an array of the correct type
-        if (!convert && !isinstance<array_t<Scalar>>(src))
+        if (!convert && !isinstance<array_t<Scalar>>(src)) {
             return false;
+        }
 
         // Coerce into an array, but don't do type conversion yet; the copy below handles it.
         auto buf = array::ensure(src);
 
-        if (!buf)
+        if (!buf) {
             return false;
+        }
 
         auto dims = buf.ndim();
-        if (dims < 1 || dims > 2)
+        if (dims < 1 || dims > 2) {
             return false;
+        }
 
         auto fits = props::conformable(buf);
-        if (!fits)
+        if (!fits) {
             return false;
+        }
 
         // Allocate the new type, then build a numpy reference into it
         value = Type(fits.rows, fits.cols);
         auto ref = reinterpret_steal<array>(eigen_ref_array<props>(value));
-        if (dims == 1) ref = ref.squeeze();
-        else if (ref.ndim() == 1) buf = buf.squeeze();
+        if (dims == 1) {
+            ref = ref.squeeze();
+        } else if (ref.ndim() == 1) {
+            buf = buf.squeeze();
+        }
 
         int result = detail::npy_api::get().PyArray_CopyInto_(ref.ptr(), buf.ptr());
 
         if (result < 0) { // Copy failed!
             PyErr_Clear();
             return false;
         }
 
         return true;
     }
 
 private:
-
     // Cast implementation
     template <typename CType>
     static handle cast_impl(CType *src, return_value_policy policy, handle parent) {
         switch (policy) {
             case return_value_policy::take_ownership:
             case return_value_policy::automatic:
                 return eigen_encapsulate<props>(src);
@@ -308,68 +350,75 @@
                 return eigen_ref_array<props>(*src, parent);
             default:
                 throw cast_error("unhandled return_value_policy: should not happen!");
         };
     }
 
 public:
-
     // Normal returned non-reference, non-const value:
     static handle cast(Type &&src, return_value_policy /* policy */, handle parent) {
         return cast_impl(&src, return_value_policy::move, parent);
     }
     // If you return a non-reference const, we mark the numpy array readonly:
     static handle cast(const Type &&src, return_value_policy /* policy */, handle parent) {
         return cast_impl(&src, return_value_policy::move, parent);
     }
     // lvalue reference return; default (automatic) becomes copy
     static handle cast(Type &src, return_value_policy policy, handle parent) {
-        if (policy == return_value_policy::automatic || policy == return_value_policy::automatic_reference)
+        if (policy == return_value_policy::automatic
+            || policy == return_value_policy::automatic_reference) {
             policy = return_value_policy::copy;
+        }
         return cast_impl(&src, policy, parent);
     }
     // const lvalue reference return; default (automatic) becomes copy
     static handle cast(const Type &src, return_value_policy policy, handle parent) {
-        if (policy == return_value_policy::automatic || policy == return_value_policy::automatic_reference)
+        if (policy == return_value_policy::automatic
+            || policy == return_value_policy::automatic_reference) {
             policy = return_value_policy::copy;
+        }
         return cast(&src, policy, parent);
     }
     // non-const pointer return
     static handle cast(Type *src, return_value_policy policy, handle parent) {
         return cast_impl(src, policy, parent);
     }
     // const pointer return
     static handle cast(const Type *src, return_value_policy policy, handle parent) {
         return cast_impl(src, policy, parent);
     }
 
     static constexpr auto name = props::descriptor;
 
-    operator Type*() { return &value; }
-    operator Type&() { return value; }
-    operator Type&&() && { return std::move(value); }
-    template <typename T> using cast_op_type = movable_cast_op_type<T>;
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    operator Type *() { return &value; }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    operator Type &() { return value; }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    operator Type &&() && { return std::move(value); }
+    template <typename T>
+    using cast_op_type = movable_cast_op_type<T>;
 
 private:
     Type value;
 };
 
 // Base class for casting reference/map/block/etc. objects back to python.
-template <typename MapType> struct eigen_map_caster {
+template <typename MapType>
+struct eigen_map_caster {
 private:
     using props = EigenProps<MapType>;
 
 public:
-
     // Directly referencing a ref/map's data is a bit dangerous (whatever the map/ref points to has
-    // to stay around), but we'll allow it under the assumption that you know what you're doing (and
-    // have an appropriate keep_alive in place).  We return a numpy array pointing directly at the
-    // ref's data (The numpy array ends up read-only if the ref was to a const matrix type.) Note
-    // that this means you need to ensure you don't destroy the object in some other way (e.g. with
-    // an appropriate keep_alive, or with a reference to a statically allocated matrix).
+    // to stay around), but we'll allow it under the assumption that you know what you're doing
+    // (and have an appropriate keep_alive in place).  We return a numpy array pointing directly at
+    // the ref's data (The numpy array ends up read-only if the ref was to a const matrix type.)
+    // Note that this means you need to ensure you don't destroy the object in some other way (e.g.
+    // with an appropriate keep_alive, or with a reference to a statically allocated matrix).
     static handle cast(const MapType &src, return_value_policy policy, handle parent) {
         switch (policy) {
             case return_value_policy::copy:
                 return eigen_array_cast<props>(src);
             case return_value_policy::reference_internal:
                 return eigen_array_cast<props>(src, parent, is_eigen_mutable_map<MapType>::value);
             case return_value_policy::reference:
@@ -385,223 +434,268 @@
     static constexpr auto name = props::descriptor;
 
     // Explicitly delete these: support python -> C++ conversion on these (i.e. these can be return
     // types but not bound arguments).  We still provide them (with an explicitly delete) so that
     // you end up here if you try anyway.
     bool load(handle, bool) = delete;
     operator MapType() = delete;
-    template <typename> using cast_op_type = MapType;
+    template <typename>
+    using cast_op_type = MapType;
 };
 
 // We can return any map-like object (but can only load Refs, specialized next):
-template <typename Type> struct type_caster<Type, enable_if_t<is_eigen_dense_map<Type>::value>>
-    : eigen_map_caster<Type> {};
+template <typename Type>
+struct type_caster<Type, enable_if_t<is_eigen_dense_map<Type>::value>> : eigen_map_caster<Type> {};
 
 // Loader for Ref<...> arguments.  See the documentation for info on how to make this work without
 // copying (it requires some extra effort in many cases).
 template <typename PlainObjectType, typename StrideType>
 struct type_caster<
     Eigen::Ref<PlainObjectType, 0, StrideType>,
-    enable_if_t<is_eigen_dense_map<Eigen::Ref<PlainObjectType, 0, StrideType>>::value>
-> : public eigen_map_caster<Eigen::Ref<PlainObjectType, 0, StrideType>> {
+    enable_if_t<is_eigen_dense_map<Eigen::Ref<PlainObjectType, 0, StrideType>>::value>>
+    : public eigen_map_caster<Eigen::Ref<PlainObjectType, 0, StrideType>> {
 private:
     using Type = Eigen::Ref<PlainObjectType, 0, StrideType>;
     using props = EigenProps<Type>;
     using Scalar = typename props::Scalar;
     using MapType = Eigen::Map<PlainObjectType, 0, StrideType>;
-    using Array = array_t<Scalar, array::forcecast |
-                ((props::row_major ? props::inner_stride : props::outer_stride) == 1 ? array::c_style :
-                 (props::row_major ? props::outer_stride : props::inner_stride) == 1 ? array::f_style : 0)>;
+    using Array
+        = array_t<Scalar,
+                  array::forcecast
+                      | ((props::row_major ? props::inner_stride : props::outer_stride) == 1
+                             ? array::c_style
+                         : (props::row_major ? props::outer_stride : props::inner_stride) == 1
+                             ? array::f_style
+                             : 0)>;
     static constexpr bool need_writeable = is_eigen_mutable_map<Type>::value;
     // Delay construction (these have no default constructor)
     std::unique_ptr<MapType> map;
     std::unique_ptr<Type> ref;
     // Our array.  When possible, this is just a numpy array pointing to the source data, but
-    // sometimes we can't avoid copying (e.g. input is not a numpy array at all, has an incompatible
-    // layout, or is an array of a type that needs to be converted).  Using a numpy temporary
-    // (rather than an Eigen temporary) saves an extra copy when we need both type conversion and
-    // storage order conversion.  (Note that we refuse to use this temporary copy when loading an
-    // argument for a Ref<M> with M non-const, i.e. a read-write reference).
+    // sometimes we can't avoid copying (e.g. input is not a numpy array at all, has an
+    // incompatible layout, or is an array of a type that needs to be converted).  Using a numpy
+    // temporary (rather than an Eigen temporary) saves an extra copy when we need both type
+    // conversion and storage order conversion.  (Note that we refuse to use this temporary copy
+    // when loading an argument for a Ref<M> with M non-const, i.e. a read-write reference).
     Array copy_or_ref;
+
 public:
     bool load(handle src, bool convert) {
-        // First check whether what we have is already an array of the right type.  If not, we can't
-        // avoid a copy (because the copy is also going to do type conversion).
+        // First check whether what we have is already an array of the right type.  If not, we
+        // can't avoid a copy (because the copy is also going to do type conversion).
         bool need_copy = !isinstance<Array>(src);
 
         EigenConformable<props::row_major> fits;
         if (!need_copy) {
             // We don't need a converting copy, but we also need to check whether the strides are
             // compatible with the Ref's stride requirements
-            Array aref = reinterpret_borrow<Array>(src);
+            auto aref = reinterpret_borrow<Array>(src);
 
             if (aref && (!need_writeable || aref.writeable())) {
                 fits = props::conformable(aref);
-                if (!fits) return false; // Incompatible dimensions
-                if (!fits.template stride_compatible<props>())
+                if (!fits) {
+                    return false; // Incompatible dimensions
+                }
+                if (!fits.template stride_compatible<props>()) {
                     need_copy = true;
-                else
+                } else {
                     copy_or_ref = std::move(aref);
-            }
-            else {
+                }
+            } else {
                 need_copy = true;
             }
         }
 
         if (need_copy) {
             // We need to copy: If we need a mutable reference, or we're not supposed to convert
             // (either because we're in the no-convert overload pass, or because we're explicitly
             // instructed not to copy (via `py::arg().noconvert()`) we have to fail loading.
-            if (!convert || need_writeable) return false;
+            if (!convert || need_writeable) {
+                return false;
+            }
 
             Array copy = Array::ensure(src);
-            if (!copy) return false;
+            if (!copy) {
+                return false;
+            }
             fits = props::conformable(copy);
-            if (!fits || !fits.template stride_compatible<props>())
+            if (!fits || !fits.template stride_compatible<props>()) {
                 return false;
+            }
             copy_or_ref = std::move(copy);
             loader_life_support::add_patient(copy_or_ref);
         }
 
         ref.reset();
-        map.reset(new MapType(data(copy_or_ref), fits.rows, fits.cols, make_stride(fits.stride.outer(), fits.stride.inner())));
+        map.reset(new MapType(data(copy_or_ref),
+                              fits.rows,
+                              fits.cols,
+                              make_stride(fits.stride.outer(), fits.stride.inner())));
         ref.reset(new Type(*map));
 
         return true;
     }
 
-    operator Type*() { return ref.get(); }
-    operator Type&() { return *ref; }
-    template <typename _T> using cast_op_type = pybind11::detail::cast_op_type<_T>;
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    operator Type *() { return ref.get(); }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    operator Type &() { return *ref; }
+    template <typename _T>
+    using cast_op_type = pybind11::detail::cast_op_type<_T>;
 
 private:
     template <typename T = Type, enable_if_t<is_eigen_mutable_map<T>::value, int> = 0>
-    Scalar *data(Array &a) { return a.mutable_data(); }
+    Scalar *data(Array &a) {
+        return a.mutable_data();
+    }
 
     template <typename T = Type, enable_if_t<!is_eigen_mutable_map<T>::value, int> = 0>
-    const Scalar *data(Array &a) { return a.data(); }
+    const Scalar *data(Array &a) {
+        return a.data();
+    }
 
     // Attempt to figure out a constructor of `Stride` that will work.
     // If both strides are fixed, use a default constructor:
-    template <typename S> using stride_ctor_default = bool_constant<
-        S::InnerStrideAtCompileTime != Eigen::Dynamic && S::OuterStrideAtCompileTime != Eigen::Dynamic &&
-        std::is_default_constructible<S>::value>;
+    template <typename S>
+    using stride_ctor_default = bool_constant<S::InnerStrideAtCompileTime != Eigen::Dynamic
+                                              && S::OuterStrideAtCompileTime != Eigen::Dynamic
+                                              && std::is_default_constructible<S>::value>;
     // Otherwise, if there is a two-index constructor, assume it is (outer,inner) like
     // Eigen::Stride, and use it:
-    template <typename S> using stride_ctor_dual = bool_constant<
-        !stride_ctor_default<S>::value && std::is_constructible<S, EigenIndex, EigenIndex>::value>;
+    template <typename S>
+    using stride_ctor_dual
+        = bool_constant<!stride_ctor_default<S>::value
+                        && std::is_constructible<S, EigenIndex, EigenIndex>::value>;
     // Otherwise, if there is a one-index constructor, and just one of the strides is dynamic, use
     // it (passing whichever stride is dynamic).
-    template <typename S> using stride_ctor_outer = bool_constant<
-        !any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value &&
-        S::OuterStrideAtCompileTime == Eigen::Dynamic && S::InnerStrideAtCompileTime != Eigen::Dynamic &&
-        std::is_constructible<S, EigenIndex>::value>;
-    template <typename S> using stride_ctor_inner = bool_constant<
-        !any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value &&
-        S::InnerStrideAtCompileTime == Eigen::Dynamic && S::OuterStrideAtCompileTime != Eigen::Dynamic &&
-        std::is_constructible<S, EigenIndex>::value>;
+    template <typename S>
+    using stride_ctor_outer
+        = bool_constant<!any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value
+                        && S::OuterStrideAtCompileTime == Eigen::Dynamic
+                        && S::InnerStrideAtCompileTime != Eigen::Dynamic
+                        && std::is_constructible<S, EigenIndex>::value>;
+    template <typename S>
+    using stride_ctor_inner
+        = bool_constant<!any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value
+                        && S::InnerStrideAtCompileTime == Eigen::Dynamic
+                        && S::OuterStrideAtCompileTime != Eigen::Dynamic
+                        && std::is_constructible<S, EigenIndex>::value>;
 
     template <typename S = StrideType, enable_if_t<stride_ctor_default<S>::value, int> = 0>
-    static S make_stride(EigenIndex, EigenIndex) { return S(); }
+    static S make_stride(EigenIndex, EigenIndex) {
+        return S();
+    }
     template <typename S = StrideType, enable_if_t<stride_ctor_dual<S>::value, int> = 0>
-    static S make_stride(EigenIndex outer, EigenIndex inner) { return S(outer, inner); }
+    static S make_stride(EigenIndex outer, EigenIndex inner) {
+        return S(outer, inner);
+    }
     template <typename S = StrideType, enable_if_t<stride_ctor_outer<S>::value, int> = 0>
-    static S make_stride(EigenIndex outer, EigenIndex) { return S(outer); }
+    static S make_stride(EigenIndex outer, EigenIndex) {
+        return S(outer);
+    }
     template <typename S = StrideType, enable_if_t<stride_ctor_inner<S>::value, int> = 0>
-    static S make_stride(EigenIndex, EigenIndex inner) { return S(inner); }
-
+    static S make_stride(EigenIndex, EigenIndex inner) {
+        return S(inner);
+    }
 };
 
 // type_caster for special matrix types (e.g. DiagonalMatrix), which are EigenBase, but not
 // EigenDense (i.e. they don't have a data(), at least not with the usual matrix layout).
 // load() is not supported, but we can cast them into the python domain by first copying to a
 // regular Eigen::Matrix, then casting that.
 template <typename Type>
 struct type_caster<Type, enable_if_t<is_eigen_other<Type>::value>> {
 protected:
-    using Matrix = Eigen::Matrix<typename Type::Scalar, Type::RowsAtCompileTime, Type::ColsAtCompileTime>;
+    using Matrix
+        = Eigen::Matrix<typename Type::Scalar, Type::RowsAtCompileTime, Type::ColsAtCompileTime>;
     using props = EigenProps<Matrix>;
+
 public:
     static handle cast(const Type &src, return_value_policy /* policy */, handle /* parent */) {
         handle h = eigen_encapsulate<props>(new Matrix(src));
         return h;
     }
-    static handle cast(const Type *src, return_value_policy policy, handle parent) { return cast(*src, policy, parent); }
+    static handle cast(const Type *src, return_value_policy policy, handle parent) {
+        return cast(*src, policy, parent);
+    }
 
     static constexpr auto name = props::descriptor;
 
     // Explicitly delete these: support python -> C++ conversion on these (i.e. these can be return
     // types but not bound arguments).  We still provide them (with an explicitly delete) so that
     // you end up here if you try anyway.
     bool load(handle, bool) = delete;
     operator Type() = delete;
-    template <typename> using cast_op_type = Type;
+    template <typename>
+    using cast_op_type = Type;
 };
 
-template<typename Type>
+template <typename Type>
 struct type_caster<Type, enable_if_t<is_eigen_sparse<Type>::value>> {
-    typedef typename Type::Scalar Scalar;
-    typedef remove_reference_t<decltype(*std::declval<Type>().outerIndexPtr())> StorageIndex;
-    typedef typename Type::Index Index;
+    using Scalar = typename Type::Scalar;
+    using StorageIndex = remove_reference_t<decltype(*std::declval<Type>().outerIndexPtr())>;
+    using Index = typename Type::Index;
     static constexpr bool rowMajor = Type::IsRowMajor;
 
     bool load(handle src, bool) {
-        if (!src)
+        if (!src) {
             return false;
+        }
 
         auto obj = reinterpret_borrow<object>(src);
-        object sparse_module = module::import("scipy.sparse");
-        object matrix_type = sparse_module.attr(
-            rowMajor ? "csr_matrix" : "csc_matrix");
+        object sparse_module = module_::import("scipy.sparse");
+        object matrix_type = sparse_module.attr(rowMajor ? "csr_matrix" : "csc_matrix");
 
-        if (!obj.get_type().is(matrix_type)) {
+        if (!type::handle_of(obj).is(matrix_type)) {
             try {
                 obj = matrix_type(obj);
             } catch (const error_already_set &) {
                 return false;
             }
         }
 
         auto values = array_t<Scalar>((object) obj.attr("data"));
         auto innerIndices = array_t<StorageIndex>((object) obj.attr("indices"));
         auto outerIndices = array_t<StorageIndex>((object) obj.attr("indptr"));
         auto shape = pybind11::tuple((pybind11::object) obj.attr("shape"));
         auto nnz = obj.attr("nnz").cast<Index>();
 
-        if (!values || !innerIndices || !outerIndices)
+        if (!values || !innerIndices || !outerIndices) {
             return false;
+        }
 
-        value = Eigen::MappedSparseMatrix<Scalar, Type::Flags, StorageIndex>(
-            shape[0].cast<Index>(), shape[1].cast<Index>(), nnz,
-            outerIndices.mutable_data(), innerIndices.mutable_data(), values.mutable_data());
+        value = EigenMapSparseMatrix<Scalar,
+                                     Type::Flags &(Eigen::RowMajor | Eigen::ColMajor),
+                                     StorageIndex>(shape[0].cast<Index>(),
+                                                   shape[1].cast<Index>(),
+                                                   std::move(nnz),
+                                                   outerIndices.mutable_data(),
+                                                   innerIndices.mutable_data(),
+                                                   values.mutable_data());
 
         return true;
     }
 
     static handle cast(const Type &src, return_value_policy /* policy */, handle /* parent */) {
-        const_cast<Type&>(src).makeCompressed();
+        const_cast<Type &>(src).makeCompressed();
 
-        object matrix_type = module::import("scipy.sparse").attr(
-            rowMajor ? "csr_matrix" : "csc_matrix");
+        object matrix_type
+            = module_::import("scipy.sparse").attr(rowMajor ? "csr_matrix" : "csc_matrix");
 
         array data(src.nonZeros(), src.valuePtr());
         array outerIndices((rowMajor ? src.rows() : src.cols()) + 1, src.outerIndexPtr());
         array innerIndices(src.nonZeros(), src.innerIndexPtr());
 
-        return matrix_type(
-            std::make_tuple(data, innerIndices, outerIndices),
-            std::make_pair(src.rows(), src.cols())
-        ).release();
+        return matrix_type(pybind11::make_tuple(
+                               std::move(data), std::move(innerIndices), std::move(outerIndices)),
+                           pybind11::make_tuple(src.rows(), src.cols()))
+            .release();
     }
 
-    PYBIND11_TYPE_CASTER(Type, _<(Type::IsRowMajor) != 0>("scipy.sparse.csr_matrix[", "scipy.sparse.csc_matrix[")
-            + npy_format_descriptor<Scalar>::name + _("]"));
+    PYBIND11_TYPE_CASTER(Type,
+                         const_name<(Type::IsRowMajor) != 0>("scipy.sparse.csr_matrix[",
+                                                             "scipy.sparse.csc_matrix[")
+                             + npy_format_descriptor<Scalar>::name + const_name("]"));
 };
 
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
-
-#if defined(__GNUG__) || defined(__clang__)
-#  pragma GCC diagnostic pop
-#elif defined(_MSC_VER)
-#  pragma warning(pop)
-#endif
+PYBIND11_NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/eval.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/eval.h`

 * *Files 24% similar despite different names*

```diff
@@ -1,117 +1,156 @@
 /*
-    pybind11/exec.h: Support for evaluating Python expressions and statements
+    pybind11/eval.h: Support for evaluating Python expressions and statements
     from strings and files
 
     Copyright (c) 2016 Klemens Morgenstern <klemens.morgenstern@ed-chemnitz.de> and
                        Wenzel Jakob <wenzel.jakob@epfl.ch>
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "pybind11.h"
 
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+#include <utility>
+
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_BEGIN(detail)
+
+inline void ensure_builtins_in_globals(object &global) {
+#if defined(PYPY_VERSION) || PY_VERSION_HEX < 0x03080000
+    // Running exec and eval adds `builtins` module under `__builtins__` key to
+    // globals if not yet present.  Python 3.8 made PyRun_String behave
+    // similarly. Let's also do that for older versions, for consistency. This
+    // was missing from PyPy3.8 7.3.7.
+    if (!global.contains("__builtins__"))
+        global["__builtins__"] = module_::import(PYBIND11_BUILTINS_MODULE);
+#else
+    (void) global;
+#endif
+}
+
+PYBIND11_NAMESPACE_END(detail)
 
 enum eval_mode {
     /// Evaluate a string containing an isolated expression
     eval_expr,
 
     /// Evaluate a string containing a single statement. Returns \c none
     eval_single_statement,
 
     /// Evaluate a string containing a sequence of statement. Returns \c none
     eval_statements
 };
 
 template <eval_mode mode = eval_expr>
-object eval(str expr, object global = globals(), object local = object()) {
-    if (!local)
+object eval(const str &expr, object global = globals(), object local = object()) {
+    if (!local) {
         local = global;
+    }
+
+    detail::ensure_builtins_in_globals(global);
 
     /* PyRun_String does not accept a PyObject / encoding specifier,
        this seems to be the only alternative */
     std::string buffer = "# -*- coding: utf-8 -*-\n" + (std::string) expr;
 
-    int start;
+    int start = 0;
     switch (mode) {
-        case eval_expr:             start = Py_eval_input;   break;
-        case eval_single_statement: start = Py_single_input; break;
-        case eval_statements:       start = Py_file_input;   break;
-        default: pybind11_fail("invalid evaluation mode");
+        case eval_expr:
+            start = Py_eval_input;
+            break;
+        case eval_single_statement:
+            start = Py_single_input;
+            break;
+        case eval_statements:
+            start = Py_file_input;
+            break;
+        default:
+            pybind11_fail("invalid evaluation mode");
     }
 
     PyObject *result = PyRun_String(buffer.c_str(), start, global.ptr(), local.ptr());
-    if (!result)
+    if (!result) {
         throw error_already_set();
+    }
     return reinterpret_steal<object>(result);
 }
 
 template <eval_mode mode = eval_expr, size_t N>
 object eval(const char (&s)[N], object global = globals(), object local = object()) {
     /* Support raw string literals by removing common leading whitespace */
-    auto expr = (s[0] == '\n') ? str(module::import("textwrap").attr("dedent")(s))
-                               : str(s);
-    return eval<mode>(expr, global, local);
+    auto expr = (s[0] == '\n') ? str(module_::import("textwrap").attr("dedent")(s)) : str(s);
+    return eval<mode>(expr, std::move(global), std::move(local));
 }
 
-inline void exec(str expr, object global = globals(), object local = object()) {
-    eval<eval_statements>(expr, global, local);
+inline void exec(const str &expr, object global = globals(), object local = object()) {
+    eval<eval_statements>(expr, std::move(global), std::move(local));
 }
 
 template <size_t N>
 void exec(const char (&s)[N], object global = globals(), object local = object()) {
-    eval<eval_statements>(s, global, local);
+    eval<eval_statements>(s, std::move(global), std::move(local));
 }
 
+#if defined(PYPY_VERSION)
+template <eval_mode mode = eval_statements>
+object eval_file(str, object, object) {
+    pybind11_fail("eval_file not supported in PyPy3. Use eval");
+}
+template <eval_mode mode = eval_statements>
+object eval_file(str, object) {
+    pybind11_fail("eval_file not supported in PyPy3. Use eval");
+}
+template <eval_mode mode = eval_statements>
+object eval_file(str) {
+    pybind11_fail("eval_file not supported in PyPy3. Use eval");
+}
+#else
 template <eval_mode mode = eval_statements>
 object eval_file(str fname, object global = globals(), object local = object()) {
-    if (!local)
+    if (!local) {
         local = global;
+    }
 
-    int start;
+    detail::ensure_builtins_in_globals(global);
+
+    int start = 0;
     switch (mode) {
-        case eval_expr:             start = Py_eval_input;   break;
-        case eval_single_statement: start = Py_single_input; break;
-        case eval_statements:       start = Py_file_input;   break;
-        default: pybind11_fail("invalid evaluation mode");
+        case eval_expr:
+            start = Py_eval_input;
+            break;
+        case eval_single_statement:
+            start = Py_single_input;
+            break;
+        case eval_statements:
+            start = Py_file_input;
+            break;
+        default:
+            pybind11_fail("invalid evaluation mode");
     }
 
     int closeFile = 1;
     std::string fname_str = (std::string) fname;
-#if PY_VERSION_HEX >= 0x03040000
     FILE *f = _Py_fopen_obj(fname.ptr(), "r");
-#elif PY_VERSION_HEX >= 0x03000000
-    FILE *f = _Py_fopen(fname.ptr(), "r");
-#else
-    /* No unicode support in open() :( */
-    auto fobj = reinterpret_steal<object>(PyFile_FromString(
-        const_cast<char *>(fname_str.c_str()),
-        const_cast<char*>("r")));
-    FILE *f = nullptr;
-    if (fobj)
-        f = PyFile_AsFile(fobj.ptr());
-    closeFile = 0;
-#endif
     if (!f) {
         PyErr_Clear();
         pybind11_fail("File \"" + fname_str + "\" could not be opened!");
     }
 
-#if PY_VERSION_HEX < 0x03000000 && defined(PYPY_VERSION)
-    PyObject *result = PyRun_File(f, fname_str.c_str(), start, global.ptr(),
-                                  local.ptr());
-    (void) closeFile;
-#else
-    PyObject *result = PyRun_FileEx(f, fname_str.c_str(), start, global.ptr(),
-                                    local.ptr(), closeFile);
-#endif
+    if (!global.contains("__file__")) {
+        global["__file__"] = std::move(fname);
+    }
 
-    if (!result)
+    PyObject *result
+        = PyRun_FileEx(f, fname_str.c_str(), start, global.ptr(), local.ptr(), closeFile);
+
+    if (!result) {
         throw error_already_set();
+    }
     return reinterpret_steal<object>(result);
 }
+#endif
 
-NAMESPACE_END(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/functional.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/functional.h`

 * *Files 22% similar despite different names*

```diff
@@ -6,96 +6,132 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "pybind11.h"
+
 #include <functional>
 
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_BEGIN(detail)
 
 template <typename Return, typename... Args>
 struct type_caster<std::function<Return(Args...)>> {
     using type = std::function<Return(Args...)>;
     using retval_type = conditional_t<std::is_same<Return, void>::value, void_type, Return>;
-    using function_type = Return (*) (Args...);
+    using function_type = Return (*)(Args...);
 
 public:
     bool load(handle src, bool convert) {
         if (src.is_none()) {
             // Defer accepting None to other overloads (if we aren't in convert mode):
-            if (!convert) return false;
+            if (!convert) {
+                return false;
+            }
             return true;
         }
 
-        if (!isinstance<function>(src))
+        if (!isinstance<function>(src)) {
             return false;
+        }
 
         auto func = reinterpret_borrow<function>(src);
 
         /*
            When passing a C++ function as an argument to another C++
            function via Python, every function call would normally involve
            a full C++ -> Python -> C++ roundtrip, which can be prohibitive.
            Here, we try to at least detect the case where the function is
            stateless (i.e. function pointer or lambda function without
            captured variables), in which case the roundtrip can be avoided.
          */
         if (auto cfunc = func.cpp_function()) {
-            auto c = reinterpret_borrow<capsule>(PyCFunction_GET_SELF(cfunc.ptr()));
-            auto rec = (function_record *) c;
-
-            if (rec && rec->is_stateless &&
-                    same_type(typeid(function_type), *reinterpret_cast<const std::type_info *>(rec->data[1]))) {
-                struct capture { function_type f; };
-                value = ((capture *) &rec->data)->f;
-                return true;
+            auto *cfunc_self = PyCFunction_GET_SELF(cfunc.ptr());
+            if (cfunc_self == nullptr) {
+                PyErr_Clear();
+            } else if (isinstance<capsule>(cfunc_self)) {
+                auto c = reinterpret_borrow<capsule>(cfunc_self);
+
+                function_record *rec = nullptr;
+                // Check that we can safely reinterpret the capsule into a function_record
+                if (detail::is_function_record_capsule(c)) {
+                    rec = c.get_pointer<function_record>();
+                }
+
+                while (rec != nullptr) {
+                    if (rec->is_stateless
+                        && same_type(typeid(function_type),
+                                     *reinterpret_cast<const std::type_info *>(rec->data[1]))) {
+                        struct capture {
+                            function_type f;
+                        };
+                        value = ((capture *) &rec->data)->f;
+                        return true;
+                    }
+                    rec = rec->next;
+                }
             }
+            // PYPY segfaults here when passing builtin function like sum.
+            // Raising an fail exception here works to prevent the segfault, but only on gcc.
+            // See PR #1413 for full details
         }
 
         // ensure GIL is held during functor destruction
         struct func_handle {
             function f;
-            func_handle(function&& f_) : f(std::move(f_)) {}
-            func_handle(const func_handle&) = default;
+#if !(defined(_MSC_VER) && _MSC_VER == 1916 && defined(PYBIND11_CPP17))
+            // This triggers a syntax error under very special conditions (very weird indeed).
+            explicit
+#endif
+                func_handle(function &&f_) noexcept
+                : f(std::move(f_)) {
+            }
+            func_handle(const func_handle &f_) { operator=(f_); }
+            func_handle &operator=(const func_handle &f_) {
+                gil_scoped_acquire acq;
+                f = f_.f;
+                return *this;
+            }
             ~func_handle() {
                 gil_scoped_acquire acq;
                 function kill_f(std::move(f));
             }
         };
 
         // to emulate 'move initialization capture' in C++11
         struct func_wrapper {
             func_handle hfunc;
-            func_wrapper(func_handle&& hf): hfunc(std::move(hf)) {}
+            explicit func_wrapper(func_handle &&hf) noexcept : hfunc(std::move(hf)) {}
             Return operator()(Args... args) const {
                 gil_scoped_acquire acq;
-                object retval(hfunc.f(std::forward<Args>(args)...));
-                /* Visual studio 2015 parser issue: need parentheses around this expression */
-                return (retval.template cast<Return>());
+                // casts the returned object as a rvalue to the return type
+                return hfunc.f(std::forward<Args>(args)...).template cast<Return>();
             }
         };
 
         value = func_wrapper(func_handle(std::move(func)));
         return true;
     }
 
     template <typename Func>
     static handle cast(Func &&f_, return_value_policy policy, handle /* parent */) {
-        if (!f_)
-            return none().inc_ref();
+        if (!f_) {
+            return none().release();
+        }
 
         auto result = f_.template target<function_type>();
-        if (result)
+        if (result) {
             return cpp_function(*result, policy).release();
-        else
-            return cpp_function(std::forward<Func>(f_), policy).release();
+        }
+        return cpp_function(std::forward<Func>(f_), policy).release();
     }
 
-    PYBIND11_TYPE_CASTER(type, _("Callable[[") + concat(make_caster<Args>::name...) + _("], ")
-                               + make_caster<retval_type>::name + _("]"));
+    PYBIND11_TYPE_CASTER(type,
+                         const_name("Callable[[") + concat(make_caster<Args>::name...)
+                             + const_name("], ") + make_caster<retval_type>::name
+                             + const_name("]"));
 };
 
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/operators.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/operators.h`

 * *Files 16% similar despite different names*

```diff
@@ -7,162 +7,196 @@
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "pybind11.h"
 
-#if defined(__clang__) && !defined(__INTEL_COMPILER)
-#  pragma clang diagnostic ignored "-Wunsequenced" // multiple unsequenced modifications to 'self' (when using def(py::self OP Type()))
-#elif defined(_MSC_VER)
-#  pragma warning(push)
-#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#endif
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_BEGIN(detail)
 
 /// Enumeration with all supported operator types
 enum op_id : int {
-    op_add, op_sub, op_mul, op_div, op_mod, op_divmod, op_pow, op_lshift,
-    op_rshift, op_and, op_xor, op_or, op_neg, op_pos, op_abs, op_invert,
-    op_int, op_long, op_float, op_str, op_cmp, op_gt, op_ge, op_lt, op_le,
-    op_eq, op_ne, op_iadd, op_isub, op_imul, op_idiv, op_imod, op_ilshift,
-    op_irshift, op_iand, op_ixor, op_ior, op_complex, op_bool, op_nonzero,
-    op_repr, op_truediv, op_itruediv, op_hash
+    op_add,
+    op_sub,
+    op_mul,
+    op_div,
+    op_mod,
+    op_divmod,
+    op_pow,
+    op_lshift,
+    op_rshift,
+    op_and,
+    op_xor,
+    op_or,
+    op_neg,
+    op_pos,
+    op_abs,
+    op_invert,
+    op_int,
+    op_long,
+    op_float,
+    op_str,
+    op_cmp,
+    op_gt,
+    op_ge,
+    op_lt,
+    op_le,
+    op_eq,
+    op_ne,
+    op_iadd,
+    op_isub,
+    op_imul,
+    op_idiv,
+    op_imod,
+    op_ilshift,
+    op_irshift,
+    op_iand,
+    op_ixor,
+    op_ior,
+    op_complex,
+    op_bool,
+    op_nonzero,
+    op_repr,
+    op_truediv,
+    op_itruediv,
+    op_hash
 };
 
 enum op_type : int {
     op_l, /* base type on left */
     op_r, /* base type on right */
     op_u  /* unary operator */
 };
 
-struct self_t { };
+struct self_t {};
 static const self_t self = self_t();
 
 /// Type for an unused type slot
-struct undefined_t { };
+struct undefined_t {};
 
 /// Don't warn about an unused variable
 inline self_t __self() { return self; }
 
 /// base template of operator implementations
-template <op_id, op_type, typename B, typename L, typename R> struct op_impl { };
+template <op_id, op_type, typename B, typename L, typename R>
+struct op_impl {};
 
 /// Operator implementation generator
-template <op_id id, op_type ot, typename L, typename R> struct op_ {
-    template <typename Class, typename... Extra> void execute(Class &cl, const Extra&... extra) const {
+template <op_id id, op_type ot, typename L, typename R>
+struct op_ {
+    static constexpr bool op_enable_if_hook = true;
+    template <typename Class, typename... Extra>
+    void execute(Class &cl, const Extra &...extra) const {
         using Base = typename Class::type;
         using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;
         using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;
         using op = op_impl<id, ot, Base, L_type, R_type>;
         cl.def(op::name(), &op::execute, is_operator(), extra...);
-        #if PY_MAJOR_VERSION < 3
-        if (id == op_truediv || id == op_itruediv)
-            cl.def(id == op_itruediv ? "__idiv__" : ot == op_l ? "__div__" : "__rdiv__",
-                    &op::execute, is_operator(), extra...);
-        #endif
     }
-    template <typename Class, typename... Extra> void execute_cast(Class &cl, const Extra&... extra) const {
+    template <typename Class, typename... Extra>
+    void execute_cast(Class &cl, const Extra &...extra) const {
         using Base = typename Class::type;
         using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;
         using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;
         using op = op_impl<id, ot, Base, L_type, R_type>;
         cl.def(op::name(), &op::execute_cast, is_operator(), extra...);
-        #if PY_MAJOR_VERSION < 3
-        if (id == op_truediv || id == op_itruediv)
-            cl.def(id == op_itruediv ? "__idiv__" : ot == op_l ? "__div__" : "__rdiv__",
-                    &op::execute, is_operator(), extra...);
-        #endif
     }
 };
 
-#define PYBIND11_BINARY_OPERATOR(id, rid, op, expr)                                    \
-template <typename B, typename L, typename R> struct op_impl<op_##id, op_l, B, L, R> { \
-    static char const* name() { return "__" #id "__"; }                                \
-    static auto execute(const L &l, const R &r) -> decltype(expr) { return (expr); }   \
-    static B execute_cast(const L &l, const R &r) { return B(expr); }                  \
-};                                                                                     \
-template <typename B, typename L, typename R> struct op_impl<op_##id, op_r, B, L, R> { \
-    static char const* name() { return "__" #rid "__"; }                               \
-    static auto execute(const R &r, const L &l) -> decltype(expr) { return (expr); }   \
-    static B execute_cast(const R &r, const L &l) { return B(expr); }                  \
-};                                                                                     \
-inline op_<op_##id, op_l, self_t, self_t> op(const self_t &, const self_t &) {         \
-    return op_<op_##id, op_l, self_t, self_t>();                                       \
-}                                                                                      \
-template <typename T> op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {    \
-    return op_<op_##id, op_l, self_t, T>();                                            \
-}                                                                                      \
-template <typename T> op_<op_##id, op_r, T, self_t> op(const T &, const self_t &) {    \
-    return op_<op_##id, op_r, T, self_t>();                                            \
-}
-
-#define PYBIND11_INPLACE_OPERATOR(id, op, expr)                                        \
-template <typename B, typename L, typename R> struct op_impl<op_##id, op_l, B, L, R> { \
-    static char const* name() { return "__" #id "__"; }                                \
-    static auto execute(L &l, const R &r) -> decltype(expr) { return expr; }           \
-    static B execute_cast(L &l, const R &r) { return B(expr); }                        \
-};                                                                                     \
-template <typename T> op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {    \
-    return op_<op_##id, op_l, self_t, T>();                                            \
-}
-
-#define PYBIND11_UNARY_OPERATOR(id, op, expr)                                          \
-template <typename B, typename L> struct op_impl<op_##id, op_u, B, L, undefined_t> {   \
-    static char const* name() { return "__" #id "__"; }                                \
-    static auto execute(const L &l) -> decltype(expr) { return expr; }                 \
-    static B execute_cast(const L &l) { return B(expr); }                              \
-};                                                                                     \
-inline op_<op_##id, op_u, self_t, undefined_t> op(const self_t &) {                    \
-    return op_<op_##id, op_u, self_t, undefined_t>();                                  \
-}
-
-PYBIND11_BINARY_OPERATOR(sub,       rsub,         operator-,    l - r)
-PYBIND11_BINARY_OPERATOR(add,       radd,         operator+,    l + r)
-PYBIND11_BINARY_OPERATOR(mul,       rmul,         operator*,    l * r)
-PYBIND11_BINARY_OPERATOR(truediv,   rtruediv,     operator/,    l / r)
-PYBIND11_BINARY_OPERATOR(mod,       rmod,         operator%,    l % r)
-PYBIND11_BINARY_OPERATOR(lshift,    rlshift,      operator<<,   l << r)
-PYBIND11_BINARY_OPERATOR(rshift,    rrshift,      operator>>,   l >> r)
-PYBIND11_BINARY_OPERATOR(and,       rand,         operator&,    l & r)
-PYBIND11_BINARY_OPERATOR(xor,       rxor,         operator^,    l ^ r)
-PYBIND11_BINARY_OPERATOR(eq,        eq,           operator==,   l == r)
-PYBIND11_BINARY_OPERATOR(ne,        ne,           operator!=,   l != r)
-PYBIND11_BINARY_OPERATOR(or,        ror,          operator|,    l | r)
-PYBIND11_BINARY_OPERATOR(gt,        lt,           operator>,    l > r)
-PYBIND11_BINARY_OPERATOR(ge,        le,           operator>=,   l >= r)
-PYBIND11_BINARY_OPERATOR(lt,        gt,           operator<,    l < r)
-PYBIND11_BINARY_OPERATOR(le,        ge,           operator<=,   l <= r)
-//PYBIND11_BINARY_OPERATOR(pow,       rpow,         pow,          std::pow(l,  r))
-PYBIND11_INPLACE_OPERATOR(iadd,     operator+=,   l += r)
-PYBIND11_INPLACE_OPERATOR(isub,     operator-=,   l -= r)
-PYBIND11_INPLACE_OPERATOR(imul,     operator*=,   l *= r)
-PYBIND11_INPLACE_OPERATOR(itruediv, operator/=,   l /= r)
-PYBIND11_INPLACE_OPERATOR(imod,     operator%=,   l %= r)
-PYBIND11_INPLACE_OPERATOR(ilshift,  operator<<=,  l <<= r)
-PYBIND11_INPLACE_OPERATOR(irshift,  operator>>=,  l >>= r)
-PYBIND11_INPLACE_OPERATOR(iand,     operator&=,   l &= r)
-PYBIND11_INPLACE_OPERATOR(ixor,     operator^=,   l ^= r)
-PYBIND11_INPLACE_OPERATOR(ior,      operator|=,   l |= r)
-PYBIND11_UNARY_OPERATOR(neg,        operator-,    -l)
-PYBIND11_UNARY_OPERATOR(pos,        operator+,    +l)
-PYBIND11_UNARY_OPERATOR(abs,        abs,          std::abs(l))
-PYBIND11_UNARY_OPERATOR(hash,       hash,         std::hash<L>()(l))
-PYBIND11_UNARY_OPERATOR(invert,     operator~,    (~l))
-PYBIND11_UNARY_OPERATOR(bool,       operator!,    !!l)
-PYBIND11_UNARY_OPERATOR(int,        int_,         (int) l)
-PYBIND11_UNARY_OPERATOR(float,      float_,       (double) l)
+#define PYBIND11_BINARY_OPERATOR(id, rid, op, expr)                                               \
+    template <typename B, typename L, typename R>                                                 \
+    struct op_impl<op_##id, op_l, B, L, R> {                                                      \
+        static char const *name() { return "__" #id "__"; }                                       \
+        static auto execute(const L &l, const R &r) -> decltype(expr) { return (expr); }          \
+        static B execute_cast(const L &l, const R &r) { return B(expr); }                         \
+    };                                                                                            \
+    template <typename B, typename L, typename R>                                                 \
+    struct op_impl<op_##id, op_r, B, L, R> {                                                      \
+        static char const *name() { return "__" #rid "__"; }                                      \
+        static auto execute(const R &r, const L &l) -> decltype(expr) { return (expr); }          \
+        static B execute_cast(const R &r, const L &l) { return B(expr); }                         \
+    };                                                                                            \
+    inline op_<op_##id, op_l, self_t, self_t> op(const self_t &, const self_t &) {                \
+        return op_<op_##id, op_l, self_t, self_t>();                                              \
+    }                                                                                             \
+    template <typename T>                                                                         \
+    op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {                                 \
+        return op_<op_##id, op_l, self_t, T>();                                                   \
+    }                                                                                             \
+    template <typename T>                                                                         \
+    op_<op_##id, op_r, T, self_t> op(const T &, const self_t &) {                                 \
+        return op_<op_##id, op_r, T, self_t>();                                                   \
+    }
+
+#define PYBIND11_INPLACE_OPERATOR(id, op, expr)                                                   \
+    template <typename B, typename L, typename R>                                                 \
+    struct op_impl<op_##id, op_l, B, L, R> {                                                      \
+        static char const *name() { return "__" #id "__"; }                                       \
+        static auto execute(L &l, const R &r) -> decltype(expr) { return expr; }                  \
+        static B execute_cast(L &l, const R &r) { return B(expr); }                               \
+    };                                                                                            \
+    template <typename T>                                                                         \
+    op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {                                 \
+        return op_<op_##id, op_l, self_t, T>();                                                   \
+    }
+
+#define PYBIND11_UNARY_OPERATOR(id, op, expr)                                                     \
+    template <typename B, typename L>                                                             \
+    struct op_impl<op_##id, op_u, B, L, undefined_t> {                                            \
+        static char const *name() { return "__" #id "__"; }                                       \
+        static auto execute(const L &l) -> decltype(expr) { return expr; }                        \
+        static B execute_cast(const L &l) { return B(expr); }                                     \
+    };                                                                                            \
+    inline op_<op_##id, op_u, self_t, undefined_t> op(const self_t &) {                           \
+        return op_<op_##id, op_u, self_t, undefined_t>();                                         \
+    }
+
+PYBIND11_BINARY_OPERATOR(sub, rsub, operator-, l - r)
+PYBIND11_BINARY_OPERATOR(add, radd, operator+, l + r)
+PYBIND11_BINARY_OPERATOR(mul, rmul, operator*, l *r)
+PYBIND11_BINARY_OPERATOR(truediv, rtruediv, operator/, l / r)
+PYBIND11_BINARY_OPERATOR(mod, rmod, operator%, l % r)
+PYBIND11_BINARY_OPERATOR(lshift, rlshift, operator<<, l << r)
+PYBIND11_BINARY_OPERATOR(rshift, rrshift, operator>>, l >> r)
+PYBIND11_BINARY_OPERATOR(and, rand, operator&, l &r)
+PYBIND11_BINARY_OPERATOR(xor, rxor, operator^, l ^ r)
+PYBIND11_BINARY_OPERATOR(eq, eq, operator==, l == r)
+PYBIND11_BINARY_OPERATOR(ne, ne, operator!=, l != r)
+PYBIND11_BINARY_OPERATOR(or, ror, operator|, l | r)
+PYBIND11_BINARY_OPERATOR(gt, lt, operator>, l > r)
+PYBIND11_BINARY_OPERATOR(ge, le, operator>=, l >= r)
+PYBIND11_BINARY_OPERATOR(lt, gt, operator<, l < r)
+PYBIND11_BINARY_OPERATOR(le, ge, operator<=, l <= r)
+// PYBIND11_BINARY_OPERATOR(pow,       rpow,         pow,          std::pow(l,  r))
+PYBIND11_INPLACE_OPERATOR(iadd, operator+=, l += r)
+PYBIND11_INPLACE_OPERATOR(isub, operator-=, l -= r)
+PYBIND11_INPLACE_OPERATOR(imul, operator*=, l *= r)
+PYBIND11_INPLACE_OPERATOR(itruediv, operator/=, l /= r)
+PYBIND11_INPLACE_OPERATOR(imod, operator%=, l %= r)
+PYBIND11_INPLACE_OPERATOR(ilshift, operator<<=, l <<= r)
+PYBIND11_INPLACE_OPERATOR(irshift, operator>>=, l >>= r)
+PYBIND11_INPLACE_OPERATOR(iand, operator&=, l &= r)
+PYBIND11_INPLACE_OPERATOR(ixor, operator^=, l ^= r)
+PYBIND11_INPLACE_OPERATOR(ior, operator|=, l |= r)
+PYBIND11_UNARY_OPERATOR(neg, operator-, -l)
+PYBIND11_UNARY_OPERATOR(pos, operator+, +l)
+// WARNING: This usage of `abs` should only be done for existing STL overloads.
+// Adding overloads directly in to the `std::` namespace is advised against:
+// https://en.cppreference.com/w/cpp/language/extending_std
+PYBIND11_UNARY_OPERATOR(abs, abs, std::abs(l))
+PYBIND11_UNARY_OPERATOR(hash, hash, std::hash<L>()(l))
+PYBIND11_UNARY_OPERATOR(invert, operator~, (~l))
+PYBIND11_UNARY_OPERATOR(bool, operator!, !!l)
+PYBIND11_UNARY_OPERATOR(int, int_, (int) l)
+PYBIND11_UNARY_OPERATOR(float, float_, (double) l)
 
 #undef PYBIND11_BINARY_OPERATOR
 #undef PYBIND11_INPLACE_OPERATOR
 #undef PYBIND11_UNARY_OPERATOR
-NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(detail)
 
 using detail::self;
+// Add named operators so that they are accessible via `py::`.
+using detail::hash;
 
-NAMESPACE_END(PYBIND11_NAMESPACE)
-
-#if defined(_MSC_VER)
-#  pragma warning(pop)
-#endif
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/pybind11.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/pybind11.h`

 * *Files 10% similar despite different names*

```diff
@@ -6,461 +6,706 @@
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
-#if defined(__INTEL_COMPILER)
-#  pragma warning push
-#  pragma warning disable 68    // integer conversion resulted in a change of sign
-#  pragma warning disable 186   // pointless comparison of unsigned integer with zero
-#  pragma warning disable 878   // incompatible exception specifications
-#  pragma warning disable 1334  // the "template" keyword used for syntactic disambiguation may only be used within a template
-#  pragma warning disable 1682  // implicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem)
-#  pragma warning disable 1786  // function "strdup" was declared deprecated
-#  pragma warning disable 1875  // offsetof applied to non-POD (Plain Old Data) types is nonstandard
-#  pragma warning disable 2196  // warning #2196: routine is both "inline" and "noinline"
-#elif defined(_MSC_VER)
-#  pragma warning(push)
-#  pragma warning(disable: 4100) // warning C4100: Unreferenced formal parameter
-#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#  pragma warning(disable: 4512) // warning C4512: Assignment operator was implicitly defined as deleted
-#  pragma warning(disable: 4800) // warning C4800: 'int': forcing value to bool 'true' or 'false' (performance warning)
-#  pragma warning(disable: 4996) // warning C4996: The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name
-#  pragma warning(disable: 4702) // warning C4702: unreachable code
-#  pragma warning(disable: 4522) // warning C4522: multiple assignment operators specified
-#elif defined(__GNUG__) && !defined(__clang__)
-#  pragma GCC diagnostic push
-#  pragma GCC diagnostic ignored "-Wunused-but-set-parameter"
-#  pragma GCC diagnostic ignored "-Wunused-but-set-variable"
-#  pragma GCC diagnostic ignored "-Wmissing-field-initializers"
-#  pragma GCC diagnostic ignored "-Wstrict-aliasing"
-#  pragma GCC diagnostic ignored "-Wattributes"
-#  if __GNUC__ >= 7
-#    pragma GCC diagnostic ignored "-Wnoexcept-type"
-#  endif
-#endif
-
-#include "attr.h"
-#include "options.h"
 #include "detail/class.h"
 #include "detail/init.h"
+#include "attr.h"
+#include "gil.h"
+#include "options.h"
 
+#include <cstdlib>
+#include <cstring>
+#include <memory>
+#include <new>
+#include <string>
+#include <utility>
+#include <vector>
+
+#if defined(__cpp_lib_launder) && !(defined(_MSC_VER) && (_MSC_VER < 1914))
+#    define PYBIND11_STD_LAUNDER std::launder
+#    define PYBIND11_HAS_STD_LAUNDER 1
+#else
+#    define PYBIND11_STD_LAUNDER
+#    define PYBIND11_HAS_STD_LAUNDER 0
+#endif
 #if defined(__GNUG__) && !defined(__clang__)
-#  include <cxxabi.h>
+#    include <cxxabi.h>
+#endif
+
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+
+/* https://stackoverflow.com/questions/46798456/handling-gccs-noexcept-type-warning
+   This warning is about ABI compatibility, not code health.
+   It is only actually needed in a couple places, but apparently GCC 7 "generates this warning if
+   and only if the first template instantiation ... involves noexcept" [stackoverflow], therefore
+   it could get triggered from seemingly random places, depending on user code.
+   No other GCC version generates this warning.
+ */
+#if defined(__GNUC__) && __GNUC__ == 7
+PYBIND11_WARNING_DISABLE_GCC("-Wnoexcept-type")
+#endif
+
+PYBIND11_WARNING_DISABLE_MSVC(4127)
+
+PYBIND11_NAMESPACE_BEGIN(detail)
+
+// Apply all the extensions translators from a list
+// Return true if one of the translators completed without raising an exception
+// itself. Return of false indicates that if there are other translators
+// available, they should be tried.
+inline bool apply_exception_translators(std::forward_list<ExceptionTranslator> &translators) {
+    auto last_exception = std::current_exception();
+
+    for (auto &translator : translators) {
+        try {
+            translator(last_exception);
+            return true;
+        } catch (...) {
+            last_exception = std::current_exception();
+        }
+    }
+    return false;
+}
+
+#if defined(_MSC_VER)
+#    define PYBIND11_COMPAT_STRDUP _strdup
+#else
+#    define PYBIND11_COMPAT_STRDUP strdup
 #endif
 
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_END(detail)
 
 /// Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object
 class cpp_function : public function {
 public:
-    cpp_function() { }
-    cpp_function(std::nullptr_t) { }
+    cpp_function() = default;
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    cpp_function(std::nullptr_t) {}
 
     /// Construct a cpp_function from a vanilla function pointer
     template <typename Return, typename... Args, typename... Extra>
-    cpp_function(Return (*f)(Args...), const Extra&... extra) {
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    cpp_function(Return (*f)(Args...), const Extra &...extra) {
         initialize(f, f, extra...);
     }
 
     /// Construct a cpp_function from a lambda function (possibly with internal state)
-    template <typename Func, typename... Extra,
+    template <typename Func,
+              typename... Extra,
               typename = detail::enable_if_t<detail::is_lambda<Func>::value>>
-    cpp_function(Func &&f, const Extra&... extra) {
-        initialize(std::forward<Func>(f),
-                   (detail::function_signature_t<Func> *) nullptr, extra...);
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    cpp_function(Func &&f, const Extra &...extra) {
+        initialize(
+            std::forward<Func>(f), (detail::function_signature_t<Func> *) nullptr, extra...);
+    }
+
+    /// Construct a cpp_function from a class method (non-const, no ref-qualifier)
+    template <typename Return, typename Class, typename... Arg, typename... Extra>
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    cpp_function(Return (Class::*f)(Arg...), const Extra &...extra) {
+        initialize(
+            [f](Class *c, Arg... args) -> Return { return (c->*f)(std::forward<Arg>(args)...); },
+            (Return(*)(Class *, Arg...)) nullptr,
+            extra...);
+    }
+
+    /// Construct a cpp_function from a class method (non-const, lvalue ref-qualifier)
+    /// A copy of the overload for non-const functions without explicit ref-qualifier
+    /// but with an added `&`.
+    template <typename Return, typename Class, typename... Arg, typename... Extra>
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    cpp_function(Return (Class::*f)(Arg...) &, const Extra &...extra) {
+        initialize(
+            [f](Class *c, Arg... args) -> Return { return (c->*f)(std::forward<Arg>(args)...); },
+            (Return(*)(Class *, Arg...)) nullptr,
+            extra...);
     }
 
-    /// Construct a cpp_function from a class method (non-const)
+    /// Construct a cpp_function from a class method (const, no ref-qualifier)
     template <typename Return, typename Class, typename... Arg, typename... Extra>
-    cpp_function(Return (Class::*f)(Arg...), const Extra&... extra) {
-        initialize([f](Class *c, Arg... args) -> Return { return (c->*f)(args...); },
-                   (Return (*) (Class *, Arg...)) nullptr, extra...);
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    cpp_function(Return (Class::*f)(Arg...) const, const Extra &...extra) {
+        initialize([f](const Class *c,
+                       Arg... args) -> Return { return (c->*f)(std::forward<Arg>(args)...); },
+                   (Return(*)(const Class *, Arg...)) nullptr,
+                   extra...);
     }
 
-    /// Construct a cpp_function from a class method (const)
+    /// Construct a cpp_function from a class method (const, lvalue ref-qualifier)
+    /// A copy of the overload for const functions without explicit ref-qualifier
+    /// but with an added `&`.
     template <typename Return, typename Class, typename... Arg, typename... Extra>
-    cpp_function(Return (Class::*f)(Arg...) const, const Extra&... extra) {
-        initialize([f](const Class *c, Arg... args) -> Return { return (c->*f)(args...); },
-                   (Return (*)(const Class *, Arg ...)) nullptr, extra...);
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    cpp_function(Return (Class::*f)(Arg...) const &, const Extra &...extra) {
+        initialize([f](const Class *c,
+                       Arg... args) -> Return { return (c->*f)(std::forward<Arg>(args)...); },
+                   (Return(*)(const Class *, Arg...)) nullptr,
+                   extra...);
     }
 
     /// Return the function name
     object name() const { return attr("__name__"); }
 
 protected:
+    struct InitializingFunctionRecordDeleter {
+        // `destruct(function_record, false)`: `initialize_generic` copies strings and
+        // takes care of cleaning up in case of exceptions. So pass `false` to `free_strings`.
+        void operator()(detail::function_record *rec) { destruct(rec, false); }
+    };
+    using unique_function_record
+        = std::unique_ptr<detail::function_record, InitializingFunctionRecordDeleter>;
+
     /// Space optimization: don't inline this frequently instantiated fragment
-    PYBIND11_NOINLINE detail::function_record *make_function_record() {
-        return new detail::function_record();
+    PYBIND11_NOINLINE unique_function_record make_function_record() {
+        return unique_function_record(new detail::function_record());
     }
 
     /// Special internal constructor for functors, lambda functions, etc.
     template <typename Func, typename Return, typename... Args, typename... Extra>
-    void initialize(Func &&f, Return (*)(Args...), const Extra&... extra) {
+    void initialize(Func &&f, Return (*)(Args...), const Extra &...extra) {
         using namespace detail;
-        struct capture { remove_reference_t<Func> f; };
+        struct capture {
+            remove_reference_t<Func> f;
+        };
 
-        /* Store the function including any extra state it might have (e.g. a lambda capture object) */
-        auto rec = make_function_record();
+        /* Store the function including any extra state it might have (e.g. a lambda capture
+         * object) */
+        // The unique_ptr makes sure nothing is leaked in case of an exception.
+        auto unique_rec = make_function_record();
+        auto *rec = unique_rec.get();
 
         /* Store the capture object directly in the function record if there is enough space */
         if (sizeof(capture) <= sizeof(rec->data)) {
             /* Without these pragmas, GCC warns that there might not be
                enough space to use the placement new operator. However, the
                'if' statement above ensures that this is the case. */
-#if defined(__GNUG__) && !defined(__clang__) && __GNUC__ >= 6
-#  pragma GCC diagnostic push
-#  pragma GCC diagnostic ignored "-Wplacement-new"
+            PYBIND11_WARNING_PUSH
+
+#if defined(__GNUG__) && __GNUC__ >= 6
+            PYBIND11_WARNING_DISABLE_GCC("-Wplacement-new")
 #endif
-            new ((capture *) &rec->data) capture { std::forward<Func>(f) };
-#if defined(__GNUG__) && !defined(__clang__) && __GNUC__ >= 6
-#  pragma GCC diagnostic pop
+
+            new ((capture *) &rec->data) capture{std::forward<Func>(f)};
+
+#if !PYBIND11_HAS_STD_LAUNDER
+            PYBIND11_WARNING_DISABLE_GCC("-Wstrict-aliasing")
 #endif
-            if (!std::is_trivially_destructible<Func>::value)
-                rec->free_data = [](function_record *r) { ((capture *) &r->data)->~capture(); };
+
+            // UB without std::launder, but without breaking ABI and/or
+            // a significant refactoring it's "impossible" to solve.
+            if (!std::is_trivially_destructible<capture>::value) {
+                rec->free_data = [](function_record *r) {
+                    auto data = PYBIND11_STD_LAUNDER((capture *) &r->data);
+                    (void) data;
+                    data->~capture();
+                };
+            }
+            PYBIND11_WARNING_POP
         } else {
-            rec->data[0] = new capture { std::forward<Func>(f) };
+            rec->data[0] = new capture{std::forward<Func>(f)};
             rec->free_data = [](function_record *r) { delete ((capture *) r->data[0]); };
         }
 
         /* Type casters for the function arguments and return value */
         using cast_in = argument_loader<Args...>;
-        using cast_out = make_caster<
-            conditional_t<std::is_void<Return>::value, void_type, Return>
-        >;
+        using cast_out
+            = make_caster<conditional_t<std::is_void<Return>::value, void_type, Return>>;
 
-        static_assert(expected_num_args<Extra...>(sizeof...(Args), cast_in::has_args, cast_in::has_kwargs),
-                      "The number of argument annotations does not match the number of function arguments");
+        static_assert(
+            expected_num_args<Extra...>(
+                sizeof...(Args), cast_in::args_pos >= 0, cast_in::has_kwargs),
+            "The number of argument annotations does not match the number of function arguments");
 
         /* Dispatch code which converts function arguments and performs the actual function call */
         rec->impl = [](function_call &call) -> handle {
             cast_in args_converter;
 
             /* Try to cast the function arguments into the C++ domain */
-            if (!args_converter.load_args(call))
+            if (!args_converter.load_args(call)) {
                 return PYBIND11_TRY_NEXT_OVERLOAD;
+            }
 
             /* Invoke call policy pre-call hook */
             process_attributes<Extra...>::precall(call);
 
             /* Get a pointer to the capture object */
-            auto data = (sizeof(capture) <= sizeof(call.func.data)
-                         ? &call.func.data : call.func.data[0]);
-            capture *cap = const_cast<capture *>(reinterpret_cast<const capture *>(data));
+            const auto *data = (sizeof(capture) <= sizeof(call.func.data) ? &call.func.data
+                                                                          : call.func.data[0]);
+            auto *cap = const_cast<capture *>(reinterpret_cast<const capture *>(data));
 
             /* Override policy for rvalues -- usually to enforce rvp::move on an rvalue */
-            return_value_policy policy = return_value_policy_override<Return>::policy(call.func.policy);
+            return_value_policy policy
+                = return_value_policy_override<Return>::policy(call.func.policy);
 
             /* Function scope guard -- defaults to the compile-to-nothing `void_type` */
             using Guard = extract_guard_t<Extra...>;
 
             /* Perform the function call */
-            handle result = cast_out::cast(
-                std::move(args_converter).template call<Return, Guard>(cap->f), policy, call.parent);
+            handle result
+                = cast_out::cast(std::move(args_converter).template call<Return, Guard>(cap->f),
+                                 policy,
+                                 call.parent);
 
             /* Invoke call policy post-call hook */
             process_attributes<Extra...>::postcall(call, result);
 
             return result;
         };
 
+        rec->nargs_pos = cast_in::args_pos >= 0
+                             ? static_cast<std::uint16_t>(cast_in::args_pos)
+                             : sizeof...(Args) - cast_in::has_kwargs; // Will get reduced more if
+                                                                      // we have a kw_only
+        rec->has_args = cast_in::args_pos >= 0;
+        rec->has_kwargs = cast_in::has_kwargs;
+
         /* Process any user-provided function attributes */
         process_attributes<Extra...>::init(extra..., rec);
 
         {
-            constexpr bool has_kwonly_args = any_of<std::is_same<kwonly, Extra>...>::value,
-                           has_args = any_of<std::is_same<args, Args>...>::value,
+            constexpr bool has_kw_only_args = any_of<std::is_same<kw_only, Extra>...>::value,
+                           has_pos_only_args = any_of<std::is_same<pos_only, Extra>...>::value,
                            has_arg_annotations = any_of<is_keyword<Extra>...>::value;
-            static_assert(has_arg_annotations || !has_kwonly_args, "py::kwonly requires the use of argument annotations");
-            static_assert(!(has_args && has_kwonly_args), "py::kwonly cannot be combined with a py::args argument");
-        }
-
-        /* Generate a readable signature describing the function's arguments and return value types */
-        static constexpr auto signature = _("(") + cast_in::arg_names + _(") -> ") + cast_out::name;
+            static_assert(has_arg_annotations || !has_kw_only_args,
+                          "py::kw_only requires the use of argument annotations");
+            static_assert(has_arg_annotations || !has_pos_only_args,
+                          "py::pos_only requires the use of argument annotations (for docstrings "
+                          "and aligning the annotations to the argument)");
+
+            static_assert(constexpr_sum(is_kw_only<Extra>::value...) <= 1,
+                          "py::kw_only may be specified only once");
+            static_assert(constexpr_sum(is_pos_only<Extra>::value...) <= 1,
+                          "py::pos_only may be specified only once");
+            constexpr auto kw_only_pos = constexpr_first<is_kw_only, Extra...>();
+            constexpr auto pos_only_pos = constexpr_first<is_pos_only, Extra...>();
+            static_assert(!(has_kw_only_args && has_pos_only_args) || pos_only_pos < kw_only_pos,
+                          "py::pos_only must come before py::kw_only");
+        }
+
+        /* Generate a readable signature describing the function's arguments and return
+           value types */
+        static constexpr auto signature
+            = const_name("(") + cast_in::arg_names + const_name(") -> ") + cast_out::name;
         PYBIND11_DESCR_CONSTEXPR auto types = decltype(signature)::types();
 
         /* Register the function with Python from generic (non-templated) code */
-        initialize_generic(rec, signature.text, types.data(), sizeof...(Args));
-
-        if (cast_in::has_args) rec->has_args = true;
-        if (cast_in::has_kwargs) rec->has_kwargs = true;
+        // Pass on the ownership over the `unique_rec` to `initialize_generic`. `rec` stays valid.
+        initialize_generic(std::move(unique_rec), signature.text, types.data(), sizeof...(Args));
 
         /* Stash some additional information used by an important optimization in 'functional.h' */
         using FunctionType = Return (*)(Args...);
-        constexpr bool is_function_ptr =
-            std::is_convertible<Func, FunctionType>::value &&
-            sizeof(capture) == sizeof(void *);
+        constexpr bool is_function_ptr
+            = std::is_convertible<Func, FunctionType>::value && sizeof(capture) == sizeof(void *);
         if (is_function_ptr) {
             rec->is_stateless = true;
-            rec->data[1] = const_cast<void *>(reinterpret_cast<const void *>(&typeid(FunctionType)));
+            rec->data[1]
+                = const_cast<void *>(reinterpret_cast<const void *>(&typeid(FunctionType)));
         }
     }
 
+    // Utility class that keeps track of all duplicated strings, and cleans them up in its
+    // destructor, unless they are released. Basically a RAII-solution to deal with exceptions
+    // along the way.
+    class strdup_guard {
+    public:
+        strdup_guard() = default;
+        strdup_guard(const strdup_guard &) = delete;
+        strdup_guard &operator=(const strdup_guard &) = delete;
+
+        ~strdup_guard() {
+            for (auto *s : strings) {
+                std::free(s);
+            }
+        }
+        char *operator()(const char *s) {
+            auto *t = PYBIND11_COMPAT_STRDUP(s);
+            strings.push_back(t);
+            return t;
+        }
+        void release() { strings.clear(); }
+
+    private:
+        std::vector<char *> strings;
+    };
+
     /// Register a function call with Python (generic non-templated code goes here)
-    void initialize_generic(detail::function_record *rec, const char *text,
-                            const std::type_info *const *types, size_t args) {
+    void initialize_generic(unique_function_record &&unique_rec,
+                            const char *text,
+                            const std::type_info *const *types,
+                            size_t args) {
+        // Do NOT receive `unique_rec` by value. If this function fails to move out the unique_ptr,
+        // we do not want this to destruct the pointer. `initialize` (the caller) still relies on
+        // the pointee being alive after this call. Only move out if a `capsule` is going to keep
+        // it alive.
+        auto *rec = unique_rec.get();
+
+        // Keep track of strdup'ed strings, and clean them up as long as the function's capsule
+        // has not taken ownership yet (when `unique_rec.release()` is called).
+        // Note: This cannot easily be fixed by a `unique_ptr` with custom deleter, because the
+        // strings are only referenced before strdup'ing. So only *after* the following block could
+        // `destruct` safely be called, but even then, `repr` could still throw in the middle of
+        // copying all strings.
+        strdup_guard guarded_strdup;
 
         /* Create copies of all referenced C-style strings */
-        rec->name = strdup(rec->name ? rec->name : "");
-        if (rec->doc) rec->doc = strdup(rec->doc);
-        for (auto &a: rec->args) {
-            if (a.name)
-                a.name = strdup(a.name);
-            if (a.descr)
-                a.descr = strdup(a.descr);
-            else if (a.value)
-                a.descr = strdup(a.value.attr("__repr__")().cast<std::string>().c_str());
+        rec->name = guarded_strdup(rec->name ? rec->name : "");
+        if (rec->doc) {
+            rec->doc = guarded_strdup(rec->doc);
+        }
+        for (auto &a : rec->args) {
+            if (a.name) {
+                a.name = guarded_strdup(a.name);
+            }
+            if (a.descr) {
+                a.descr = guarded_strdup(a.descr);
+            } else if (a.value) {
+                a.descr = guarded_strdup(repr(a.value).cast<std::string>().c_str());
+            }
         }
 
-        rec->is_constructor = !strcmp(rec->name, "__init__") || !strcmp(rec->name, "__setstate__");
+        rec->is_constructor = (std::strcmp(rec->name, "__init__") == 0)
+                              || (std::strcmp(rec->name, "__setstate__") == 0);
 
-#if !defined(NDEBUG) && !defined(PYBIND11_DISABLE_NEW_STYLE_INIT_WARNING)
+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES) && !defined(PYBIND11_DISABLE_NEW_STYLE_INIT_WARNING)
         if (rec->is_constructor && !rec->is_new_style_constructor) {
-            const auto class_name = std::string(((PyTypeObject *) rec->scope.ptr())->tp_name);
+            const auto class_name
+                = detail::get_fully_qualified_tp_name((PyTypeObject *) rec->scope.ptr());
             const auto func_name = std::string(rec->name);
-            PyErr_WarnEx(
-                PyExc_FutureWarning,
-                ("pybind11-bound class '" + class_name + "' is using an old-style "
-                 "placement-new '" + func_name + "' which has been deprecated. See "
-                 "the upgrade guide in pybind11's docs. This message is only visible "
-                 "when compiled in debug mode.").c_str(), 0
-            );
+            PyErr_WarnEx(PyExc_FutureWarning,
+                         ("pybind11-bound class '" + class_name
+                          + "' is using an old-style "
+                            "placement-new '"
+                          + func_name
+                          + "' which has been deprecated. See "
+                            "the upgrade guide in pybind11's docs. This message is only visible "
+                            "when compiled in debug mode.")
+                             .c_str(),
+                         0);
         }
 #endif
 
         /* Generate a proper function signature */
         std::string signature;
         size_t type_index = 0, arg_index = 0;
-        for (auto *pc = text; *pc != '\0'; ++pc) {
+        bool is_starred = false;
+        for (const auto *pc = text; *pc != '\0'; ++pc) {
             const auto c = *pc;
 
             if (c == '{') {
                 // Write arg name for everything except *args and **kwargs.
-                if (*(pc + 1) == '*')
+                is_starred = *(pc + 1) == '*';
+                if (is_starred) {
                     continue;
-
+                }
+                // Separator for keyword-only arguments, placed before the kw
+                // arguments start (unless we are already putting an *args)
+                if (!rec->has_args && arg_index == rec->nargs_pos) {
+                    signature += "*, ";
+                }
                 if (arg_index < rec->args.size() && rec->args[arg_index].name) {
                     signature += rec->args[arg_index].name;
                 } else if (arg_index == 0 && rec->is_method) {
                     signature += "self";
                 } else {
                     signature += "arg" + std::to_string(arg_index - (rec->is_method ? 1 : 0));
                 }
                 signature += ": ";
             } else if (c == '}') {
                 // Write default value if available.
-                if (arg_index < rec->args.size() && rec->args[arg_index].descr) {
+                if (!is_starred && arg_index < rec->args.size() && rec->args[arg_index].descr) {
                     signature += " = ";
                     signature += rec->args[arg_index].descr;
                 }
-                arg_index++;
+                // Separator for positional-only arguments (placed after the
+                // argument, rather than before like *
+                if (rec->nargs_pos_only > 0 && (arg_index + 1) == rec->nargs_pos_only) {
+                    signature += ", /";
+                }
+                if (!is_starred) {
+                    arg_index++;
+                }
             } else if (c == '%') {
                 const std::type_info *t = types[type_index++];
-                if (!t)
+                if (!t) {
                     pybind11_fail("Internal error while parsing type signature (1)");
-                if (auto tinfo = detail::get_type_info(*t)) {
+                }
+                if (auto *tinfo = detail::get_type_info(*t)) {
                     handle th((PyObject *) tinfo->type);
-                    signature +=
-                        th.attr("__module__").cast<std::string>() + "." +
-                        th.attr("__qualname__").cast<std::string>(); // Python 3.3+, but we backport it to earlier versions
+                    signature += th.attr("__module__").cast<std::string>() + "."
+                                 + th.attr("__qualname__").cast<std::string>();
                 } else if (rec->is_new_style_constructor && arg_index == 0) {
                     // A new-style `__init__` takes `self` as `value_and_holder`.
                     // Rewrite it to the proper class type.
-                    signature +=
-                        rec->scope.attr("__module__").cast<std::string>() + "." +
-                        rec->scope.attr("__qualname__").cast<std::string>();
+                    signature += rec->scope.attr("__module__").cast<std::string>() + "."
+                                 + rec->scope.attr("__qualname__").cast<std::string>();
                 } else {
                     std::string tname(t->name());
                     detail::clean_type_id(tname);
                     signature += tname;
                 }
             } else {
                 signature += c;
             }
         }
-        if (arg_index != args || types[type_index] != nullptr)
-            pybind11_fail("Internal error while parsing type signature (2)");
 
-#if PY_MAJOR_VERSION < 3
-        if (strcmp(rec->name, "__next__") == 0) {
-            std::free(rec->name);
-            rec->name = strdup("next");
-        } else if (strcmp(rec->name, "__bool__") == 0) {
-            std::free(rec->name);
-            rec->name = strdup("__nonzero__");
+        if (arg_index != args - rec->has_args - rec->has_kwargs || types[type_index] != nullptr) {
+            pybind11_fail("Internal error while parsing type signature (2)");
         }
-#endif
-        rec->signature = strdup(signature.c_str());
+
+        rec->signature = guarded_strdup(signature.c_str());
         rec->args.shrink_to_fit();
         rec->nargs = (std::uint16_t) args;
 
-        if (rec->sibling && PYBIND11_INSTANCE_METHOD_CHECK(rec->sibling.ptr()))
+        if (rec->sibling && PYBIND11_INSTANCE_METHOD_CHECK(rec->sibling.ptr())) {
             rec->sibling = PYBIND11_INSTANCE_METHOD_GET_FUNCTION(rec->sibling.ptr());
+        }
 
         detail::function_record *chain = nullptr, *chain_start = rec;
         if (rec->sibling) {
             if (PyCFunction_Check(rec->sibling.ptr())) {
-                auto rec_capsule = reinterpret_borrow<capsule>(PyCFunction_GET_SELF(rec->sibling.ptr()));
-                chain = (detail::function_record *) rec_capsule;
-                /* Never append a method to an overload chain of a parent class;
-                   instead, hide the parent's overloads in this case */
-                if (!chain->scope.is(rec->scope))
+                auto *self = PyCFunction_GET_SELF(rec->sibling.ptr());
+                if (!isinstance<capsule>(self)) {
                     chain = nullptr;
+                } else {
+                    auto rec_capsule = reinterpret_borrow<capsule>(self);
+                    if (detail::is_function_record_capsule(rec_capsule)) {
+                        chain = rec_capsule.get_pointer<detail::function_record>();
+                        /* Never append a method to an overload chain of a parent class;
+                           instead, hide the parent's overloads in this case */
+                        if (!chain->scope.is(rec->scope)) {
+                            chain = nullptr;
+                        }
+                    } else {
+                        chain = nullptr;
+                    }
+                }
+            }
+            // Don't trigger for things like the default __init__, which are wrapper_descriptors
+            // that we are intentionally replacing
+            else if (!rec->sibling.is_none() && rec->name[0] != '_') {
+                pybind11_fail("Cannot overload existing non-function object \""
+                              + std::string(rec->name) + "\" with a function of the same name");
             }
-            // Don't trigger for things like the default __init__, which are wrapper_descriptors that we are intentionally replacing
-            else if (!rec->sibling.is_none() && rec->name[0] != '_')
-                pybind11_fail("Cannot overload existing non-function object \"" + std::string(rec->name) +
-                        "\" with a function of the same name");
         }
 
         if (!chain) {
             /* No existing overload was found, create a new function object */
             rec->def = new PyMethodDef();
             std::memset(rec->def, 0, sizeof(PyMethodDef));
             rec->def->ml_name = rec->name;
-            rec->def->ml_meth = reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) (void)>(*dispatcher));
+            rec->def->ml_meth
+                = reinterpret_cast<PyCFunction>(reinterpret_cast<void (*)()>(dispatcher));
             rec->def->ml_flags = METH_VARARGS | METH_KEYWORDS;
 
-            capsule rec_capsule(rec, [](void *ptr) {
-                destruct((detail::function_record *) ptr);
-            });
+            capsule rec_capsule(unique_rec.release(),
+                                [](void *ptr) { destruct((detail::function_record *) ptr); });
+            rec_capsule.set_name(detail::get_function_record_capsule_name());
+            guarded_strdup.release();
 
             object scope_module;
             if (rec->scope) {
                 if (hasattr(rec->scope, "__module__")) {
                     scope_module = rec->scope.attr("__module__");
                 } else if (hasattr(rec->scope, "__name__")) {
                     scope_module = rec->scope.attr("__name__");
                 }
             }
 
             m_ptr = PyCFunction_NewEx(rec->def, rec_capsule.ptr(), scope_module.ptr());
-            if (!m_ptr)
+            if (!m_ptr) {
                 pybind11_fail("cpp_function::cpp_function(): Could not allocate function object");
+            }
         } else {
-            /* Append at the end of the overload chain */
+            /* Append at the beginning or end of the overload chain */
             m_ptr = rec->sibling.ptr();
             inc_ref();
-            chain_start = chain;
-            if (chain->is_method != rec->is_method)
-                pybind11_fail("overloading a method with both static and instance methods is not supported; "
-                    #if defined(NDEBUG)
-                        "compile in debug mode for more details"
-                    #else
-                        "error while attempting to bind " + std::string(rec->is_method ? "instance" : "static") + " method " +
-                        std::string(pybind11::str(rec->scope.attr("__name__"))) + "." + std::string(rec->name) + signature
-                    #endif
+            if (chain->is_method != rec->is_method) {
+                pybind11_fail(
+                    "overloading a method with both static and instance methods is not supported; "
+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)
+                    "#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for more "
+                    "details"
+#else
+                    "error while attempting to bind "
+                    + std::string(rec->is_method ? "instance" : "static") + " method "
+                    + std::string(pybind11::str(rec->scope.attr("__name__"))) + "."
+                    + std::string(rec->name) + signature
+#endif
                 );
-            while (chain->next)
-                chain = chain->next;
-            chain->next = rec;
+            }
+
+            if (rec->prepend) {
+                // Beginning of chain; we need to replace the capsule's current head-of-the-chain
+                // pointer with this one, then make this one point to the previous head of the
+                // chain.
+                chain_start = rec;
+                rec->next = chain;
+                auto rec_capsule
+                    = reinterpret_borrow<capsule>(((PyCFunctionObject *) m_ptr)->m_self);
+                rec_capsule.set_pointer(unique_rec.release());
+                guarded_strdup.release();
+            } else {
+                // Or end of chain (normal behavior)
+                chain_start = chain;
+                while (chain->next) {
+                    chain = chain->next;
+                }
+                chain->next = unique_rec.release();
+                guarded_strdup.release();
+            }
         }
 
         std::string signatures;
         int index = 0;
         /* Create a nice pydoc rec including all signatures and
            docstrings of the functions in the overload chain */
         if (chain && options::show_function_signatures()) {
             // First a generic signature
             signatures += rec->name;
             signatures += "(*args, **kwargs)\n";
             signatures += "Overloaded function.\n\n";
         }
         // Then specific overload signatures
         bool first_user_def = true;
-        for (auto it = chain_start; it != nullptr; it = it->next) {
+        for (auto *it = chain_start; it != nullptr; it = it->next) {
             if (options::show_function_signatures()) {
-                if (index > 0) signatures += "\n";
-                if (chain)
+                if (index > 0) {
+                    signatures += '\n';
+                }
+                if (chain) {
                     signatures += std::to_string(++index) + ". ";
+                }
                 signatures += rec->name;
                 signatures += it->signature;
-                signatures += "\n";
+                signatures += '\n';
             }
-            if (it->doc && strlen(it->doc) > 0 && options::show_user_defined_docstrings()) {
-                // If we're appending another docstring, and aren't printing function signatures, we
-                // need to append a newline first:
+            if (it->doc && it->doc[0] != '\0' && options::show_user_defined_docstrings()) {
+                // If we're appending another docstring, and aren't printing function signatures,
+                // we need to append a newline first:
                 if (!options::show_function_signatures()) {
-                    if (first_user_def) first_user_def = false;
-                    else signatures += "\n";
+                    if (first_user_def) {
+                        first_user_def = false;
+                    } else {
+                        signatures += '\n';
+                    }
+                }
+                if (options::show_function_signatures()) {
+                    signatures += '\n';
                 }
-                if (options::show_function_signatures()) signatures += "\n";
                 signatures += it->doc;
-                if (options::show_function_signatures()) signatures += "\n";
+                if (options::show_function_signatures()) {
+                    signatures += '\n';
+                }
             }
         }
 
         /* Install docstring */
-        PyCFunctionObject *func = (PyCFunctionObject *) m_ptr;
-        if (func->m_ml->ml_doc)
-            std::free(const_cast<char *>(func->m_ml->ml_doc));
-        func->m_ml->ml_doc = strdup(signatures.c_str());
+        auto *func = (PyCFunctionObject *) m_ptr;
+        std::free(const_cast<char *>(func->m_ml->ml_doc));
+        // Install docstring if it's non-empty (when at least one option is enabled)
+        func->m_ml->ml_doc
+            = signatures.empty() ? nullptr : PYBIND11_COMPAT_STRDUP(signatures.c_str());
 
         if (rec->is_method) {
             m_ptr = PYBIND11_INSTANCE_METHOD_NEW(m_ptr, rec->scope.ptr());
-            if (!m_ptr)
-                pybind11_fail("cpp_function::cpp_function(): Could not allocate instance method object");
+            if (!m_ptr) {
+                pybind11_fail(
+                    "cpp_function::cpp_function(): Could not allocate instance method object");
+            }
             Py_DECREF(func);
         }
     }
 
     /// When a cpp_function is GCed, release any memory allocated by pybind11
-    static void destruct(detail::function_record *rec) {
+    static void destruct(detail::function_record *rec, bool free_strings = true) {
+// If on Python 3.9, check the interpreter "MICRO" (patch) version.
+// If this is running on 3.9.0, we have to work around a bug.
+#if !defined(PYPY_VERSION) && PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION == 9
+        static bool is_zero = Py_GetVersion()[4] == '0';
+#endif
+
         while (rec) {
             detail::function_record *next = rec->next;
-            if (rec->free_data)
+            if (rec->free_data) {
                 rec->free_data(rec);
-            std::free((char *) rec->name);
-            std::free((char *) rec->doc);
-            std::free((char *) rec->signature);
-            for (auto &arg: rec->args) {
-                std::free(const_cast<char *>(arg.name));
-                std::free(const_cast<char *>(arg.descr));
+            }
+            // During initialization, these strings might not have been copied yet,
+            // so they cannot be freed. Once the function has been created, they can.
+            // Check `make_function_record` for more details.
+            if (free_strings) {
+                std::free((char *) rec->name);
+                std::free((char *) rec->doc);
+                std::free((char *) rec->signature);
+                for (auto &arg : rec->args) {
+                    std::free(const_cast<char *>(arg.name));
+                    std::free(const_cast<char *>(arg.descr));
+                }
+            }
+            for (auto &arg : rec->args) {
                 arg.value.dec_ref();
             }
             if (rec->def) {
                 std::free(const_cast<char *>(rec->def->ml_doc));
+// Python 3.9.0 decref's these in the wrong order; rec->def
+// If loaded on 3.9.0, let these leak (use Python 3.9.1 at runtime to fix)
+// See https://github.com/python/cpython/pull/22670
+#if !defined(PYPY_VERSION) && PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION == 9
+                if (!is_zero) {
+                    delete rec->def;
+                }
+#else
                 delete rec->def;
+#endif
             }
             delete rec;
             rec = next;
         }
     }
 
     /// Main dispatch logic for calls to functions bound using pybind11
     static PyObject *dispatcher(PyObject *self, PyObject *args_in, PyObject *kwargs_in) {
         using namespace detail;
+        assert(isinstance<capsule>(self));
 
         /* Iterator over the list of potentially admissible overloads */
-        const function_record *overloads = (function_record *) PyCapsule_GetPointer(self, nullptr),
+        const function_record *overloads = reinterpret_cast<function_record *>(
+                                  PyCapsule_GetPointer(self, get_function_record_capsule_name())),
                               *it = overloads;
+        assert(overloads != nullptr);
 
-        /* Need to know how many arguments + keyword arguments there are to pick the right overload */
-        const size_t n_args_in = (size_t) PyTuple_GET_SIZE(args_in);
+        /* Need to know how many arguments + keyword arguments there are to pick the right
+           overload */
+        const auto n_args_in = (size_t) PyTuple_GET_SIZE(args_in);
 
         handle parent = n_args_in > 0 ? PyTuple_GET_ITEM(args_in, 0) : nullptr,
                result = PYBIND11_TRY_NEXT_OVERLOAD;
 
         auto self_value_and_holder = value_and_holder();
         if (overloads->is_constructor) {
-            const auto tinfo = get_type_info((PyTypeObject *) overloads->scope.ptr());
-            const auto pi = reinterpret_cast<instance *>(parent.ptr());
-            self_value_and_holder = pi->get_value_and_holder(tinfo, false);
-
-            if (!self_value_and_holder.type || !self_value_and_holder.inst) {
-                PyErr_SetString(PyExc_TypeError, "__init__(self, ...) called with invalid `self` argument");
+            if (!parent
+                || !PyObject_TypeCheck(parent.ptr(), (PyTypeObject *) overloads->scope.ptr())) {
+                PyErr_SetString(
+                    PyExc_TypeError,
+                    "__init__(self, ...) called with invalid or missing `self` argument");
                 return nullptr;
             }
 
+            auto *const tinfo = get_type_info((PyTypeObject *) overloads->scope.ptr());
+            auto *const pi = reinterpret_cast<instance *>(parent.ptr());
+            self_value_and_holder = pi->get_value_and_holder(tinfo, true);
+
             // If this value is already registered it must mean __init__ is invoked multiple times;
             // we really can't support that in C++, so just ignore the second __init__.
-            if (self_value_and_holder.instance_registered())
+            if (self_value_and_holder.instance_registered()) {
                 return none().release().ptr();
+            }
         }
 
         try {
             // We do this in two passes: in the first pass, we load arguments with `convert=false`;
             // in the second, we allow conversion (except for arguments with an explicit
             // py::arg().noconvert()).  This lets us prefer calls without conversion, with
             // conversion as a fallback.
@@ -471,156 +716,217 @@
 
             for (; it != nullptr; it = it->next) {
 
                 /* For each overload:
                    1. Copy all positional arguments we were given, also checking to make sure that
                       named positional arguments weren't *also* specified via kwarg.
                    2. If we weren't given enough, try to make up the omitted ones by checking
-                      whether they were provided by a kwarg matching the `py::arg("name")` name.  If
-                      so, use it (and remove it from kwargs; if not, see if the function binding
+                      whether they were provided by a kwarg matching the `py::arg("name")` name. If
+                      so, use it (and remove it from kwargs); if not, see if the function binding
                       provided a default that we can use.
-                   3. Ensure that either all keyword arguments were "consumed", or that the function
-                      takes a kwargs argument to accept unconsumed kwargs.
+                   3. Ensure that either all keyword arguments were "consumed", or that the
+                   function takes a kwargs argument to accept unconsumed kwargs.
                    4. Any positional arguments still left get put into a tuple (for args), and any
                       leftover kwargs get put into a dict.
                    5. Pack everything into a vector; if we have py::args or py::kwargs, they are an
                       extra tuple or dict at the end of the positional arguments.
                    6. Call the function call dispatcher (function_record::impl)
 
-                   If one of these fail, move on to the next overload and keep trying until we get a
-                   result other than PYBIND11_TRY_NEXT_OVERLOAD.
+                   If one of these fail, move on to the next overload and keep trying until we get
+                   a result other than PYBIND11_TRY_NEXT_OVERLOAD.
                  */
 
                 const function_record &func = *it;
-                size_t num_args = func.nargs;    // Number of positional arguments that we need
-                if (func.has_args) --num_args;   // (but don't count py::args
-                if (func.has_kwargs) --num_args; //  or py::kwargs)
-                size_t pos_args = num_args - func.nargs_kwonly;
+                size_t num_args = func.nargs; // Number of positional arguments that we need
+                if (func.has_args) {
+                    --num_args; // (but don't count py::args
+                }
+                if (func.has_kwargs) {
+                    --num_args; //  or py::kwargs)
+                }
+                size_t pos_args = func.nargs_pos;
 
-                if (!func.has_args && n_args_in > pos_args)
+                if (!func.has_args && n_args_in > pos_args) {
                     continue; // Too many positional arguments for this overload
+                }
 
-                if (n_args_in < pos_args && func.args.size() < pos_args)
-                    continue; // Not enough positional arguments given, and not enough defaults to fill in the blanks
+                if (n_args_in < pos_args && func.args.size() < pos_args) {
+                    continue; // Not enough positional arguments given, and not enough defaults to
+                              // fill in the blanks
+                }
 
                 function_call call(func, parent);
 
-                size_t args_to_copy = (std::min)(pos_args, n_args_in); // Protect std::min with parentheses
+                // Protect std::min with parentheses
+                size_t args_to_copy = (std::min)(pos_args, n_args_in);
                 size_t args_copied = 0;
 
                 // 0. Inject new-style `self` argument
                 if (func.is_new_style_constructor) {
                     // The `value` may have been preallocated by an old-style `__init__`
                     // if it was a preceding candidate for overload resolution.
-                    if (self_value_and_holder)
+                    if (self_value_and_holder) {
                         self_value_and_holder.type->dealloc(self_value_and_holder);
+                    }
 
                     call.init_self = PyTuple_GET_ITEM(args_in, 0);
-                    call.args.push_back(reinterpret_cast<PyObject *>(&self_value_and_holder));
+                    call.args.emplace_back(reinterpret_cast<PyObject *>(&self_value_and_holder));
                     call.args_convert.push_back(false);
                     ++args_copied;
                 }
 
                 // 1. Copy any position arguments given.
                 bool bad_arg = false;
                 for (; args_copied < args_to_copy; ++args_copied) {
-                    const argument_record *arg_rec = args_copied < func.args.size() ? &func.args[args_copied] : nullptr;
-                    if (kwargs_in && arg_rec && arg_rec->name && PyDict_GetItemString(kwargs_in, arg_rec->name)) {
+                    const argument_record *arg_rec
+                        = args_copied < func.args.size() ? &func.args[args_copied] : nullptr;
+                    if (kwargs_in && arg_rec && arg_rec->name
+                        && dict_getitemstring(kwargs_in, arg_rec->name)) {
                         bad_arg = true;
                         break;
                     }
 
                     handle arg(PyTuple_GET_ITEM(args_in, args_copied));
                     if (arg_rec && !arg_rec->none && arg.is_none()) {
                         bad_arg = true;
                         break;
                     }
                     call.args.push_back(arg);
                     call.args_convert.push_back(arg_rec ? arg_rec->convert : true);
                 }
-                if (bad_arg)
+                if (bad_arg) {
                     continue; // Maybe it was meant for another overload (issue #688)
+                }
+
+                // Keep track of how many position args we copied out in case we need to come back
+                // to copy the rest into a py::args argument.
+                size_t positional_args_copied = args_copied;
 
                 // We'll need to copy this if we steal some kwargs for defaults
                 dict kwargs = reinterpret_borrow<dict>(kwargs_in);
 
+                // 1.5. Fill in any missing pos_only args from defaults if they exist
+                if (args_copied < func.nargs_pos_only) {
+                    for (; args_copied < func.nargs_pos_only; ++args_copied) {
+                        const auto &arg_rec = func.args[args_copied];
+                        handle value;
+
+                        if (arg_rec.value) {
+                            value = arg_rec.value;
+                        }
+                        if (value) {
+                            call.args.push_back(value);
+                            call.args_convert.push_back(arg_rec.convert);
+                        } else {
+                            break;
+                        }
+                    }
+
+                    if (args_copied < func.nargs_pos_only) {
+                        continue; // Not enough defaults to fill the positional arguments
+                    }
+                }
+
                 // 2. Check kwargs and, failing that, defaults that may help complete the list
                 if (args_copied < num_args) {
                     bool copied_kwargs = false;
 
                     for (; args_copied < num_args; ++args_copied) {
-                        const auto &arg = func.args[args_copied];
+                        const auto &arg_rec = func.args[args_copied];
 
                         handle value;
-                        if (kwargs_in && arg.name)
-                            value = PyDict_GetItemString(kwargs.ptr(), arg.name);
+                        if (kwargs_in && arg_rec.name) {
+                            value = dict_getitemstring(kwargs.ptr(), arg_rec.name);
+                        }
 
                         if (value) {
                             // Consume a kwargs value
                             if (!copied_kwargs) {
                                 kwargs = reinterpret_steal<dict>(PyDict_Copy(kwargs.ptr()));
                                 copied_kwargs = true;
                             }
-                            PyDict_DelItemString(kwargs.ptr(), arg.name);
-                        } else if (arg.value) {
-                            value = arg.value;
+                            if (PyDict_DelItemString(kwargs.ptr(), arg_rec.name) == -1) {
+                                throw error_already_set();
+                            }
+                        } else if (arg_rec.value) {
+                            value = arg_rec.value;
+                        }
+
+                        if (!arg_rec.none && value.is_none()) {
+                            break;
                         }
 
                         if (value) {
+                            // If we're at the py::args index then first insert a stub for it to be
+                            // replaced later
+                            if (func.has_args && call.args.size() == func.nargs_pos) {
+                                call.args.push_back(none());
+                            }
+
                             call.args.push_back(value);
-                            call.args_convert.push_back(arg.convert);
-                        }
-                        else
+                            call.args_convert.push_back(arg_rec.convert);
+                        } else {
                             break;
+                        }
                     }
 
-                    if (args_copied < num_args)
-                        continue; // Not enough arguments, defaults, or kwargs to fill the positional arguments
+                    if (args_copied < num_args) {
+                        continue; // Not enough arguments, defaults, or kwargs to fill the
+                                  // positional arguments
+                    }
                 }
 
                 // 3. Check everything was consumed (unless we have a kwargs arg)
-                if (kwargs && kwargs.size() > 0 && !func.has_kwargs)
+                if (kwargs && !kwargs.empty() && !func.has_kwargs) {
                     continue; // Unconsumed kwargs, but no py::kwargs argument to accept them
+                }
 
                 // 4a. If we have a py::args argument, create a new tuple with leftovers
                 if (func.has_args) {
                     tuple extra_args;
                     if (args_to_copy == 0) {
                         // We didn't copy out any position arguments from the args_in tuple, so we
                         // can reuse it directly without copying:
                         extra_args = reinterpret_borrow<tuple>(args_in);
-                    } else if (args_copied >= n_args_in) {
+                    } else if (positional_args_copied >= n_args_in) {
                         extra_args = tuple(0);
                     } else {
-                        size_t args_size = n_args_in - args_copied;
+                        size_t args_size = n_args_in - positional_args_copied;
                         extra_args = tuple(args_size);
                         for (size_t i = 0; i < args_size; ++i) {
-                            extra_args[i] = PyTuple_GET_ITEM(args_in, args_copied + i);
+                            extra_args[i] = PyTuple_GET_ITEM(args_in, positional_args_copied + i);
                         }
                     }
-                    call.args.push_back(extra_args);
+                    if (call.args.size() <= func.nargs_pos) {
+                        call.args.push_back(extra_args);
+                    } else {
+                        call.args[func.nargs_pos] = extra_args;
+                    }
                     call.args_convert.push_back(false);
                     call.args_ref = std::move(extra_args);
                 }
 
                 // 4b. If we have a py::kwargs, pass on any remaining kwargs
                 if (func.has_kwargs) {
-                    if (!kwargs.ptr())
+                    if (!kwargs.ptr()) {
                         kwargs = dict(); // If we didn't get one, send an empty one
+                    }
                     call.args.push_back(kwargs);
                     call.args_convert.push_back(false);
                     call.kwargs_ref = std::move(kwargs);
                 }
 
-                // 5. Put everything in a vector.  Not technically step 5, we've been building it
-                // in `call.args` all along.
-                #if !defined(NDEBUG)
-                if (call.args.size() != func.nargs || call.args_convert.size() != func.nargs)
-                    pybind11_fail("Internal error: function call dispatcher inserted wrong number of arguments!");
-                #endif
+// 5. Put everything in a vector.  Not technically step 5, we've been building it
+// in `call.args` all along.
+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)
+                if (call.args.size() != func.nargs || call.args_convert.size() != func.nargs) {
+                    pybind11_fail("Internal error: function call dispatcher inserted wrong number "
+                                  "of arguments!");
+                }
+#endif
 
                 std::vector<bool> second_pass_convert;
                 if (overloaded) {
                     // We're in the first no-convert pass, so swap out the conversion flags for a
                     // set of all-false flags.  If the call fails, we'll swap the flags back in for
                     // the conversion-allowed call below.
                     second_pass_convert.resize(func.nargs, false);
@@ -631,16 +937,17 @@
                 try {
                     loader_life_support guard{};
                     result = func.impl(call);
                 } catch (reference_cast_error &) {
                     result = PYBIND11_TRY_NEXT_OVERLOAD;
                 }
 
-                if (result.ptr() != PYBIND11_TRY_NEXT_OVERLOAD)
+                if (result.ptr() != PYBIND11_TRY_NEXT_OVERLOAD) {
                     break;
+                }
 
                 if (overloaded) {
                     // The (overloaded) call failed; if the call has at least one argument that
                     // permits conversion (i.e. it hasn't been explicitly specified `.noconvert()`)
                     // then add this call to the list of second pass overloads to try.
                     for (size_t i = func.is_method ? 1 : 0; i < pos_args; i++) {
                         if (second_pass_convert[i]) {
@@ -651,265 +958,359 @@
                             break;
                         }
                     }
                 }
             }
 
             if (overloaded && !second_pass.empty() && result.ptr() == PYBIND11_TRY_NEXT_OVERLOAD) {
-                // The no-conversion pass finished without success, try again with conversion allowed
+                // The no-conversion pass finished without success, try again with conversion
+                // allowed
                 for (auto &call : second_pass) {
                     try {
                         loader_life_support guard{};
                         result = call.func.impl(call);
                     } catch (reference_cast_error &) {
                         result = PYBIND11_TRY_NEXT_OVERLOAD;
                     }
 
                     if (result.ptr() != PYBIND11_TRY_NEXT_OVERLOAD) {
                         // The error reporting logic below expects 'it' to be valid, as it would be
                         // if we'd encountered this failure in the first-pass loop.
-                        if (!result)
+                        if (!result) {
                             it = &call.func;
+                        }
                         break;
                     }
                 }
             }
         } catch (error_already_set &e) {
             e.restore();
             return nullptr;
-#if defined(__GNUG__) && !defined(__clang__)
-        } catch ( abi::__forced_unwind& ) {
+#ifdef __GLIBCXX__
+        } catch (abi::__forced_unwind &) {
             throw;
 #endif
         } catch (...) {
             /* When an exception is caught, give each registered exception
-               translator a chance to translate it to a Python exception
-               in reverse order of registration.
+               translator a chance to translate it to a Python exception. First
+               all module-local translators will be tried in reverse order of
+               registration. If none of the module-locale translators handle
+               the exception (or there are no module-locale translators) then
+               the global translators will be tried, also in reverse order of
+               registration.
 
                A translator may choose to do one of the following:
 
                 - catch the exception and call PyErr_SetString or PyErr_SetObject
                   to set a standard (or custom) Python exception, or
                 - do nothing and let the exception fall through to the next translator, or
-                - delegate translation to the next translator by throwing a new type of exception. */
+                - delegate translation to the next translator by throwing a new type of exception.
+             */
 
-            auto last_exception = std::current_exception();
-            auto &registered_exception_translators = get_internals().registered_exception_translators;
-            for (auto& translator : registered_exception_translators) {
-                try {
-                    translator(last_exception);
-                } catch (...) {
-                    last_exception = std::current_exception();
-                    continue;
-                }
+            auto &local_exception_translators
+                = get_local_internals().registered_exception_translators;
+            if (detail::apply_exception_translators(local_exception_translators)) {
+                return nullptr;
+            }
+            auto &exception_translators = get_internals().registered_exception_translators;
+            if (detail::apply_exception_translators(exception_translators)) {
                 return nullptr;
             }
-            PyErr_SetString(PyExc_SystemError, "Exception escaped from default exception translator!");
+
+            PyErr_SetString(PyExc_SystemError,
+                            "Exception escaped from default exception translator!");
             return nullptr;
         }
 
         auto append_note_if_missing_header_is_suspected = [](std::string &msg) {
             if (msg.find("std::") != std::string::npos) {
                 msg += "\n\n"
                        "Did you forget to `#include <pybind11/stl.h>`? Or <pybind11/complex.h>,\n"
                        "<pybind11/functional.h>, <pybind11/chrono.h>, etc. Some automatic\n"
                        "conversions are optional and require extra headers to be included\n"
                        "when compiling your pybind11 module.";
             }
         };
 
         if (result.ptr() == PYBIND11_TRY_NEXT_OVERLOAD) {
-            if (overloads->is_operator)
+            if (overloads->is_operator) {
                 return handle(Py_NotImplemented).inc_ref().ptr();
+            }
 
-            std::string msg = std::string(overloads->name) + "(): incompatible " +
-                std::string(overloads->is_constructor ? "constructor" : "function") +
-                " arguments. The following argument types are supported:\n";
+            std::string msg = std::string(overloads->name) + "(): incompatible "
+                              + std::string(overloads->is_constructor ? "constructor" : "function")
+                              + " arguments. The following argument types are supported:\n";
 
             int ctr = 0;
             for (const function_record *it2 = overloads; it2 != nullptr; it2 = it2->next) {
-                msg += "    "+ std::to_string(++ctr) + ". ";
+                msg += "    " + std::to_string(++ctr) + ". ";
 
                 bool wrote_sig = false;
                 if (overloads->is_constructor) {
-                    // For a constructor, rewrite `(self: Object, arg0, ...) -> NoneType` as `Object(arg0, ...)`
+                    // For a constructor, rewrite `(self: Object, arg0, ...) -> NoneType` as
+                    // `Object(arg0, ...)`
                     std::string sig = it2->signature;
                     size_t start = sig.find('(') + 7; // skip "(self: "
                     if (start < sig.size()) {
                         // End at the , for the next argument
                         size_t end = sig.find(", "), next = end + 2;
                         size_t ret = sig.rfind(" -> ");
                         // Or the ), if there is no comma:
-                        if (end >= sig.size()) next = end = sig.find(')');
+                        if (end >= sig.size()) {
+                            next = end = sig.find(')');
+                        }
                         if (start < end && next < sig.size()) {
                             msg.append(sig, start, end - start);
                             msg += '(';
                             msg.append(sig, next, ret - next);
                             wrote_sig = true;
                         }
                     }
                 }
-                if (!wrote_sig) msg += it2->signature;
+                if (!wrote_sig) {
+                    msg += it2->signature;
+                }
 
-                msg += "\n";
+                msg += '\n';
             }
             msg += "\nInvoked with: ";
             auto args_ = reinterpret_borrow<tuple>(args_in);
             bool some_args = false;
             for (size_t ti = overloads->is_constructor ? 1 : 0; ti < args_.size(); ++ti) {
-                if (!some_args) some_args = true;
-                else msg += ", ";
-                msg += pybind11::repr(args_[ti]);
+                if (!some_args) {
+                    some_args = true;
+                } else {
+                    msg += ", ";
+                }
+                try {
+                    msg += pybind11::repr(args_[ti]);
+                } catch (const error_already_set &) {
+                    msg += "<repr raised Error>";
+                }
             }
             if (kwargs_in) {
                 auto kwargs = reinterpret_borrow<dict>(kwargs_in);
-                if (kwargs.size() > 0) {
-                    if (some_args) msg += "; ";
+                if (!kwargs.empty()) {
+                    if (some_args) {
+                        msg += "; ";
+                    }
                     msg += "kwargs: ";
                     bool first = true;
                     for (auto kwarg : kwargs) {
-                        if (first) first = false;
-                        else msg += ", ";
-                        msg += pybind11::str("{}={!r}").format(kwarg.first, kwarg.second);
+                        if (first) {
+                            first = false;
+                        } else {
+                            msg += ", ";
+                        }
+                        msg += pybind11::str("{}=").format(kwarg.first);
+                        try {
+                            msg += pybind11::repr(kwarg.second);
+                        } catch (const error_already_set &) {
+                            msg += "<repr raised Error>";
+                        }
                     }
                 }
             }
 
             append_note_if_missing_header_is_suspected(msg);
+            // Attach additional error info to the exception if supported
+            if (PyErr_Occurred()) {
+                // #HelpAppreciated: unit test coverage for this branch.
+                raise_from(PyExc_TypeError, msg.c_str());
+                return nullptr;
+            }
             PyErr_SetString(PyExc_TypeError, msg.c_str());
             return nullptr;
-        } else if (!result) {
+        }
+        if (!result) {
             std::string msg = "Unable to convert function return value to a "
                               "Python type! The signature was\n\t";
             msg += it->signature;
             append_note_if_missing_header_is_suspected(msg);
+            // Attach additional error info to the exception if supported
+            if (PyErr_Occurred()) {
+                raise_from(PyExc_TypeError, msg.c_str());
+                return nullptr;
+            }
             PyErr_SetString(PyExc_TypeError, msg.c_str());
             return nullptr;
-        } else {
-            if (overloads->is_constructor && !self_value_and_holder.holder_constructed()) {
-                auto *pi = reinterpret_cast<instance *>(parent.ptr());
-                self_value_and_holder.type->init_instance(pi, nullptr);
-            }
-            return result.ptr();
         }
+        if (overloads->is_constructor && !self_value_and_holder.holder_constructed()) {
+            auto *pi = reinterpret_cast<instance *>(parent.ptr());
+            self_value_and_holder.type->init_instance(pi, nullptr);
+        }
+        return result.ptr();
     }
 };
 
 /// Wrapper for Python extension modules
-class module : public object {
+class module_ : public object {
 public:
-    PYBIND11_OBJECT_DEFAULT(module, object, PyModule_Check)
+    PYBIND11_OBJECT_DEFAULT(module_, object, PyModule_Check)
 
     /// Create a new top-level Python module with the given name and docstring
-    explicit module(const char *name, const char *doc = nullptr) {
-        if (!options::show_user_defined_docstrings()) doc = nullptr;
-#if PY_MAJOR_VERSION >= 3
-        PyModuleDef *def = new PyModuleDef();
-        std::memset(def, 0, sizeof(PyModuleDef));
-        def->m_name = name;
-        def->m_doc = doc;
-        def->m_size = -1;
-        Py_INCREF(def);
-        m_ptr = PyModule_Create(def);
-#else
-        m_ptr = Py_InitModule3(name, nullptr, doc);
-#endif
-        if (m_ptr == nullptr)
-            pybind11_fail("Internal error in module::module()");
-        inc_ref();
+    PYBIND11_DEPRECATED("Use PYBIND11_MODULE or module_::create_extension_module instead")
+    explicit module_(const char *name, const char *doc = nullptr) {
+        *this = create_extension_module(name, doc, new PyModuleDef());
     }
 
     /** \rst
         Create Python binding for a new function within the module scope. ``Func``
         can be a plain C++ function, a function pointer, or a lambda function. For
         details on the ``Extra&& ... extra`` argument, see section :ref:`extras`.
     \endrst */
     template <typename Func, typename... Extra>
-    module &def(const char *name_, Func &&f, const Extra& ... extra) {
-        cpp_function func(std::forward<Func>(f), name(name_), scope(*this),
-                          sibling(getattr(*this, name_, none())), extra...);
+    module_ &def(const char *name_, Func &&f, const Extra &...extra) {
+        cpp_function func(std::forward<Func>(f),
+                          name(name_),
+                          scope(*this),
+                          sibling(getattr(*this, name_, none())),
+                          extra...);
         // NB: allow overwriting here because cpp_function sets up a chain with the intention of
-        // overwriting (and has already checked internally that it isn't overwriting non-functions).
+        // overwriting (and has already checked internally that it isn't overwriting
+        // non-functions).
         add_object(name_, func, true /* overwrite */);
         return *this;
     }
 
     /** \rst
         Create and return a new Python submodule with the given name and docstring.
         This also works recursively, i.e.
 
         .. code-block:: cpp
 
-            py::module m("example", "pybind11 example plugin");
-            py::module m2 = m.def_submodule("sub", "A submodule of 'example'");
-            py::module m3 = m2.def_submodule("subsub", "A submodule of 'example.sub'");
+            py::module_ m("example", "pybind11 example plugin");
+            py::module_ m2 = m.def_submodule("sub", "A submodule of 'example'");
+            py::module_ m3 = m2.def_submodule("subsub", "A submodule of 'example.sub'");
     \endrst */
-    module def_submodule(const char *name, const char *doc = nullptr) {
-        std::string full_name = std::string(PyModule_GetName(m_ptr))
-            + std::string(".") + std::string(name);
-        auto result = reinterpret_borrow<module>(PyImport_AddModule(full_name.c_str()));
-        if (doc && options::show_user_defined_docstrings())
+    module_ def_submodule(const char *name, const char *doc = nullptr) {
+        const char *this_name = PyModule_GetName(m_ptr);
+        if (this_name == nullptr) {
+            throw error_already_set();
+        }
+        std::string full_name = std::string(this_name) + '.' + name;
+        handle submodule = PyImport_AddModule(full_name.c_str());
+        if (!submodule) {
+            throw error_already_set();
+        }
+        auto result = reinterpret_borrow<module_>(submodule);
+        if (doc && options::show_user_defined_docstrings()) {
             result.attr("__doc__") = pybind11::str(doc);
+        }
         attr(name) = result;
         return result;
     }
 
     /// Import and return a module or throws `error_already_set`.
-    static module import(const char *name) {
+    static module_ import(const char *name) {
         PyObject *obj = PyImport_ImportModule(name);
-        if (!obj)
+        if (!obj) {
             throw error_already_set();
-        return reinterpret_steal<module>(obj);
+        }
+        return reinterpret_steal<module_>(obj);
     }
 
     /// Reload the module or throws `error_already_set`.
     void reload() {
         PyObject *obj = PyImport_ReloadModule(ptr());
-        if (!obj)
+        if (!obj) {
             throw error_already_set();
-        *this = reinterpret_steal<module>(obj);
+        }
+        *this = reinterpret_steal<module_>(obj);
     }
 
-    // Adds an object to the module using the given name.  Throws if an object with the given name
-    // already exists.
-    //
-    // overwrite should almost always be false: attempting to overwrite objects that pybind11 has
-    // established will, in most cases, break things.
+    /** \rst
+        Adds an object to the module using the given name.  Throws if an object with the given name
+        already exists.
+
+        ``overwrite`` should almost always be false: attempting to overwrite objects that pybind11
+        has established will, in most cases, break things.
+    \endrst */
     PYBIND11_NOINLINE void add_object(const char *name, handle obj, bool overwrite = false) {
-        if (!overwrite && hasattr(*this, name))
-            pybind11_fail("Error during initialization: multiple incompatible definitions with name \"" +
-                    std::string(name) + "\"");
+        if (!overwrite && hasattr(*this, name)) {
+            pybind11_fail(
+                "Error during initialization: multiple incompatible definitions with name \""
+                + std::string(name) + "\"");
+        }
 
         PyModule_AddObject(ptr(), name, obj.inc_ref().ptr() /* steals a reference */);
     }
+
+    using module_def = PyModuleDef; // TODO: Can this be removed (it was needed only for Python 2)?
+
+    /** \rst
+        Create a new top-level module that can be used as the main module of a C extension.
+
+        ``def`` should point to a statically allocated module_def.
+    \endrst */
+    static module_ create_extension_module(const char *name, const char *doc, module_def *def) {
+        // module_def is PyModuleDef
+        // Placement new (not an allocation).
+        def = new (def)
+            PyModuleDef{/* m_base */ PyModuleDef_HEAD_INIT,
+                        /* m_name */ name,
+                        /* m_doc */ options::show_user_defined_docstrings() ? doc : nullptr,
+                        /* m_size */ -1,
+                        /* m_methods */ nullptr,
+                        /* m_slots */ nullptr,
+                        /* m_traverse */ nullptr,
+                        /* m_clear */ nullptr,
+                        /* m_free */ nullptr};
+        auto *m = PyModule_Create(def);
+        if (m == nullptr) {
+            if (PyErr_Occurred()) {
+                throw error_already_set();
+            }
+            pybind11_fail("Internal error in module_::create_extension_module()");
+        }
+        // TODO: Should be reinterpret_steal for Python 3, but Python also steals it again when
+        //       returned from PyInit_...
+        //       For Python 2, reinterpret_borrow was correct.
+        return reinterpret_borrow<module_>(m);
+    }
 };
 
+// When inside a namespace (or anywhere as long as it's not the first item on a line),
+// C++20 allows "module" to be used. This is provided for backward compatibility, and for
+// simplicity, if someone wants to use py::module for example, that is perfectly safe.
+using module = module_;
+
 /// \ingroup python_builtins
 /// Return a dictionary representing the global variables in the current execution frame,
 /// or ``__main__.__dict__`` if there is no frame (usually when the interpreter is embedded).
 inline dict globals() {
     PyObject *p = PyEval_GetGlobals();
-    return reinterpret_borrow<dict>(p ? p : module::import("__main__").attr("__dict__").ptr());
+    return reinterpret_borrow<dict>(p ? p : module_::import("__main__").attr("__dict__").ptr());
 }
 
-NAMESPACE_BEGIN(detail)
+template <typename... Args, typename = detail::enable_if_t<args_are_all_keyword_or_ds<Args...>()>>
+PYBIND11_DEPRECATED("make_simple_namespace should be replaced with "
+                    "py::module_::import(\"types\").attr(\"SimpleNamespace\") ")
+object make_simple_namespace(Args &&...args_) {
+    return module_::import("types").attr("SimpleNamespace")(std::forward<Args>(args_)...);
+}
+
+PYBIND11_NAMESPACE_BEGIN(detail)
 /// Generic support for creating new Python heap types
 class generic_type : public object {
-    template <typename...> friend class class_;
 public:
     PYBIND11_OBJECT_DEFAULT(generic_type, object, PyType_Check)
 protected:
     void initialize(const type_record &rec) {
-        if (rec.scope && hasattr(rec.scope, rec.name))
-            pybind11_fail("generic_type: cannot initialize type \"" + std::string(rec.name) +
-                          "\": an object with that name is already defined");
-
-        if (rec.module_local ? get_local_type_info(*rec.type) : get_global_type_info(*rec.type))
-            pybind11_fail("generic_type: type \"" + std::string(rec.name) +
-                          "\" is already registered!");
+        if (rec.scope && hasattr(rec.scope, "__dict__")
+            && rec.scope.attr("__dict__").contains(rec.name)) {
+            pybind11_fail("generic_type: cannot initialize type \"" + std::string(rec.name)
+                          + "\": an object with that name is already defined");
+        }
+
+        if ((rec.module_local ? get_local_type_info(*rec.type) : get_global_type_info(*rec.type))
+            != nullptr) {
+            pybind11_fail("generic_type: type \"" + std::string(rec.name)
+                          + "\" is already registered!");
+        }
 
         m_ptr = make_new_python_type(rec);
 
         /* Register supplemental type information in C++ dict */
         auto *tinfo = new detail::type_info();
         tinfo->type = (PyTypeObject *) m_ptr;
         tinfo->cpptype = rec.type;
@@ -923,178 +1324,216 @@
         tinfo->simple_ancestors = true;
         tinfo->default_holder = rec.default_holder;
         tinfo->module_local = rec.module_local;
 
         auto &internals = get_internals();
         auto tindex = std::type_index(*rec.type);
         tinfo->direct_conversions = &internals.direct_conversions[tindex];
-        if (rec.module_local)
-            registered_local_types_cpp()[tindex] = tinfo;
-        else
+        if (rec.module_local) {
+            get_local_internals().registered_types_cpp[tindex] = tinfo;
+        } else {
             internals.registered_types_cpp[tindex] = tinfo;
-        internals.registered_types_py[(PyTypeObject *) m_ptr] = { tinfo };
+        }
+        internals.registered_types_py[(PyTypeObject *) m_ptr] = {tinfo};
 
         if (rec.bases.size() > 1 || rec.multiple_inheritance) {
             mark_parents_nonsimple(tinfo->type);
             tinfo->simple_ancestors = false;
-        }
-        else if (rec.bases.size() == 1) {
-            auto parent_tinfo = get_type_info((PyTypeObject *) rec.bases[0].ptr());
-            tinfo->simple_ancestors = parent_tinfo->simple_ancestors;
+        } else if (rec.bases.size() == 1) {
+            auto *parent_tinfo = get_type_info((PyTypeObject *) rec.bases[0].ptr());
+            assert(parent_tinfo != nullptr);
+            bool parent_simple_ancestors = parent_tinfo->simple_ancestors;
+            tinfo->simple_ancestors = parent_simple_ancestors;
+            // The parent can no longer be a simple type if it has MI and has a child
+            parent_tinfo->simple_type = parent_tinfo->simple_type && parent_simple_ancestors;
         }
 
         if (rec.module_local) {
             // Stash the local typeinfo and loader so that external modules can access it.
             tinfo->module_local_load = &type_caster_generic::local_load;
             setattr(m_ptr, PYBIND11_MODULE_LOCAL_ID, capsule(tinfo));
         }
     }
 
     /// Helper function which tags all parents of a type using mult. inheritance
     void mark_parents_nonsimple(PyTypeObject *value) {
         auto t = reinterpret_borrow<tuple>(value->tp_bases);
         for (handle h : t) {
-            auto tinfo2 = get_type_info((PyTypeObject *) h.ptr());
-            if (tinfo2)
+            auto *tinfo2 = get_type_info((PyTypeObject *) h.ptr());
+            if (tinfo2) {
                 tinfo2->simple_type = false;
+            }
             mark_parents_nonsimple((PyTypeObject *) h.ptr());
         }
     }
 
-    void install_buffer_funcs(
-            buffer_info *(*get_buffer)(PyObject *, void *),
-            void *get_buffer_data) {
-        PyHeapTypeObject *type = (PyHeapTypeObject*) m_ptr;
-        auto tinfo = detail::get_type_info(&type->ht_type);
-
-        if (!type->ht_type.tp_as_buffer)
-            pybind11_fail(
-                "To be able to register buffer protocol support for the type '" +
-                std::string(tinfo->type->tp_name) +
-                "' the associated class<>(..) invocation must "
-                "include the pybind11::buffer_protocol() annotation!");
+    void install_buffer_funcs(buffer_info *(*get_buffer)(PyObject *, void *),
+                              void *get_buffer_data) {
+        auto *type = (PyHeapTypeObject *) m_ptr;
+        auto *tinfo = detail::get_type_info(&type->ht_type);
+
+        if (!type->ht_type.tp_as_buffer) {
+            pybind11_fail("To be able to register buffer protocol support for the type '"
+                          + get_fully_qualified_tp_name(tinfo->type)
+                          + "' the associated class<>(..) invocation must "
+                            "include the pybind11::buffer_protocol() annotation!");
+        }
 
         tinfo->get_buffer = get_buffer;
         tinfo->get_buffer_data = get_buffer_data;
     }
 
     // rec_func must be set for either fget or fset.
     void def_property_static_impl(const char *name,
-                                  handle fget, handle fset,
+                                  handle fget,
+                                  handle fset,
                                   detail::function_record *rec_func) {
-        const auto is_static = rec_func && !(rec_func->is_method && rec_func->scope);
-        const auto has_doc = rec_func && rec_func->doc && pybind11::options::show_user_defined_docstrings();
-        auto property = handle((PyObject *) (is_static ? get_internals().static_property_type
-                                                       : &PyProperty_Type));
+        const auto is_static = (rec_func != nullptr) && !(rec_func->is_method && rec_func->scope);
+        const auto has_doc = (rec_func != nullptr) && (rec_func->doc != nullptr)
+                             && pybind11::options::show_user_defined_docstrings();
+        auto property = handle(
+            (PyObject *) (is_static ? get_internals().static_property_type : &PyProperty_Type));
         attr(name) = property(fget.ptr() ? fget : none(),
                               fset.ptr() ? fset : none(),
-                              /*deleter*/none(),
+                              /*deleter*/ none(),
                               pybind11::str(has_doc ? rec_func->doc : ""));
     }
 };
 
 /// Set the pointer to operator new if it exists. The cast is needed because it can be overloaded.
-template <typename T, typename = void_t<decltype(static_cast<void *(*)(size_t)>(T::operator new))>>
-void set_operator_new(type_record *r) { r->operator_new = &T::operator new; }
-
-template <typename> void set_operator_new(...) { }
-
-template <typename T, typename SFINAE = void> struct has_operator_delete : std::false_type { };
-template <typename T> struct has_operator_delete<T, void_t<decltype(static_cast<void (*)(void *)>(T::operator delete))>>
-    : std::true_type { };
-template <typename T, typename SFINAE = void> struct has_operator_delete_size : std::false_type { };
-template <typename T> struct has_operator_delete_size<T, void_t<decltype(static_cast<void (*)(void *, size_t)>(T::operator delete))>>
-    : std::true_type { };
+template <typename T,
+          typename = void_t<decltype(static_cast<void *(*) (size_t)>(T::operator new))>>
+void set_operator_new(type_record *r) {
+    r->operator_new = &T::operator new;
+}
+
+template <typename>
+void set_operator_new(...) {}
+
+template <typename T, typename SFINAE = void>
+struct has_operator_delete : std::false_type {};
+template <typename T>
+struct has_operator_delete<T, void_t<decltype(static_cast<void (*)(void *)>(T::operator delete))>>
+    : std::true_type {};
+template <typename T, typename SFINAE = void>
+struct has_operator_delete_size : std::false_type {};
+template <typename T>
+struct has_operator_delete_size<
+    T,
+    void_t<decltype(static_cast<void (*)(void *, size_t)>(T::operator delete))>> : std::true_type {
+};
 /// Call class-specific delete if it exists or global otherwise. Can also be an overload set.
 template <typename T, enable_if_t<has_operator_delete<T>::value, int> = 0>
-void call_operator_delete(T *p, size_t, size_t) { T::operator delete(p); }
-template <typename T, enable_if_t<!has_operator_delete<T>::value && has_operator_delete_size<T>::value, int> = 0>
-void call_operator_delete(T *p, size_t s, size_t) { T::operator delete(p, s); }
+void call_operator_delete(T *p, size_t, size_t) {
+    T::operator delete(p);
+}
+template <typename T,
+          enable_if_t<!has_operator_delete<T>::value && has_operator_delete_size<T>::value, int>
+          = 0>
+void call_operator_delete(T *p, size_t s, size_t) {
+    T::operator delete(p, s);
+}
 
 inline void call_operator_delete(void *p, size_t s, size_t a) {
-    (void)s; (void)a;
-    #if defined(__cpp_aligned_new) && (!defined(_MSC_VER) || _MSC_VER >= 1912)
-        if (a > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
-            #ifdef __cpp_sized_deallocation
-                ::operator delete(p, s, std::align_val_t(a));
-            #else
-                ::operator delete(p, std::align_val_t(a));
-            #endif
-            return;
-        }
-    #endif
-    #ifdef __cpp_sized_deallocation
-        ::operator delete(p, s);
-    #else
-        ::operator delete(p);
-    #endif
+    (void) s;
+    (void) a;
+#if defined(__cpp_aligned_new) && (!defined(_MSC_VER) || _MSC_VER >= 1912)
+    if (a > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
+#    ifdef __cpp_sized_deallocation
+        ::operator delete(p, s, std::align_val_t(a));
+#    else
+        ::operator delete(p, std::align_val_t(a));
+#    endif
+        return;
+    }
+#endif
+#ifdef __cpp_sized_deallocation
+    ::operator delete(p, s);
+#else
+    ::operator delete(p);
+#endif
+}
+
+inline void add_class_method(object &cls, const char *name_, const cpp_function &cf) {
+    cls.attr(cf.name()) = cf;
+    if (std::strcmp(name_, "__eq__") == 0 && !cls.attr("__dict__").contains("__hash__")) {
+        cls.attr("__hash__") = none();
+    }
 }
 
-NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(detail)
 
 /// Given a pointer to a member function, cast it to its `Derived` version.
 /// Forward everything else unchanged.
 template <typename /*Derived*/, typename F>
-auto method_adaptor(F &&f) -> decltype(std::forward<F>(f)) { return std::forward<F>(f); }
+auto method_adaptor(F &&f) -> decltype(std::forward<F>(f)) {
+    return std::forward<F>(f);
+}
 
 template <typename Derived, typename Return, typename Class, typename... Args>
 auto method_adaptor(Return (Class::*pmf)(Args...)) -> Return (Derived::*)(Args...) {
-    static_assert(detail::is_accessible_base_of<Class, Derived>::value,
+    static_assert(
+        detail::is_accessible_base_of<Class, Derived>::value,
         "Cannot bind an inaccessible base class method; use a lambda definition instead");
     return pmf;
 }
 
 template <typename Derived, typename Return, typename Class, typename... Args>
 auto method_adaptor(Return (Class::*pmf)(Args...) const) -> Return (Derived::*)(Args...) const {
-    static_assert(detail::is_accessible_base_of<Class, Derived>::value,
+    static_assert(
+        detail::is_accessible_base_of<Class, Derived>::value,
         "Cannot bind an inaccessible base class method; use a lambda definition instead");
     return pmf;
 }
 
 template <typename type_, typename... options>
 class class_ : public detail::generic_type {
-    template <typename T> using is_holder = detail::is_holder_type<type_, T>;
-    template <typename T> using is_subtype = detail::is_strict_base_of<type_, T>;
-    template <typename T> using is_base = detail::is_strict_base_of<T, type_>;
+    template <typename T>
+    using is_holder = detail::is_holder_type<type_, T>;
+    template <typename T>
+    using is_subtype = detail::is_strict_base_of<type_, T>;
+    template <typename T>
+    using is_base = detail::is_strict_base_of<T, type_>;
     // struct instead of using here to help MSVC:
-    template <typename T> struct is_valid_class_option :
-        detail::any_of<is_holder<T>, is_subtype<T>, is_base<T>> {};
+    template <typename T>
+    struct is_valid_class_option : detail::any_of<is_holder<T>, is_subtype<T>, is_base<T>> {};
 
 public:
     using type = type_;
     using type_alias = detail::exactly_one_t<is_subtype, void, options...>;
     constexpr static bool has_alias = !std::is_void<type_alias>::value;
     using holder_type = detail::exactly_one_t<is_holder, std::unique_ptr<type>, options...>;
 
     static_assert(detail::all_of<is_valid_class_option<options>...>::value,
-            "Unknown/invalid class_ template parameters provided");
+                  "Unknown/invalid class_ template parameters provided");
 
     static_assert(!has_alias || std::is_polymorphic<type>::value,
-            "Cannot use an alias class with a non-polymorphic type");
+                  "Cannot use an alias class with a non-polymorphic type");
 
     PYBIND11_OBJECT(class_, generic_type, PyType_Check)
 
     template <typename... Extra>
-    class_(handle scope, const char *name, const Extra &... extra) {
+    class_(handle scope, const char *name, const Extra &...extra) {
         using namespace detail;
 
         // MI can only be specified via class_ template options, not constructor parameters
         static_assert(
             none_of<is_pyobject<Extra>...>::value || // no base class arguments, or:
-            (   constexpr_sum(is_pyobject<Extra>::value...) == 1 && // Exactly one base
-                constexpr_sum(is_base<options>::value...)   == 0 && // no template option bases
-                none_of<std::is_same<multiple_inheritance, Extra>...>::value), // no multiple_inheritance attr
+                (constexpr_sum(is_pyobject<Extra>::value...) == 1 && // Exactly one base
+                 constexpr_sum(is_base<options>::value...) == 0 &&   // no template option bases
+                 // no multiple_inheritance attr
+                 none_of<std::is_same<multiple_inheritance, Extra>...>::value),
             "Error: multiple inheritance bases must be specified via class_ template options");
 
         type_record record;
         record.scope = scope;
         record.name = name;
         record.type = &typeid(type);
         record.type_size = sizeof(conditional_t<has_alias, type_alias, type>);
-        record.type_align = alignof(conditional_t<has_alias, type_alias, type>&);
+        record.type_align = alignof(conditional_t<has_alias, type_alias, type> &);
         record.holder_size = sizeof(holder_type);
         record.init_instance = init_instance;
         record.dealloc = dealloc;
         record.default_holder = detail::is_instantiation<std::unique_ptr, holder_type>::value;
 
         set_operator_new<type>(&record);
 
@@ -1103,1092 +1542,1341 @@
 
         /* Process optional arguments, if any */
         process_attributes<Extra...>::init(extra..., &record);
 
         generic_type::initialize(record);
 
         if (has_alias) {
-            auto &instances = record.module_local ? registered_local_types_cpp() : get_internals().registered_types_cpp;
-            instances[std::type_index(typeid(type_alias))] = instances[std::type_index(typeid(type))];
+            auto &instances = record.module_local ? get_local_internals().registered_types_cpp
+                                                  : get_internals().registered_types_cpp;
+            instances[std::type_index(typeid(type_alias))]
+                = instances[std::type_index(typeid(type))];
         }
     }
 
     template <typename Base, detail::enable_if_t<is_base<Base>::value, int> = 0>
     static void add_base(detail::type_record &rec) {
         rec.add_base(typeid(Base), [](void *src) -> void * {
             return static_cast<Base *>(reinterpret_cast<type *>(src));
         });
     }
 
     template <typename Base, detail::enable_if_t<!is_base<Base>::value, int> = 0>
-    static void add_base(detail::type_record &) { }
+    static void add_base(detail::type_record &) {}
 
     template <typename Func, typename... Extra>
-    class_ &def(const char *name_, Func&& f, const Extra&... extra) {
-        cpp_function cf(method_adaptor<type>(std::forward<Func>(f)), name(name_), is_method(*this),
-                        sibling(getattr(*this, name_, none())), extra...);
-        attr(cf.name()) = cf;
+    class_ &def(const char *name_, Func &&f, const Extra &...extra) {
+        cpp_function cf(method_adaptor<type>(std::forward<Func>(f)),
+                        name(name_),
+                        is_method(*this),
+                        sibling(getattr(*this, name_, none())),
+                        extra...);
+        add_class_method(*this, name_, cf);
         return *this;
     }
 
-    template <typename Func, typename... Extra> class_ &
-    def_static(const char *name_, Func &&f, const Extra&... extra) {
+    template <typename Func, typename... Extra>
+    class_ &def_static(const char *name_, Func &&f, const Extra &...extra) {
         static_assert(!std::is_member_function_pointer<Func>::value,
-                "def_static(...) called with a non-static member function pointer");
-        cpp_function cf(std::forward<Func>(f), name(name_), scope(*this),
-                        sibling(getattr(*this, name_, none())), extra...);
-        attr(cf.name()) = staticmethod(cf);
+                      "def_static(...) called with a non-static member function pointer");
+        cpp_function cf(std::forward<Func>(f),
+                        name(name_),
+                        scope(*this),
+                        sibling(getattr(*this, name_, none())),
+                        extra...);
+        auto cf_name = cf.name();
+        attr(std::move(cf_name)) = staticmethod(std::move(cf));
         return *this;
     }
 
-    template <detail::op_id id, detail::op_type ot, typename L, typename R, typename... Extra>
-    class_ &def(const detail::op_<id, ot, L, R> &op, const Extra&... extra) {
+    template <typename T, typename... Extra, detail::enable_if_t<T::op_enable_if_hook, int> = 0>
+    class_ &def(const T &op, const Extra &...extra) {
         op.execute(*this, extra...);
         return *this;
     }
 
-    template <detail::op_id id, detail::op_type ot, typename L, typename R, typename... Extra>
-    class_ & def_cast(const detail::op_<id, ot, L, R> &op, const Extra&... extra) {
+    template <typename T, typename... Extra, detail::enable_if_t<T::op_enable_if_hook, int> = 0>
+    class_ &def_cast(const T &op, const Extra &...extra) {
         op.execute_cast(*this, extra...);
         return *this;
     }
 
     template <typename... Args, typename... Extra>
-    class_ &def(const detail::initimpl::constructor<Args...> &init, const Extra&... extra) {
+    class_ &def(const detail::initimpl::constructor<Args...> &init, const Extra &...extra) {
+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(init);
         init.execute(*this, extra...);
         return *this;
     }
 
     template <typename... Args, typename... Extra>
-    class_ &def(const detail::initimpl::alias_constructor<Args...> &init, const Extra&... extra) {
+    class_ &def(const detail::initimpl::alias_constructor<Args...> &init, const Extra &...extra) {
+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(init);
         init.execute(*this, extra...);
         return *this;
     }
 
     template <typename... Args, typename... Extra>
-    class_ &def(detail::initimpl::factory<Args...> &&init, const Extra&... extra) {
+    class_ &def(detail::initimpl::factory<Args...> &&init, const Extra &...extra) {
         std::move(init).execute(*this, extra...);
         return *this;
     }
 
     template <typename... Args, typename... Extra>
     class_ &def(detail::initimpl::pickle_factory<Args...> &&pf, const Extra &...extra) {
         std::move(pf).execute(*this, extra...);
         return *this;
     }
 
-    template <typename Func> class_& def_buffer(Func &&func) {
-        struct capture { Func func; };
-        capture *ptr = new capture { std::forward<Func>(func) };
-        install_buffer_funcs([](PyObject *obj, void *ptr) -> buffer_info* {
-            detail::make_caster<type> caster;
-            if (!caster.load(obj, false))
-                return nullptr;
-            return new buffer_info(((capture *) ptr)->func(caster));
-        }, ptr);
+    template <typename Func>
+    class_ &def_buffer(Func &&func) {
+        struct capture {
+            Func func;
+        };
+        auto *ptr = new capture{std::forward<Func>(func)};
+        install_buffer_funcs(
+            [](PyObject *obj, void *ptr) -> buffer_info * {
+                detail::make_caster<type> caster;
+                if (!caster.load(obj, false)) {
+                    return nullptr;
+                }
+                return new buffer_info(((capture *) ptr)->func(std::move(caster)));
+            },
+            ptr);
+        weakref(m_ptr, cpp_function([ptr](handle wr) {
+                    delete ptr;
+                    wr.dec_ref();
+                }))
+            .release();
         return *this;
     }
 
     template <typename Return, typename Class, typename... Args>
     class_ &def_buffer(Return (Class::*func)(Args...)) {
-        return def_buffer([func] (type &obj) { return (obj.*func)(); });
+        return def_buffer([func](type &obj) { return (obj.*func)(); });
     }
 
     template <typename Return, typename Class, typename... Args>
     class_ &def_buffer(Return (Class::*func)(Args...) const) {
-        return def_buffer([func] (const type &obj) { return (obj.*func)(); });
+        return def_buffer([func](const type &obj) { return (obj.*func)(); });
     }
 
     template <typename C, typename D, typename... Extra>
-    class_ &def_readwrite(const char *name, D C::*pm, const Extra&... extra) {
-        static_assert(std::is_same<C, type>::value || std::is_base_of<C, type>::value, "def_readwrite() requires a class member (or base class member)");
-        cpp_function fget([pm](const type &c) -> const D &{ return c.*pm; }, is_method(*this)),
-                     fset([pm](type &c, const D &value) { c.*pm = value; }, is_method(*this));
+    class_ &def_readwrite(const char *name, D C::*pm, const Extra &...extra) {
+        static_assert(std::is_same<C, type>::value || std::is_base_of<C, type>::value,
+                      "def_readwrite() requires a class member (or base class member)");
+        cpp_function fget([pm](const type &c) -> const D & { return c.*pm; }, is_method(*this)),
+            fset([pm](type &c, const D &value) { c.*pm = value; }, is_method(*this));
         def_property(name, fget, fset, return_value_policy::reference_internal, extra...);
         return *this;
     }
 
     template <typename C, typename D, typename... Extra>
-    class_ &def_readonly(const char *name, const D C::*pm, const Extra& ...extra) {
-        static_assert(std::is_same<C, type>::value || std::is_base_of<C, type>::value, "def_readonly() requires a class member (or base class member)");
-        cpp_function fget([pm](const type &c) -> const D &{ return c.*pm; }, is_method(*this));
+    class_ &def_readonly(const char *name, const D C::*pm, const Extra &...extra) {
+        static_assert(std::is_same<C, type>::value || std::is_base_of<C, type>::value,
+                      "def_readonly() requires a class member (or base class member)");
+        cpp_function fget([pm](const type &c) -> const D & { return c.*pm; }, is_method(*this));
         def_property_readonly(name, fget, return_value_policy::reference_internal, extra...);
         return *this;
     }
 
     template <typename D, typename... Extra>
-    class_ &def_readwrite_static(const char *name, D *pm, const Extra& ...extra) {
-        cpp_function fget([pm](object) -> const D &{ return *pm; }, scope(*this)),
-                     fset([pm](object, const D &value) { *pm = value; }, scope(*this));
+    class_ &def_readwrite_static(const char *name, D *pm, const Extra &...extra) {
+        cpp_function fget([pm](const object &) -> const D & { return *pm; }, scope(*this)),
+            fset([pm](const object &, const D &value) { *pm = value; }, scope(*this));
         def_property_static(name, fget, fset, return_value_policy::reference, extra...);
         return *this;
     }
 
     template <typename D, typename... Extra>
-    class_ &def_readonly_static(const char *name, const D *pm, const Extra& ...extra) {
-        cpp_function fget([pm](object) -> const D &{ return *pm; }, scope(*this));
+    class_ &def_readonly_static(const char *name, const D *pm, const Extra &...extra) {
+        cpp_function fget([pm](const object &) -> const D & { return *pm; }, scope(*this));
         def_property_readonly_static(name, fget, return_value_policy::reference, extra...);
         return *this;
     }
 
     /// Uses return_value_policy::reference_internal by default
     template <typename Getter, typename... Extra>
-    class_ &def_property_readonly(const char *name, const Getter &fget, const Extra& ...extra) {
-        return def_property_readonly(name, cpp_function(method_adaptor<type>(fget)),
-                                     return_value_policy::reference_internal, extra...);
+    class_ &def_property_readonly(const char *name, const Getter &fget, const Extra &...extra) {
+        return def_property_readonly(name,
+                                     cpp_function(method_adaptor<type>(fget)),
+                                     return_value_policy::reference_internal,
+                                     extra...);
     }
 
     /// Uses cpp_function's return_value_policy by default
     template <typename... Extra>
-    class_ &def_property_readonly(const char *name, const cpp_function &fget, const Extra& ...extra) {
+    class_ &
+    def_property_readonly(const char *name, const cpp_function &fget, const Extra &...extra) {
         return def_property(name, fget, nullptr, extra...);
     }
 
     /// Uses return_value_policy::reference by default
     template <typename Getter, typename... Extra>
-    class_ &def_property_readonly_static(const char *name, const Getter &fget, const Extra& ...extra) {
-        return def_property_readonly_static(name, cpp_function(fget), return_value_policy::reference, extra...);
+    class_ &
+    def_property_readonly_static(const char *name, const Getter &fget, const Extra &...extra) {
+        return def_property_readonly_static(
+            name, cpp_function(fget), return_value_policy::reference, extra...);
     }
 
     /// Uses cpp_function's return_value_policy by default
     template <typename... Extra>
-    class_ &def_property_readonly_static(const char *name, const cpp_function &fget, const Extra& ...extra) {
+    class_ &def_property_readonly_static(const char *name,
+                                         const cpp_function &fget,
+                                         const Extra &...extra) {
         return def_property_static(name, fget, nullptr, extra...);
     }
 
     /// Uses return_value_policy::reference_internal by default
     template <typename Getter, typename Setter, typename... Extra>
-    class_ &def_property(const char *name, const Getter &fget, const Setter &fset, const Extra& ...extra) {
+    class_ &
+    def_property(const char *name, const Getter &fget, const Setter &fset, const Extra &...extra) {
         return def_property(name, fget, cpp_function(method_adaptor<type>(fset)), extra...);
     }
     template <typename Getter, typename... Extra>
-    class_ &def_property(const char *name, const Getter &fget, const cpp_function &fset, const Extra& ...extra) {
-        return def_property(name, cpp_function(method_adaptor<type>(fget)), fset,
-                            return_value_policy::reference_internal, extra...);
+    class_ &def_property(const char *name,
+                         const Getter &fget,
+                         const cpp_function &fset,
+                         const Extra &...extra) {
+        return def_property(name,
+                            cpp_function(method_adaptor<type>(fget)),
+                            fset,
+                            return_value_policy::reference_internal,
+                            extra...);
     }
 
     /// Uses cpp_function's return_value_policy by default
     template <typename... Extra>
-    class_ &def_property(const char *name, const cpp_function &fget, const cpp_function &fset, const Extra& ...extra) {
+    class_ &def_property(const char *name,
+                         const cpp_function &fget,
+                         const cpp_function &fset,
+                         const Extra &...extra) {
         return def_property_static(name, fget, fset, is_method(*this), extra...);
     }
 
     /// Uses return_value_policy::reference by default
     template <typename Getter, typename... Extra>
-    class_ &def_property_static(const char *name, const Getter &fget, const cpp_function &fset, const Extra& ...extra) {
-        return def_property_static(name, cpp_function(fget), fset, return_value_policy::reference, extra...);
+    class_ &def_property_static(const char *name,
+                                const Getter &fget,
+                                const cpp_function &fset,
+                                const Extra &...extra) {
+        return def_property_static(
+            name, cpp_function(fget), fset, return_value_policy::reference, extra...);
     }
 
     /// Uses cpp_function's return_value_policy by default
     template <typename... Extra>
-    class_ &def_property_static(const char *name, const cpp_function &fget, const cpp_function &fset, const Extra& ...extra) {
-        static_assert( 0 == detail::constexpr_sum(std::is_base_of<arg, Extra>::value...),
+    class_ &def_property_static(const char *name,
+                                const cpp_function &fget,
+                                const cpp_function &fset,
+                                const Extra &...extra) {
+        static_assert(0 == detail::constexpr_sum(std::is_base_of<arg, Extra>::value...),
                       "Argument annotations are not allowed for properties");
         auto rec_fget = get_function_record(fget), rec_fset = get_function_record(fset);
         auto *rec_active = rec_fget;
         if (rec_fget) {
-           char *doc_prev = rec_fget->doc; /* 'extra' field may include a property-specific documentation string */
-           detail::process_attributes<Extra...>::init(extra..., rec_fget);
-           if (rec_fget->doc && rec_fget->doc != doc_prev) {
-              free(doc_prev);
-              rec_fget->doc = strdup(rec_fget->doc);
-           }
+            char *doc_prev = rec_fget->doc; /* 'extra' field may include a property-specific
+                                               documentation string */
+            detail::process_attributes<Extra...>::init(extra..., rec_fget);
+            if (rec_fget->doc && rec_fget->doc != doc_prev) {
+                std::free(doc_prev);
+                rec_fget->doc = PYBIND11_COMPAT_STRDUP(rec_fget->doc);
+            }
         }
         if (rec_fset) {
             char *doc_prev = rec_fset->doc;
             detail::process_attributes<Extra...>::init(extra..., rec_fset);
             if (rec_fset->doc && rec_fset->doc != doc_prev) {
-                free(doc_prev);
-                rec_fset->doc = strdup(rec_fset->doc);
+                std::free(doc_prev);
+                rec_fset->doc = PYBIND11_COMPAT_STRDUP(rec_fset->doc);
+            }
+            if (!rec_active) {
+                rec_active = rec_fset;
             }
-            if (! rec_active) rec_active = rec_fset;
         }
         def_property_static_impl(name, fget, fset, rec_active);
         return *this;
     }
 
 private:
     /// Initialize holder object, variant 1: object derives from enable_shared_from_this
     template <typename T>
-    static void init_holder(detail::instance *inst, detail::value_and_holder &v_h,
-            const holder_type * /* unused */, const std::enable_shared_from_this<T> * /* dummy */) {
-        try {
-            auto sh = std::dynamic_pointer_cast<typename holder_type::element_type>(
-                    v_h.value_ptr<type>()->shared_from_this());
-            if (sh) {
-                new (std::addressof(v_h.holder<holder_type>())) holder_type(std::move(sh));
-                v_h.set_holder_constructed();
-            }
-        } catch (const std::bad_weak_ptr &) {}
+    static void init_holder(detail::instance *inst,
+                            detail::value_and_holder &v_h,
+                            const holder_type * /* unused */,
+                            const std::enable_shared_from_this<T> * /* dummy */) {
+
+        auto sh = std::dynamic_pointer_cast<typename holder_type::element_type>(
+            detail::try_get_shared_from_this(v_h.value_ptr<type>()));
+        if (sh) {
+            new (std::addressof(v_h.holder<holder_type>())) holder_type(std::move(sh));
+            v_h.set_holder_constructed();
+        }
 
         if (!v_h.holder_constructed() && inst->owned) {
             new (std::addressof(v_h.holder<holder_type>())) holder_type(v_h.value_ptr<type>());
             v_h.set_holder_constructed();
         }
     }
 
     static void init_holder_from_existing(const detail::value_and_holder &v_h,
-            const holder_type *holder_ptr, std::true_type /*is_copy_constructible*/) {
-        new (std::addressof(v_h.holder<holder_type>())) holder_type(*reinterpret_cast<const holder_type *>(holder_ptr));
+                                          const holder_type *holder_ptr,
+                                          std::true_type /*is_copy_constructible*/) {
+        new (std::addressof(v_h.holder<holder_type>()))
+            holder_type(*reinterpret_cast<const holder_type *>(holder_ptr));
     }
 
     static void init_holder_from_existing(const detail::value_and_holder &v_h,
-            const holder_type *holder_ptr, std::false_type /*is_copy_constructible*/) {
-        new (std::addressof(v_h.holder<holder_type>())) holder_type(std::move(*const_cast<holder_type *>(holder_ptr)));
+                                          const holder_type *holder_ptr,
+                                          std::false_type /*is_copy_constructible*/) {
+        new (std::addressof(v_h.holder<holder_type>()))
+            holder_type(std::move(*const_cast<holder_type *>(holder_ptr)));
     }
 
-    /// Initialize holder object, variant 2: try to construct from existing holder object, if possible
-    static void init_holder(detail::instance *inst, detail::value_and_holder &v_h,
-            const holder_type *holder_ptr, const void * /* dummy -- not enable_shared_from_this<T>) */) {
+    /// Initialize holder object, variant 2: try to construct from existing holder object, if
+    /// possible
+    static void init_holder(detail::instance *inst,
+                            detail::value_and_holder &v_h,
+                            const holder_type *holder_ptr,
+                            const void * /* dummy -- not enable_shared_from_this<T>) */) {
         if (holder_ptr) {
             init_holder_from_existing(v_h, holder_ptr, std::is_copy_constructible<holder_type>());
             v_h.set_holder_constructed();
-        } else if (inst->owned || detail::always_construct_holder<holder_type>::value) {
+        } else if (detail::always_construct_holder<holder_type>::value || inst->owned) {
             new (std::addressof(v_h.holder<holder_type>())) holder_type(v_h.value_ptr<type>());
             v_h.set_holder_constructed();
         }
     }
 
     /// Performs instance initialization including constructing a holder and registering the known
-    /// instance.  Should be called as soon as the `type` value_ptr is set for an instance.  Takes an
-    /// optional pointer to an existing holder to use; if not specified and the instance is
+    /// instance.  Should be called as soon as the `type` value_ptr is set for an instance.  Takes
+    /// an optional pointer to an existing holder to use; if not specified and the instance is
     /// `.owned`, a new holder will be constructed to manage the value pointer.
     static void init_instance(detail::instance *inst, const void *holder_ptr) {
         auto v_h = inst->get_value_and_holder(detail::get_type_info(typeid(type)));
         if (!v_h.instance_registered()) {
             register_instance(inst, v_h.value_ptr(), v_h.type);
             v_h.set_instance_registered();
         }
         init_holder(inst, v_h, (const holder_type *) holder_ptr, v_h.value_ptr<type>());
     }
 
     /// Deallocates an instance; via holder, if constructed; otherwise via operator delete.
     static void dealloc(detail::value_and_holder &v_h) {
+        // We could be deallocating because we are cleaning up after a Python exception.
+        // If so, the Python error indicator will be set. We need to clear that before
+        // running the destructor, in case the destructor code calls more Python.
+        // If we don't, the Python API will exit with an exception, and pybind11 will
+        // throw error_already_set from the C++ destructor which is forbidden and triggers
+        // std::terminate().
+        error_scope scope;
         if (v_h.holder_constructed()) {
             v_h.holder<holder_type>().~holder_type();
             v_h.set_holder_constructed(false);
-        }
-        else {
-            detail::call_operator_delete(v_h.value_ptr<type>(),
-                v_h.type->type_size,
-                v_h.type->type_align
-            );
+        } else {
+            detail::call_operator_delete(
+                v_h.value_ptr<type>(), v_h.type->type_size, v_h.type->type_align);
         }
         v_h.value_ptr() = nullptr;
     }
 
     static detail::function_record *get_function_record(handle h) {
         h = detail::get_function(h);
-        return h ? (detail::function_record *) reinterpret_borrow<capsule>(PyCFunction_GET_SELF(h.ptr()))
-                 : nullptr;
+        if (!h) {
+            return nullptr;
+        }
+
+        handle func_self = PyCFunction_GET_SELF(h.ptr());
+        if (!func_self) {
+            throw error_already_set();
+        }
+        if (!isinstance<capsule>(func_self)) {
+            return nullptr;
+        }
+        auto cap = reinterpret_borrow<capsule>(func_self);
+        if (!detail::is_function_record_capsule(cap)) {
+            return nullptr;
+        }
+        return cap.get_pointer<detail::function_record>();
     }
 };
 
 /// Binds an existing constructor taking arguments Args...
-template <typename... Args> detail::initimpl::constructor<Args...> init() { return {}; }
+template <typename... Args>
+detail::initimpl::constructor<Args...> init() {
+    return {};
+}
 /// Like `init<Args...>()`, but the instance is always constructed through the alias class (even
 /// when not inheriting on the Python side).
-template <typename... Args> detail::initimpl::alias_constructor<Args...> init_alias() { return {}; }
+template <typename... Args>
+detail::initimpl::alias_constructor<Args...> init_alias() {
+    return {};
+}
 
 /// Binds a factory function as a constructor
 template <typename Func, typename Ret = detail::initimpl::factory<Func>>
-Ret init(Func &&f) { return {std::forward<Func>(f)}; }
+Ret init(Func &&f) {
+    return {std::forward<Func>(f)};
+}
 
-/// Dual-argument factory function: the first function is called when no alias is needed, the second
-/// when an alias is needed (i.e. due to python-side inheritance).  Arguments must be identical.
+/// Dual-argument factory function: the first function is called when no alias is needed, the
+/// second when an alias is needed (i.e. due to python-side inheritance).  Arguments must be
+/// identical.
 template <typename CFunc, typename AFunc, typename Ret = detail::initimpl::factory<CFunc, AFunc>>
 Ret init(CFunc &&c, AFunc &&a) {
     return {std::forward<CFunc>(c), std::forward<AFunc>(a)};
 }
 
 /// Binds pickling functions `__getstate__` and `__setstate__` and ensures that the type
 /// returned by `__getstate__` is the same as the argument accepted by `__setstate__`.
 template <typename GetState, typename SetState>
 detail::initimpl::pickle_factory<GetState, SetState> pickle(GetState &&g, SetState &&s) {
     return {std::forward<GetState>(g), std::forward<SetState>(s)};
 }
 
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(detail)
+
+inline str enum_name(handle arg) {
+    dict entries = arg.get_type().attr("__entries");
+    for (auto kv : entries) {
+        if (handle(kv.second[int_(0)]).equal(arg)) {
+            return pybind11::str(kv.first);
+        }
+    }
+    return "???";
+}
+
 struct enum_base {
-    enum_base(handle base, handle parent) : m_base(base), m_parent(parent) { }
+    enum_base(const handle &base, const handle &parent) : m_base(base), m_parent(parent) {}
 
     PYBIND11_NOINLINE void init(bool is_arithmetic, bool is_convertible) {
         m_base.attr("__entries") = dict();
         auto property = handle((PyObject *) &PyProperty_Type);
         auto static_property = handle((PyObject *) get_internals().static_property_type);
 
         m_base.attr("__repr__") = cpp_function(
-            [](handle arg) -> str {
-                handle type = arg.get_type();
+            [](const object &arg) -> str {
+                handle type = type::handle_of(arg);
                 object type_name = type.attr("__name__");
-                dict entries = type.attr("__entries");
-                for (const auto &kv : entries) {
-                    object other = kv.second[int_(0)];
-                    if (other.equal(arg))
-                        return pybind11::str("{}.{}").format(type_name, kv.first);
-                }
-                return pybind11::str("{}.???").format(type_name);
-            }, name("__repr__"), is_method(m_base)
-        );
+                return pybind11::str("<{}.{}: {}>")
+                    .format(std::move(type_name), enum_name(arg), int_(arg));
+            },
+            name("__repr__"),
+            is_method(m_base));
+
+        m_base.attr("name") = property(cpp_function(&enum_name, name("name"), is_method(m_base)));
 
-        m_base.attr("name") = property(cpp_function(
+        m_base.attr("__str__") = cpp_function(
             [](handle arg) -> str {
-                dict entries = arg.get_type().attr("__entries");
-                for (const auto &kv : entries) {
-                    if (handle(kv.second[int_(0)]).equal(arg))
-                        return pybind11::str(kv.first);
-                }
-                return "???";
-            }, name("name"), is_method(m_base)
-        ));
-
-        m_base.attr("__doc__") = static_property(cpp_function(
-            [](handle arg) -> std::string {
-                std::string docstring;
-                dict entries = arg.attr("__entries");
-                if (((PyTypeObject *) arg.ptr())->tp_doc)
-                    docstring += std::string(((PyTypeObject *) arg.ptr())->tp_doc) + "\n\n";
-                docstring += "Members:";
-                for (const auto &kv : entries) {
-                    auto key = std::string(pybind11::str(kv.first));
-                    auto comment = kv.second[int_(1)];
-                    docstring += "\n\n  " + key;
-                    if (!comment.is_none())
-                        docstring += " : " + (std::string) pybind11::str(comment);
-                }
-                return docstring;
-            }, name("__doc__")
-        ), none(), none(), "");
+                object type_name = type::handle_of(arg).attr("__name__");
+                return pybind11::str("{}.{}").format(std::move(type_name), enum_name(arg));
+            },
+            name("name"),
+            is_method(m_base));
+
+        if (options::show_enum_members_docstring()) {
+            m_base.attr("__doc__") = static_property(
+                cpp_function(
+                    [](handle arg) -> std::string {
+                        std::string docstring;
+                        dict entries = arg.attr("__entries");
+                        if (((PyTypeObject *) arg.ptr())->tp_doc) {
+                            docstring += std::string(
+                                reinterpret_cast<PyTypeObject *>(arg.ptr())->tp_doc);
+                            docstring += "\n\n";
+                        }
+                        docstring += "Members:";
+                        for (auto kv : entries) {
+                            auto key = std::string(pybind11::str(kv.first));
+                            auto comment = kv.second[int_(1)];
+                            docstring += "\n\n  ";
+                            docstring += key;
+                            if (!comment.is_none()) {
+                                docstring += " : ";
+                                docstring += pybind11::str(comment).cast<std::string>();
+                            }
+                        }
+                        return docstring;
+                    },
+                    name("__doc__")),
+                none(),
+                none(),
+                "");
+        }
 
         m_base.attr("__members__") = static_property(cpp_function(
-            [](handle arg) -> dict {
-                dict entries = arg.attr("__entries"), m;
-                for (const auto &kv : entries)
-                    m[kv.first] = kv.second[int_(0)];
-                return m;
-            }, name("__members__")), none(), none(), ""
-        );
-
-        #define PYBIND11_ENUM_OP_STRICT(op, expr, strict_behavior)                     \
-            m_base.attr(op) = cpp_function(                                            \
-                [](object a, object b) {                                               \
-                    if (!a.get_type().is(b.get_type()))                                \
-                        strict_behavior;                                               \
-                    return expr;                                                       \
-                },                                                                     \
-                name(op), is_method(m_base))
-
-        #define PYBIND11_ENUM_OP_CONV(op, expr)                                        \
-            m_base.attr(op) = cpp_function(                                            \
-                [](object a_, object b_) {                                             \
-                    int_ a(a_), b(b_);                                                 \
-                    return expr;                                                       \
-                },                                                                     \
-                name(op), is_method(m_base))
-
-        #define PYBIND11_ENUM_OP_CONV_LHS(op, expr)                                    \
-            m_base.attr(op) = cpp_function(                                            \
-                [](object a_, object b) {                                              \
-                    int_ a(a_);                                                        \
-                    return expr;                                                       \
-                },                                                                     \
-                name(op), is_method(m_base))
+                                                         [](handle arg) -> dict {
+                                                             dict entries = arg.attr("__entries"),
+                                                                  m;
+                                                             for (auto kv : entries) {
+                                                                 m[kv.first] = kv.second[int_(0)];
+                                                             }
+                                                             return m;
+                                                         },
+                                                         name("__members__")),
+                                                     none(),
+                                                     none(),
+                                                     "");
+
+#define PYBIND11_ENUM_OP_STRICT(op, expr, strict_behavior)                                        \
+    m_base.attr(op) = cpp_function(                                                               \
+        [](const object &a, const object &b) {                                                    \
+            if (!type::handle_of(a).is(type::handle_of(b)))                                       \
+                strict_behavior; /* NOLINT(bugprone-macro-parentheses) */                         \
+            return expr;                                                                          \
+        },                                                                                        \
+        name(op),                                                                                 \
+        is_method(m_base),                                                                        \
+        arg("other"))
+
+#define PYBIND11_ENUM_OP_CONV(op, expr)                                                           \
+    m_base.attr(op) = cpp_function(                                                               \
+        [](const object &a_, const object &b_) {                                                  \
+            int_ a(a_), b(b_);                                                                    \
+            return expr;                                                                          \
+        },                                                                                        \
+        name(op),                                                                                 \
+        is_method(m_base),                                                                        \
+        arg("other"))
+
+#define PYBIND11_ENUM_OP_CONV_LHS(op, expr)                                                       \
+    m_base.attr(op) = cpp_function(                                                               \
+        [](const object &a_, const object &b) {                                                   \
+            int_ a(a_);                                                                           \
+            return expr;                                                                          \
+        },                                                                                        \
+        name(op),                                                                                 \
+        is_method(m_base),                                                                        \
+        arg("other"))
 
         if (is_convertible) {
-            PYBIND11_ENUM_OP_CONV_LHS("__eq__", !b.is_none() &&  a.equal(b));
-            PYBIND11_ENUM_OP_CONV_LHS("__ne__",  b.is_none() || !a.equal(b));
+            PYBIND11_ENUM_OP_CONV_LHS("__eq__", !b.is_none() && a.equal(b));
+            PYBIND11_ENUM_OP_CONV_LHS("__ne__", b.is_none() || !a.equal(b));
 
             if (is_arithmetic) {
-                PYBIND11_ENUM_OP_CONV("__lt__",   a <  b);
-                PYBIND11_ENUM_OP_CONV("__gt__",   a >  b);
-                PYBIND11_ENUM_OP_CONV("__le__",   a <= b);
-                PYBIND11_ENUM_OP_CONV("__ge__",   a >= b);
-                PYBIND11_ENUM_OP_CONV("__and__",  a &  b);
-                PYBIND11_ENUM_OP_CONV("__rand__", a &  b);
-                PYBIND11_ENUM_OP_CONV("__or__",   a |  b);
-                PYBIND11_ENUM_OP_CONV("__ror__",  a |  b);
-                PYBIND11_ENUM_OP_CONV("__xor__",  a ^  b);
-                PYBIND11_ENUM_OP_CONV("__rxor__", a ^  b);
-                m_base.attr("__invert__") = cpp_function(
-                    [](object arg) { return ~(int_(arg)); }, name("__invert__"), is_method(m_base));
+                PYBIND11_ENUM_OP_CONV("__lt__", a < b);
+                PYBIND11_ENUM_OP_CONV("__gt__", a > b);
+                PYBIND11_ENUM_OP_CONV("__le__", a <= b);
+                PYBIND11_ENUM_OP_CONV("__ge__", a >= b);
+                PYBIND11_ENUM_OP_CONV("__and__", a & b);
+                PYBIND11_ENUM_OP_CONV("__rand__", a & b);
+                PYBIND11_ENUM_OP_CONV("__or__", a | b);
+                PYBIND11_ENUM_OP_CONV("__ror__", a | b);
+                PYBIND11_ENUM_OP_CONV("__xor__", a ^ b);
+                PYBIND11_ENUM_OP_CONV("__rxor__", a ^ b);
+                m_base.attr("__invert__")
+                    = cpp_function([](const object &arg) { return ~(int_(arg)); },
+                                   name("__invert__"),
+                                   is_method(m_base));
             }
         } else {
-            PYBIND11_ENUM_OP_STRICT("__eq__",  int_(a).equal(int_(b)), return false);
+            PYBIND11_ENUM_OP_STRICT("__eq__", int_(a).equal(int_(b)), return false);
             PYBIND11_ENUM_OP_STRICT("__ne__", !int_(a).equal(int_(b)), return true);
 
             if (is_arithmetic) {
-                #define PYBIND11_THROW throw type_error("Expected an enumeration of matching type!");
-                PYBIND11_ENUM_OP_STRICT("__lt__", int_(a) <  int_(b), PYBIND11_THROW);
-                PYBIND11_ENUM_OP_STRICT("__gt__", int_(a) >  int_(b), PYBIND11_THROW);
+#define PYBIND11_THROW throw type_error("Expected an enumeration of matching type!");
+                PYBIND11_ENUM_OP_STRICT("__lt__", int_(a) < int_(b), PYBIND11_THROW);
+                PYBIND11_ENUM_OP_STRICT("__gt__", int_(a) > int_(b), PYBIND11_THROW);
                 PYBIND11_ENUM_OP_STRICT("__le__", int_(a) <= int_(b), PYBIND11_THROW);
                 PYBIND11_ENUM_OP_STRICT("__ge__", int_(a) >= int_(b), PYBIND11_THROW);
-                #undef PYBIND11_THROW
+#undef PYBIND11_THROW
             }
         }
 
-        #undef PYBIND11_ENUM_OP_CONV_LHS
-        #undef PYBIND11_ENUM_OP_CONV
-        #undef PYBIND11_ENUM_OP_STRICT
+#undef PYBIND11_ENUM_OP_CONV_LHS
+#undef PYBIND11_ENUM_OP_CONV
+#undef PYBIND11_ENUM_OP_STRICT
 
         m_base.attr("__getstate__") = cpp_function(
-            [](object arg) { return int_(arg); }, name("__getstate__"), is_method(m_base));
+            [](const object &arg) { return int_(arg); }, name("__getstate__"), is_method(m_base));
 
         m_base.attr("__hash__") = cpp_function(
-            [](object arg) { return int_(arg); }, name("__hash__"), is_method(m_base));
+            [](const object &arg) { return int_(arg); }, name("__hash__"), is_method(m_base));
     }
 
-    PYBIND11_NOINLINE void value(char const* name_, object value, const char *doc = nullptr) {
+    PYBIND11_NOINLINE void value(char const *name_, object value, const char *doc = nullptr) {
         dict entries = m_base.attr("__entries");
         str name(name_);
         if (entries.contains(name)) {
             std::string type_name = (std::string) str(m_base.attr("__name__"));
-            throw value_error(type_name + ": element \"" + std::string(name_) + "\" already exists!");
+            throw value_error(std::move(type_name) + ": element \"" + std::string(name_)
+                              + "\" already exists!");
         }
 
-        entries[name] = std::make_pair(value, doc);
-        m_base.attr(name) = value;
+        entries[name] = pybind11::make_tuple(value, doc);
+        m_base.attr(std::move(name)) = std::move(value);
     }
 
     PYBIND11_NOINLINE void export_values() {
         dict entries = m_base.attr("__entries");
-        for (const auto &kv : entries)
+        for (auto kv : entries) {
             m_parent.attr(kv.first) = kv.second[int_(0)];
+        }
     }
 
     handle m_base;
     handle m_parent;
 };
 
-NAMESPACE_END(detail)
+template <bool is_signed, size_t length>
+struct equivalent_integer {};
+template <>
+struct equivalent_integer<true, 1> {
+    using type = int8_t;
+};
+template <>
+struct equivalent_integer<false, 1> {
+    using type = uint8_t;
+};
+template <>
+struct equivalent_integer<true, 2> {
+    using type = int16_t;
+};
+template <>
+struct equivalent_integer<false, 2> {
+    using type = uint16_t;
+};
+template <>
+struct equivalent_integer<true, 4> {
+    using type = int32_t;
+};
+template <>
+struct equivalent_integer<false, 4> {
+    using type = uint32_t;
+};
+template <>
+struct equivalent_integer<true, 8> {
+    using type = int64_t;
+};
+template <>
+struct equivalent_integer<false, 8> {
+    using type = uint64_t;
+};
+
+template <typename IntLike>
+using equivalent_integer_t =
+    typename equivalent_integer<std::is_signed<IntLike>::value, sizeof(IntLike)>::type;
+
+PYBIND11_NAMESPACE_END(detail)
 
 /// Binds C++ enumerations and enumeration classes to Python
-template <typename Type> class enum_ : public class_<Type> {
+template <typename Type>
+class enum_ : public class_<Type> {
 public:
     using Base = class_<Type>;
-    using Base::def;
     using Base::attr;
+    using Base::def;
     using Base::def_property_readonly;
     using Base::def_property_readonly_static;
-    using Scalar = typename std::underlying_type<Type>::type;
+    using Underlying = typename std::underlying_type<Type>::type;
+    // Scalar is the integer representation of underlying type
+    using Scalar = detail::conditional_t<detail::any_of<detail::is_std_char_type<Underlying>,
+                                                        std::is_same<Underlying, bool>>::value,
+                                         detail::equivalent_integer_t<Underlying>,
+                                         Underlying>;
 
     template <typename... Extra>
-    enum_(const handle &scope, const char *name, const Extra&... extra)
-      : class_<Type>(scope, name, extra...), m_base(*this, scope) {
+    enum_(const handle &scope, const char *name, const Extra &...extra)
+        : class_<Type>(scope, name, extra...), m_base(*this, scope) {
         constexpr bool is_arithmetic = detail::any_of<std::is_same<arithmetic, Extra>...>::value;
-        constexpr bool is_convertible = std::is_convertible<Type, Scalar>::value;
+        constexpr bool is_convertible = std::is_convertible<Type, Underlying>::value;
         m_base.init(is_arithmetic, is_convertible);
 
-        def(init([](Scalar i) { return static_cast<Type>(i); }));
+        def(init([](Scalar i) { return static_cast<Type>(i); }), arg("value"));
+        def_property_readonly("value", [](Type value) { return (Scalar) value; });
         def("__int__", [](Type value) { return (Scalar) value; });
-        #if PY_MAJOR_VERSION < 3
-            def("__long__", [](Type value) { return (Scalar) value; });
-        #endif
-        #if PY_MAJOR_VERSION > 3 || (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 8)
-            def("__index__", [](Type value) { return (Scalar) value; });
-        #endif
-
+        def("__index__", [](Type value) { return (Scalar) value; });
         attr("__setstate__") = cpp_function(
             [](detail::value_and_holder &v_h, Scalar arg) {
-                detail::initimpl::setstate<Base>(v_h, static_cast<Type>(arg),
-                        Py_TYPE(v_h.inst) != v_h.type->type); },
+                detail::initimpl::setstate<Base>(
+                    v_h, static_cast<Type>(arg), Py_TYPE(v_h.inst) != v_h.type->type);
+            },
             detail::is_new_style_constructor(),
-            pybind11::name("__setstate__"), is_method(*this));
+            pybind11::name("__setstate__"),
+            is_method(*this),
+            arg("state"));
     }
 
     /// Export enumeration entries into the parent scope
-    enum_& export_values() {
+    enum_ &export_values() {
         m_base.export_values();
         return *this;
     }
 
     /// Add an enumeration entry
-    enum_& value(char const* name, Type value, const char *doc = nullptr) {
+    enum_ &value(char const *name, Type value, const char *doc = nullptr) {
         m_base.value(name, pybind11::cast(value, return_value_policy::copy), doc);
         return *this;
     }
 
 private:
     detail::enum_base m_base;
 };
 
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(detail)
 
-
-inline void keep_alive_impl(handle nurse, handle patient) {
-    if (!nurse || !patient)
+PYBIND11_NOINLINE void keep_alive_impl(handle nurse, handle patient) {
+    if (!nurse || !patient) {
         pybind11_fail("Could not activate keep_alive!");
+    }
 
-    if (patient.is_none() || nurse.is_none())
+    if (patient.is_none() || nurse.is_none()) {
         return; /* Nothing to keep alive or nothing to be kept alive by */
+    }
 
     auto tinfo = all_type_info(Py_TYPE(nurse.ptr()));
     if (!tinfo.empty()) {
         /* It's a pybind-registered type, so we can store the patient in the
          * internal list. */
         add_patient(nurse.ptr(), patient.ptr());
-    }
-    else {
+    } else {
         /* Fall back to clever approach based on weak references taken from
          * Boost.Python. This is not used for pybind-registered types because
          * the objects can be destroyed out-of-order in a GC pass. */
-        cpp_function disable_lifesupport(
-            [patient](handle weakref) { patient.dec_ref(); weakref.dec_ref(); });
+        cpp_function disable_lifesupport([patient](handle weakref) {
+            patient.dec_ref();
+            weakref.dec_ref();
+        });
 
         weakref wr(nurse, disable_lifesupport);
 
         patient.inc_ref(); /* reference patient and leak the weak reference */
         (void) wr.release();
     }
 }
 
-PYBIND11_NOINLINE inline void keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret) {
+PYBIND11_NOINLINE void
+keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret) {
     auto get_arg = [&](size_t n) {
-        if (n == 0)
+        if (n == 0) {
             return ret;
-        else if (n == 1 && call.init_self)
+        }
+        if (n == 1 && call.init_self) {
             return call.init_self;
-        else if (n <= call.args.size())
+        }
+        if (n <= call.args.size()) {
             return call.args[n - 1];
+        }
         return handle();
     };
 
     keep_alive_impl(get_arg(Nurse), get_arg(Patient));
 }
 
-inline std::pair<decltype(internals::registered_types_py)::iterator, bool> all_type_info_get_cache(PyTypeObject *type) {
-    auto res = get_internals().registered_types_py
+inline std::pair<decltype(internals::registered_types_py)::iterator, bool>
+all_type_info_get_cache(PyTypeObject *type) {
+    auto res = get_internals()
+                   .registered_types_py
 #ifdef __cpp_lib_unordered_map_try_emplace
-        .try_emplace(type);
+                   .try_emplace(type);
 #else
-        .emplace(type, std::vector<detail::type_info *>());
+                   .emplace(type, std::vector<detail::type_info *>());
 #endif
     if (res.second) {
         // New cache entry created; set up a weak reference to automatically remove it if the type
         // gets destroyed:
         weakref((PyObject *) type, cpp_function([type](handle wr) {
-            get_internals().registered_types_py.erase(type);
-            wr.dec_ref();
-        })).release();
+                    get_internals().registered_types_py.erase(type);
+
+                    // TODO consolidate the erasure code in pybind11_meta_dealloc() in class.h
+                    auto &cache = get_internals().inactive_override_cache;
+                    for (auto it = cache.begin(), last = cache.end(); it != last;) {
+                        if (it->first == reinterpret_cast<PyObject *>(type)) {
+                            it = cache.erase(it);
+                        } else {
+                            ++it;
+                        }
+                    }
+
+                    wr.dec_ref();
+                }))
+            .release();
     }
 
     return res;
 }
 
-template <typename Iterator, typename Sentinel, bool KeyIterator, return_value_policy Policy>
+/* There are a large number of apparently unused template arguments because
+ * each combination requires a separate py::class_ registration.
+ */
+template <typename Access,
+          return_value_policy Policy,
+          typename Iterator,
+          typename Sentinel,
+          typename ValueType,
+          typename... Extra>
 struct iterator_state {
     Iterator it;
     Sentinel end;
     bool first_or_done;
 };
 
-NAMESPACE_END(detail)
+// Note: these helpers take the iterator by non-const reference because some
+// iterators in the wild can't be dereferenced when const. The & after Iterator
+// is required for MSVC < 16.9. SFINAE cannot be reused for result_type due to
+// bugs in ICC, NVCC, and PGI compilers. See PR #3293.
+template <typename Iterator, typename SFINAE = decltype(*std::declval<Iterator &>())>
+struct iterator_access {
+    using result_type = decltype(*std::declval<Iterator &>());
+    // NOLINTNEXTLINE(readability-const-return-type) // PR #3263
+    result_type operator()(Iterator &it) const { return *it; }
+};
 
-/// Makes a python iterator from a first and past-the-end C++ InputIterator.
-template <return_value_policy Policy = return_value_policy::reference_internal,
+template <typename Iterator, typename SFINAE = decltype((*std::declval<Iterator &>()).first)>
+class iterator_key_access {
+private:
+    using pair_type = decltype(*std::declval<Iterator &>());
+
+public:
+    /* If either the pair itself or the element of the pair is a reference, we
+     * want to return a reference, otherwise a value. When the decltype
+     * expression is parenthesized it is based on the value category of the
+     * expression; otherwise it is the declared type of the pair member.
+     * The use of declval<pair_type> in the second branch rather than directly
+     * using *std::declval<Iterator &>() is a workaround for nvcc
+     * (it's not used in the first branch because going via decltype and back
+     * through declval does not perfectly preserve references).
+     */
+    using result_type
+        = conditional_t<std::is_reference<decltype(*std::declval<Iterator &>())>::value,
+                        decltype(((*std::declval<Iterator &>()).first)),
+                        decltype(std::declval<pair_type>().first)>;
+    result_type operator()(Iterator &it) const { return (*it).first; }
+};
+
+template <typename Iterator, typename SFINAE = decltype((*std::declval<Iterator &>()).second)>
+class iterator_value_access {
+private:
+    using pair_type = decltype(*std::declval<Iterator &>());
+
+public:
+    using result_type
+        = conditional_t<std::is_reference<decltype(*std::declval<Iterator &>())>::value,
+                        decltype(((*std::declval<Iterator &>()).second)),
+                        decltype(std::declval<pair_type>().second)>;
+    result_type operator()(Iterator &it) const { return (*it).second; }
+};
+
+template <typename Access,
+          return_value_policy Policy,
           typename Iterator,
           typename Sentinel,
-          typename ValueType = decltype(*std::declval<Iterator>()),
+          typename ValueType,
           typename... Extra>
-iterator make_iterator(Iterator first, Sentinel last, Extra &&... extra) {
-    typedef detail::iterator_state<Iterator, Sentinel, false, Policy> state;
+iterator make_iterator_impl(Iterator first, Sentinel last, Extra &&...extra) {
+    using state = detail::iterator_state<Access, Policy, Iterator, Sentinel, ValueType, Extra...>;
+    // TODO: state captures only the types of Extra, not the values
 
     if (!detail::get_type_info(typeid(state), false)) {
         class_<state>(handle(), "iterator", pybind11::module_local())
-            .def("__iter__", [](state &s) -> state& { return s; })
-            .def("__next__", [](state &s) -> ValueType {
-                if (!s.first_or_done)
-                    ++s.it;
-                else
-                    s.first_or_done = false;
-                if (s.it == s.end) {
-                    s.first_or_done = true;
-                    throw stop_iteration();
-                }
-                return *s.it;
-            }, std::forward<Extra>(extra)..., Policy);
+            .def("__iter__", [](state &s) -> state & { return s; })
+            .def(
+                "__next__",
+                [](state &s) -> ValueType {
+                    if (!s.first_or_done) {
+                        ++s.it;
+                    } else {
+                        s.first_or_done = false;
+                    }
+                    if (s.it == s.end) {
+                        s.first_or_done = true;
+                        throw stop_iteration();
+                    }
+                    return Access()(s.it);
+                    // NOLINTNEXTLINE(readability-const-return-type) // PR #3263
+                },
+                std::forward<Extra>(extra)...,
+                Policy);
     }
 
     return cast(state{first, last, true});
 }
 
-/// Makes an python iterator over the keys (`.first`) of a iterator over pairs from a
-/// first and past-the-end InputIterator.
+PYBIND11_NAMESPACE_END(detail)
+
+/// Makes a python iterator from a first and past-the-end C++ InputIterator.
 template <return_value_policy Policy = return_value_policy::reference_internal,
           typename Iterator,
           typename Sentinel,
-          typename KeyType = decltype((*std::declval<Iterator>()).first),
+          typename ValueType = typename detail::iterator_access<Iterator>::result_type,
           typename... Extra>
-iterator make_key_iterator(Iterator first, Sentinel last, Extra &&... extra) {
-    typedef detail::iterator_state<Iterator, Sentinel, true, Policy> state;
+iterator make_iterator(Iterator first, Sentinel last, Extra &&...extra) {
+    return detail::make_iterator_impl<detail::iterator_access<Iterator>,
+                                      Policy,
+                                      Iterator,
+                                      Sentinel,
+                                      ValueType,
+                                      Extra...>(first, last, std::forward<Extra>(extra)...);
+}
 
-    if (!detail::get_type_info(typeid(state), false)) {
-        class_<state>(handle(), "iterator", pybind11::module_local())
-            .def("__iter__", [](state &s) -> state& { return s; })
-            .def("__next__", [](state &s) -> KeyType {
-                if (!s.first_or_done)
-                    ++s.it;
-                else
-                    s.first_or_done = false;
-                if (s.it == s.end) {
-                    s.first_or_done = true;
-                    throw stop_iteration();
-                }
-                return (*s.it).first;
-            }, std::forward<Extra>(extra)..., Policy);
-    }
+/// Makes a python iterator over the keys (`.first`) of a iterator over pairs from a
+/// first and past-the-end InputIterator.
+template <return_value_policy Policy = return_value_policy::reference_internal,
+          typename Iterator,
+          typename Sentinel,
+          typename KeyType = typename detail::iterator_key_access<Iterator>::result_type,
+          typename... Extra>
+iterator make_key_iterator(Iterator first, Sentinel last, Extra &&...extra) {
+    return detail::make_iterator_impl<detail::iterator_key_access<Iterator>,
+                                      Policy,
+                                      Iterator,
+                                      Sentinel,
+                                      KeyType,
+                                      Extra...>(first, last, std::forward<Extra>(extra)...);
+}
 
-    return cast(state{first, last, true});
+/// Makes a python iterator over the values (`.second`) of a iterator over pairs from a
+/// first and past-the-end InputIterator.
+template <return_value_policy Policy = return_value_policy::reference_internal,
+          typename Iterator,
+          typename Sentinel,
+          typename ValueType = typename detail::iterator_value_access<Iterator>::result_type,
+          typename... Extra>
+iterator make_value_iterator(Iterator first, Sentinel last, Extra &&...extra) {
+    return detail::make_iterator_impl<detail::iterator_value_access<Iterator>,
+                                      Policy,
+                                      Iterator,
+                                      Sentinel,
+                                      ValueType,
+                                      Extra...>(first, last, std::forward<Extra>(extra)...);
 }
 
 /// Makes an iterator over values of an stl container or other container supporting
 /// `std::begin()`/`std::end()`
 template <return_value_policy Policy = return_value_policy::reference_internal,
-          typename Type, typename... Extra> iterator make_iterator(Type &value, Extra&&... extra) {
-    return make_iterator<Policy>(std::begin(value), std::end(value), extra...);
+          typename Type,
+          typename... Extra>
+iterator make_iterator(Type &value, Extra &&...extra) {
+    return make_iterator<Policy>(
+        std::begin(value), std::end(value), std::forward<Extra>(extra)...);
 }
 
 /// Makes an iterator over the keys (`.first`) of a stl map-like container supporting
 /// `std::begin()`/`std::end()`
 template <return_value_policy Policy = return_value_policy::reference_internal,
-          typename Type, typename... Extra> iterator make_key_iterator(Type &value, Extra&&... extra) {
-    return make_key_iterator<Policy>(std::begin(value), std::end(value), extra...);
+          typename Type,
+          typename... Extra>
+iterator make_key_iterator(Type &value, Extra &&...extra) {
+    return make_key_iterator<Policy>(
+        std::begin(value), std::end(value), std::forward<Extra>(extra)...);
+}
+
+/// Makes an iterator over the values (`.second`) of a stl map-like container supporting
+/// `std::begin()`/`std::end()`
+template <return_value_policy Policy = return_value_policy::reference_internal,
+          typename Type,
+          typename... Extra>
+iterator make_value_iterator(Type &value, Extra &&...extra) {
+    return make_value_iterator<Policy>(
+        std::begin(value), std::end(value), std::forward<Extra>(extra)...);
 }
 
-template <typename InputType, typename OutputType> void implicitly_convertible() {
+template <typename InputType, typename OutputType>
+void implicitly_convertible() {
     struct set_flag {
         bool &flag;
-        set_flag(bool &flag) : flag(flag) { flag = true; }
+        explicit set_flag(bool &flag_) : flag(flag_) { flag_ = true; }
         ~set_flag() { flag = false; }
     };
     auto implicit_caster = [](PyObject *obj, PyTypeObject *type) -> PyObject * {
         static bool currently_used = false;
-        if (currently_used) // implicit conversions are non-reentrant
+        if (currently_used) { // implicit conversions are non-reentrant
             return nullptr;
+        }
         set_flag flag_helper(currently_used);
-        if (!detail::make_caster<InputType>().load(obj, false))
+        if (!detail::make_caster<InputType>().load(obj, false)) {
             return nullptr;
+        }
         tuple args(1);
         args[0] = obj;
         PyObject *result = PyObject_Call((PyObject *) type, args.ptr(), nullptr);
-        if (result == nullptr)
+        if (result == nullptr) {
             PyErr_Clear();
+        }
         return result;
     };
 
-    if (auto tinfo = detail::get_type_info(typeid(OutputType)))
-        tinfo->implicit_conversions.push_back(implicit_caster);
-    else
+    if (auto *tinfo = detail::get_type_info(typeid(OutputType))) {
+        tinfo->implicit_conversions.emplace_back(std::move(implicit_caster));
+    } else {
         pybind11_fail("implicitly_convertible: Unable to find type " + type_id<OutputType>());
+    }
 }
 
-template <typename ExceptionTranslator>
-void register_exception_translator(ExceptionTranslator&& translator) {
+inline void register_exception_translator(ExceptionTranslator &&translator) {
     detail::get_internals().registered_exception_translators.push_front(
         std::forward<ExceptionTranslator>(translator));
 }
 
 /**
+ * Add a new module-local exception translator. Locally registered functions
+ * will be tried before any globally registered exception translators, which
+ * will only be invoked if the module-local handlers do not deal with
+ * the exception.
+ */
+inline void register_local_exception_translator(ExceptionTranslator &&translator) {
+    detail::get_local_internals().registered_exception_translators.push_front(
+        std::forward<ExceptionTranslator>(translator));
+}
+
+/**
  * Wrapper to generate a new Python exception type.
  *
  * This should only be used with PyErr_SetString for now.
  * It is not (yet) possible to use as a py::base.
  * Template type argument is reserved for future use.
  */
 template <typename type>
 class exception : public object {
 public:
     exception() = default;
-    exception(handle scope, const char *name, PyObject *base = PyExc_Exception) {
-        std::string full_name = scope.attr("__name__").cast<std::string>() +
-                                std::string(".") + name;
-        m_ptr = PyErr_NewException(const_cast<char *>(full_name.c_str()), base, NULL);
-        if (hasattr(scope, name))
+    exception(handle scope, const char *name, handle base = PyExc_Exception) {
+        std::string full_name
+            = scope.attr("__name__").cast<std::string>() + std::string(".") + name;
+        m_ptr = PyErr_NewException(const_cast<char *>(full_name.c_str()), base.ptr(), nullptr);
+        if (hasattr(scope, "__dict__") && scope.attr("__dict__").contains(name)) {
             pybind11_fail("Error during initialization: multiple incompatible "
-                          "definitions with name \"" + std::string(name) + "\"");
+                          "definitions with name \""
+                          + std::string(name) + "\"");
+        }
         scope.attr(name) = *this;
     }
 
     // Sets the current python exception to this exception object with the given message
-    void operator()(const char *message) {
-        PyErr_SetString(m_ptr, message);
-    }
+    void operator()(const char *message) { PyErr_SetString(m_ptr, message); }
 };
 
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(detail)
 // Returns a reference to a function-local static exception object used in the simple
 // register_exception approach below.  (It would be simpler to have the static local variable
 // directly in register_exception, but that makes clang <3.5 segfault - issue #1349).
 template <typename CppException>
-exception<CppException> &get_exception_object() { static exception<CppException> ex; return ex; }
-NAMESPACE_END(detail)
+exception<CppException> &get_exception_object() {
+    static exception<CppException> ex;
+    return ex;
+}
 
-/**
- * Registers a Python exception in `m` of the given `name` and installs an exception translator to
- * translate the C++ exception to the created Python exception using the exceptions what() method.
- * This is intended for simple exception translations; for more complex translation, register the
- * exception object and translator directly.
- */
+// Helper function for register_exception and register_local_exception
 template <typename CppException>
-exception<CppException> &register_exception(handle scope,
-                                            const char *name,
-                                            PyObject *base = PyExc_Exception) {
+exception<CppException> &
+register_exception_impl(handle scope, const char *name, handle base, bool isLocal) {
     auto &ex = detail::get_exception_object<CppException>();
-    if (!ex) ex = exception<CppException>(scope, name, base);
+    if (!ex) {
+        ex = exception<CppException>(scope, name, base);
+    }
+
+    auto register_func
+        = isLocal ? &register_local_exception_translator : &register_exception_translator;
 
-    register_exception_translator([](std::exception_ptr p) {
-        if (!p) return;
+    register_func([](std::exception_ptr p) {
+        if (!p) {
+            return;
+        }
         try {
             std::rethrow_exception(p);
         } catch (const CppException &e) {
             detail::get_exception_object<CppException>()(e.what());
         }
     });
     return ex;
 }
 
-NAMESPACE_BEGIN(detail)
-PYBIND11_NOINLINE inline void print(tuple args, dict kwargs) {
+PYBIND11_NAMESPACE_END(detail)
+
+/**
+ * Registers a Python exception in `m` of the given `name` and installs a translator to
+ * translate the C++ exception to the created Python exception using the what() method.
+ * This is intended for simple exception translations; for more complex translation, register the
+ * exception object and translator directly.
+ */
+template <typename CppException>
+exception<CppException> &
+register_exception(handle scope, const char *name, handle base = PyExc_Exception) {
+    return detail::register_exception_impl<CppException>(scope, name, base, false /* isLocal */);
+}
+
+/**
+ * Registers a Python exception in `m` of the given `name` and installs a translator to
+ * translate the C++ exception to the created Python exception using the what() method.
+ * This translator will only be used for exceptions that are thrown in this module and will be
+ * tried before global exception translators, including those registered with register_exception.
+ * This is intended for simple exception translations; for more complex translation, register the
+ * exception object and translator directly.
+ */
+template <typename CppException>
+exception<CppException> &
+register_local_exception(handle scope, const char *name, handle base = PyExc_Exception) {
+    return detail::register_exception_impl<CppException>(scope, name, base, true /* isLocal */);
+}
+
+PYBIND11_NAMESPACE_BEGIN(detail)
+PYBIND11_NOINLINE void print(const tuple &args, const dict &kwargs) {
     auto strings = tuple(args.size());
     for (size_t i = 0; i < args.size(); ++i) {
         strings[i] = str(args[i]);
     }
-    auto sep = kwargs.contains("sep") ? kwargs["sep"] : cast(" ");
-    auto line = sep.attr("join")(strings);
+    auto sep = kwargs.contains("sep") ? kwargs["sep"] : str(" ");
+    auto line = sep.attr("join")(std::move(strings));
 
     object file;
     if (kwargs.contains("file")) {
         file = kwargs["file"].cast<object>();
     } else {
         try {
-            file = module::import("sys").attr("stdout");
+            file = module_::import("sys").attr("stdout");
         } catch (const error_already_set &) {
             /* If print() is called from code that is executed as
                part of garbage collection during interpreter shutdown,
                importing 'sys' can fail. Give up rather than crashing the
                interpreter in this case. */
             return;
         }
     }
 
     auto write = file.attr("write");
-    write(line);
-    write(kwargs.contains("end") ? kwargs["end"] : cast("\n"));
+    write(std::move(line));
+    write(kwargs.contains("end") ? kwargs["end"] : str("\n"));
 
-    if (kwargs.contains("flush") && kwargs["flush"].cast<bool>())
+    if (kwargs.contains("flush") && kwargs["flush"].cast<bool>()) {
         file.attr("flush")();
+    }
 }
-NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(detail)
 
 template <return_value_policy policy = return_value_policy::automatic_reference, typename... Args>
 void print(Args &&...args) {
     auto c = detail::collect_arguments<policy>(std::forward<Args>(args)...);
     detail::print(c.args(), c.kwargs());
 }
 
-#if defined(WITH_THREAD) && !defined(PYPY_VERSION)
-
-/* The functions below essentially reproduce the PyGILState_* API using a RAII
- * pattern, but there are a few important differences:
- *
- * 1. When acquiring the GIL from an non-main thread during the finalization
- *    phase, the GILState API blindly terminates the calling thread, which
- *    is often not what is wanted. This API does not do this.
- *
- * 2. The gil_scoped_release function can optionally cut the relationship
- *    of a PyThreadState and its associated thread, which allows moving it to
- *    another thread (this is a fairly rare/advanced use case).
- *
- * 3. The reference count of an acquired thread state can be controlled. This
- *    can be handy to prevent cases where callbacks issued from an external
- *    thread would otherwise constantly construct and destroy thread state data
- *    structures.
- *
- * See the Python bindings of NanoGUI (http://github.com/wjakob/nanogui) for an
- * example which uses features 2 and 3 to migrate the Python thread of
- * execution to another thread (to run the event loop on the original thread,
- * in this case).
- */
-
-class gil_scoped_acquire {
-public:
-    PYBIND11_NOINLINE gil_scoped_acquire() {
-        auto const &internals = detail::get_internals();
-        tstate = (PyThreadState *) PYBIND11_TLS_GET_VALUE(internals.tstate);
-
-        if (!tstate) {
-            /* Check if the GIL was acquired using the PyGILState_* API instead (e.g. if
-               calling from a Python thread). Since we use a different key, this ensures
-               we don't create a new thread state and deadlock in PyEval_AcquireThread
-               below. Note we don't save this state with internals.tstate, since we don't
-               create it we would fail to clear it (its reference count should be > 0). */
-            tstate = PyGILState_GetThisThreadState();
-        }
-
-        if (!tstate) {
-            tstate = PyThreadState_New(internals.istate);
-            #if !defined(NDEBUG)
-                if (!tstate)
-                    pybind11_fail("scoped_acquire: could not create thread state!");
-            #endif
-            tstate->gilstate_counter = 0;
-            PYBIND11_TLS_REPLACE_VALUE(internals.tstate, tstate);
-        } else {
-            release = detail::get_thread_state_unchecked() != tstate;
-        }
-
-        if (release) {
-            /* Work around an annoying assertion in PyThreadState_Swap */
-            #if defined(Py_DEBUG)
-                PyInterpreterState *interp = tstate->interp;
-                tstate->interp = nullptr;
-            #endif
-            PyEval_AcquireThread(tstate);
-            #if defined(Py_DEBUG)
-                tstate->interp = interp;
-            #endif
-        }
-
-        inc_ref();
-    }
-
-    void inc_ref() {
-        ++tstate->gilstate_counter;
-    }
-
-    PYBIND11_NOINLINE void dec_ref() {
-        --tstate->gilstate_counter;
-        #if !defined(NDEBUG)
-            if (detail::get_thread_state_unchecked() != tstate)
-                pybind11_fail("scoped_acquire::dec_ref(): thread state must be current!");
-            if (tstate->gilstate_counter < 0)
-                pybind11_fail("scoped_acquire::dec_ref(): reference count underflow!");
-        #endif
-        if (tstate->gilstate_counter == 0) {
-            #if !defined(NDEBUG)
-                if (!release)
-                    pybind11_fail("scoped_acquire::dec_ref(): internal error!");
-            #endif
-            PyThreadState_Clear(tstate);
-            PyThreadState_DeleteCurrent();
-            PYBIND11_TLS_DELETE_VALUE(detail::get_internals().tstate);
-            release = false;
-        }
-    }
-
-    PYBIND11_NOINLINE ~gil_scoped_acquire() {
-        dec_ref();
-        if (release)
-           PyEval_SaveThread();
-    }
-private:
-    PyThreadState *tstate = nullptr;
-    bool release = true;
-};
-
-class gil_scoped_release {
-public:
-    explicit gil_scoped_release(bool disassoc = false) : disassoc(disassoc) {
-        // `get_internals()` must be called here unconditionally in order to initialize
-        // `internals.tstate` for subsequent `gil_scoped_acquire` calls. Otherwise, an
-        // initialization race could occur as multiple threads try `gil_scoped_acquire`.
-        const auto &internals = detail::get_internals();
-        tstate = PyEval_SaveThread();
-        if (disassoc) {
-            auto key = internals.tstate;
-            PYBIND11_TLS_DELETE_VALUE(key);
-        }
-    }
-    ~gil_scoped_release() {
-        if (!tstate)
-            return;
-        PyEval_RestoreThread(tstate);
-        if (disassoc) {
-            auto key = detail::get_internals().tstate;
-            PYBIND11_TLS_REPLACE_VALUE(key, tstate);
-        }
-    }
-private:
-    PyThreadState *tstate;
-    bool disassoc;
-};
-#elif defined(PYPY_VERSION)
-class gil_scoped_acquire {
-    PyGILState_STATE state;
-public:
-    gil_scoped_acquire() { state = PyGILState_Ensure(); }
-    ~gil_scoped_acquire() { PyGILState_Release(state); }
-};
-
-class gil_scoped_release {
-    PyThreadState *state;
-public:
-    gil_scoped_release() { state = PyEval_SaveThread(); }
-    ~gil_scoped_release() { PyEval_RestoreThread(state); }
-};
-#else
-class gil_scoped_acquire { };
-class gil_scoped_release { };
-#endif
+inline void
+error_already_set::m_fetched_error_deleter(detail::error_fetch_and_normalize *raw_ptr) {
+    gil_scoped_acquire gil;
+    error_scope scope;
+    delete raw_ptr;
+}
 
-error_already_set::~error_already_set() {
-    if (m_type) {
-        gil_scoped_acquire gil;
-        error_scope scope;
-        m_type.release().dec_ref();
-        m_value.release().dec_ref();
-        m_trace.release().dec_ref();
-    }
+inline const char *error_already_set::what() const noexcept {
+    gil_scoped_acquire gil;
+    error_scope scope;
+    return m_fetched_error->error_string().c_str();
 }
 
-inline function get_type_overload(const void *this_ptr, const detail::type_info *this_type, const char *name)  {
-    handle self = detail::get_object_handle(this_ptr, this_type);
-    if (!self)
+PYBIND11_NAMESPACE_BEGIN(detail)
+
+inline function
+get_type_override(const void *this_ptr, const type_info *this_type, const char *name) {
+    handle self = get_object_handle(this_ptr, this_type);
+    if (!self) {
         return function();
-    handle type = self.get_type();
+    }
+    handle type = type::handle_of(self);
     auto key = std::make_pair(type.ptr(), name);
 
-    /* Cache functions that aren't overloaded in Python to avoid
+    /* Cache functions that aren't overridden in Python to avoid
        many costly Python dictionary lookups below */
-    auto &cache = detail::get_internals().inactive_overload_cache;
-    if (cache.find(key) != cache.end())
+    auto &cache = get_internals().inactive_override_cache;
+    if (cache.find(key) != cache.end()) {
         return function();
+    }
 
-    function overload = getattr(self, name, function());
-    if (overload.is_cpp_function()) {
-        cache.insert(key);
+    function override = getattr(self, name, function());
+    if (override.is_cpp_function()) {
+        cache.insert(std::move(key));
         return function();
     }
 
     /* Don't call dispatch code if invoked from overridden function.
        Unfortunately this doesn't work on PyPy. */
 #if !defined(PYPY_VERSION)
+#    if PY_VERSION_HEX >= 0x03090000
+    PyFrameObject *frame = PyThreadState_GetFrame(PyThreadState_Get());
+    if (frame != nullptr) {
+        PyCodeObject *f_code = PyFrame_GetCode(frame);
+        // f_code is guaranteed to not be NULL
+        if ((std::string) str(f_code->co_name) == name && f_code->co_argcount > 0) {
+            PyObject *locals = PyEval_GetLocals();
+            if (locals != nullptr) {
+                PyObject *co_varnames = PyObject_GetAttrString((PyObject *) f_code, "co_varnames");
+                PyObject *self_arg = PyTuple_GET_ITEM(co_varnames, 0);
+                Py_DECREF(co_varnames);
+                PyObject *self_caller = dict_getitem(locals, self_arg);
+                if (self_caller == self.ptr()) {
+                    Py_DECREF(f_code);
+                    Py_DECREF(frame);
+                    return function();
+                }
+            }
+        }
+        Py_DECREF(f_code);
+        Py_DECREF(frame);
+    }
+#    else
     PyFrameObject *frame = PyThreadState_Get()->frame;
-    if (frame && (std::string) str(frame->f_code->co_name) == name &&
-        frame->f_code->co_argcount > 0) {
+    if (frame != nullptr && (std::string) str(frame->f_code->co_name) == name
+        && frame->f_code->co_argcount > 0) {
         PyFrame_FastToLocals(frame);
-        PyObject *self_caller = PyDict_GetItem(
-            frame->f_locals, PyTuple_GET_ITEM(frame->f_code->co_varnames, 0));
-        if (self_caller == self.ptr())
+        PyObject *self_caller
+            = dict_getitem(frame->f_locals, PyTuple_GET_ITEM(frame->f_code->co_varnames, 0));
+        if (self_caller == self.ptr()) {
             return function();
+        }
     }
+#    endif
+
 #else
     /* PyPy currently doesn't provide a detailed cpyext emulation of
        frame objects, so we have to emulate this using Python. This
        is going to be slow..*/
-    dict d; d["self"] = self; d["name"] = pybind11::str(name);
-    PyObject *result = PyRun_String(
-        "import inspect\n"
-        "frame = inspect.currentframe()\n"
-        "if frame is not None:\n"
-        "    frame = frame.f_back\n"
-        "    if frame is not None and str(frame.f_code.co_name) == name and "
-        "frame.f_code.co_argcount > 0:\n"
-        "        self_caller = frame.f_locals[frame.f_code.co_varnames[0]]\n"
-        "        if self_caller == self:\n"
-        "            self = None\n",
-        Py_file_input, d.ptr(), d.ptr());
+    dict d;
+    d["self"] = self;
+    d["name"] = pybind11::str(name);
+    PyObject *result
+        = PyRun_String("import inspect\n"
+                       "frame = inspect.currentframe()\n"
+                       "if frame is not None:\n"
+                       "    frame = frame.f_back\n"
+                       "    if frame is not None and str(frame.f_code.co_name) == name and "
+                       "frame.f_code.co_argcount > 0:\n"
+                       "        self_caller = frame.f_locals[frame.f_code.co_varnames[0]]\n"
+                       "        if self_caller == self:\n"
+                       "            self = None\n",
+                       Py_file_input,
+                       d.ptr(),
+                       d.ptr());
     if (result == nullptr)
         throw error_already_set();
+    Py_DECREF(result);
     if (d["self"].is_none())
         return function();
-    Py_DECREF(result);
 #endif
 
-    return overload;
+    return override;
 }
+PYBIND11_NAMESPACE_END(detail)
 
 /** \rst
-  Try to retrieve a python method by the provided name from the instance pointed to by the this_ptr.
+  Try to retrieve a python method by the provided name from the instance pointed to by the
+  this_ptr.
 
-  :this_ptr: The pointer to the object the overload should be retrieved for. This should be the first
-                   non-trampoline class encountered in the inheritance chain.
-  :name: The name of the overloaded Python method to retrieve.
+  :this_ptr: The pointer to the object the overridden method should be retrieved for. This should
+             be the first non-trampoline class encountered in the inheritance chain.
+  :name: The name of the overridden Python method to retrieve.
   :return: The Python method by this name from the object or an empty function wrapper.
  \endrst */
-template <class T> function get_overload(const T *this_ptr, const char *name) {
-    auto tinfo = detail::get_type_info(typeid(T));
-    return tinfo ? get_type_overload(this_ptr, tinfo, name) : function();
-}
-
-#define PYBIND11_OVERLOAD_INT(ret_type, cname, name, ...) { \
-        pybind11::gil_scoped_acquire gil; \
-        pybind11::function overload = pybind11::get_overload(static_cast<const cname *>(this), name); \
-        if (overload) { \
-            auto o = overload(__VA_ARGS__); \
-            if (pybind11::detail::cast_is_temporary_value_reference<ret_type>::value) { \
-                static pybind11::detail::overload_caster_t<ret_type> caster; \
-                return pybind11::detail::cast_ref<ret_type>(std::move(o), caster); \
-            } \
-            else return pybind11::detail::cast_safe<ret_type>(std::move(o)); \
-        } \
-    }
+template <class T>
+function get_override(const T *this_ptr, const char *name) {
+    auto *tinfo = detail::get_type_info(typeid(T));
+    return tinfo ? detail::get_type_override(this_ptr, tinfo, name) : function();
+}
+
+#define PYBIND11_OVERRIDE_IMPL(ret_type, cname, name, ...)                                        \
+    do {                                                                                          \
+        pybind11::gil_scoped_acquire gil;                                                         \
+        pybind11::function override                                                               \
+            = pybind11::get_override(static_cast<const cname *>(this), name);                     \
+        if (override) {                                                                           \
+            auto o = override(__VA_ARGS__);                                                       \
+            if (pybind11::detail::cast_is_temporary_value_reference<ret_type>::value) {           \
+                static pybind11::detail::override_caster_t<ret_type> caster;                      \
+                return pybind11::detail::cast_ref<ret_type>(std::move(o), caster);                \
+            }                                                                                     \
+            return pybind11::detail::cast_safe<ret_type>(std::move(o));                           \
+        }                                                                                         \
+    } while (false)
 
 /** \rst
-    Macro to populate the virtual method in the trampoline class. This macro tries to look up a method named 'fn'
-    from the Python side, deals with the :ref:`gil` and necessary argument conversions to call this method and return
-    the appropriate type. See :ref:`overriding_virtuals` for more information. This macro should be used when the method
+    Macro to populate the virtual method in the trampoline class. This macro tries to look up a
+    method named 'fn' from the Python side, deals with the :ref:`gil` and necessary argument
+    conversions to call this method and return the appropriate type.
+    See :ref:`overriding_virtuals` for more information. This macro should be used when the method
     name in C is not the same as the method name in Python. For example with `__str__`.
 
     .. code-block:: cpp
 
       std::string toString() override {
-        PYBIND11_OVERLOAD_NAME(
+        PYBIND11_OVERRIDE_NAME(
             std::string, // Return type (ret_type)
             Animal,      // Parent class (cname)
-            toString,    // Name of function in C++ (name)
-            "__str__",   // Name of method in Python (fn)
+            "__str__",   // Name of method in Python (name)
+            toString,    // Name of function in C++ (fn)
         );
       }
 \endrst */
-#define PYBIND11_OVERLOAD_NAME(ret_type, cname, name, fn, ...) \
-    PYBIND11_OVERLOAD_INT(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, __VA_ARGS__) \
-    return cname::fn(__VA_ARGS__)
+#define PYBIND11_OVERRIDE_NAME(ret_type, cname, name, fn, ...)                                    \
+    do {                                                                                          \
+        PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, __VA_ARGS__); \
+        return cname::fn(__VA_ARGS__);                                                            \
+    } while (false)
 
 /** \rst
-    Macro for pure virtual functions, this function is identical to :c:macro:`PYBIND11_OVERLOAD_NAME`, except that it
-    throws if no overload can be found.
+    Macro for pure virtual functions, this function is identical to
+    :c:macro:`PYBIND11_OVERRIDE_NAME`, except that it throws if no override can be found.
 \endrst */
-#define PYBIND11_OVERLOAD_PURE_NAME(ret_type, cname, name, fn, ...) \
-    PYBIND11_OVERLOAD_INT(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, __VA_ARGS__) \
-    pybind11::pybind11_fail("Tried to call pure virtual function \"" PYBIND11_STRINGIFY(cname) "::" name "\"");
+#define PYBIND11_OVERRIDE_PURE_NAME(ret_type, cname, name, fn, ...)                               \
+    do {                                                                                          \
+        PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, __VA_ARGS__); \
+        pybind11::pybind11_fail(                                                                  \
+            "Tried to call pure virtual function \"" PYBIND11_STRINGIFY(cname) "::" name "\"");   \
+    } while (false)
 
 /** \rst
-    Macro to populate the virtual method in the trampoline class. This macro tries to look up the method
-    from the Python side, deals with the :ref:`gil` and necessary argument conversions to call this method and return
-    the appropriate type. This macro should be used if the method name in C and in Python are identical.
+    Macro to populate the virtual method in the trampoline class. This macro tries to look up the
+    method from the Python side, deals with the :ref:`gil` and necessary argument conversions to
+    call this method and return the appropriate type. This macro should be used if the method name
+    in C and in Python are identical.
     See :ref:`overriding_virtuals` for more information.
 
     .. code-block:: cpp
 
       class PyAnimal : public Animal {
       public:
           // Inherit the constructors
           using Animal::Animal;
 
           // Trampoline (need one for each virtual function)
           std::string go(int n_times) override {
-              PYBIND11_OVERLOAD_PURE(
+              PYBIND11_OVERRIDE_PURE(
                   std::string, // Return type (ret_type)
                   Animal,      // Parent class (cname)
                   go,          // Name of function in C++ (must match Python name) (fn)
                   n_times      // Argument(s) (...)
               );
           }
       };
 \endrst */
-#define PYBIND11_OVERLOAD(ret_type, cname, fn, ...) \
-    PYBIND11_OVERLOAD_NAME(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), #fn, fn, __VA_ARGS__)
+#define PYBIND11_OVERRIDE(ret_type, cname, fn, ...)                                               \
+    PYBIND11_OVERRIDE_NAME(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), #fn, fn, __VA_ARGS__)
 
 /** \rst
-    Macro for pure virtual functions, this function is identical to :c:macro:`PYBIND11_OVERLOAD`, except that it throws
-    if no overload can be found.
+    Macro for pure virtual functions, this function is identical to :c:macro:`PYBIND11_OVERRIDE`,
+    except that it throws if no override can be found.
 \endrst */
-#define PYBIND11_OVERLOAD_PURE(ret_type, cname, fn, ...) \
-    PYBIND11_OVERLOAD_PURE_NAME(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), #fn, fn, __VA_ARGS__)
-
-NAMESPACE_END(PYBIND11_NAMESPACE)
+#define PYBIND11_OVERRIDE_PURE(ret_type, cname, fn, ...)                                          \
+    PYBIND11_OVERRIDE_PURE_NAME(                                                                  \
+        PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), #fn, fn, __VA_ARGS__)
+
+// Deprecated versions
+
+PYBIND11_DEPRECATED("get_type_overload has been deprecated")
+inline function
+get_type_overload(const void *this_ptr, const detail::type_info *this_type, const char *name) {
+    return detail::get_type_override(this_ptr, this_type, name);
+}
+
+template <class T>
+inline function get_overload(const T *this_ptr, const char *name) {
+    return get_override(this_ptr, name);
+}
+
+#define PYBIND11_OVERLOAD_INT(ret_type, cname, name, ...)                                         \
+    PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, __VA_ARGS__)
+#define PYBIND11_OVERLOAD_NAME(ret_type, cname, name, fn, ...)                                    \
+    PYBIND11_OVERRIDE_NAME(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, fn, __VA_ARGS__)
+#define PYBIND11_OVERLOAD_PURE_NAME(ret_type, cname, name, fn, ...)                               \
+    PYBIND11_OVERRIDE_PURE_NAME(                                                                  \
+        PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, fn, __VA_ARGS__);
+#define PYBIND11_OVERLOAD(ret_type, cname, fn, ...)                                               \
+    PYBIND11_OVERRIDE(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), fn, __VA_ARGS__)
+#define PYBIND11_OVERLOAD_PURE(ret_type, cname, fn, ...)                                          \
+    PYBIND11_OVERRIDE_PURE(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), fn, __VA_ARGS__);
 
-#if defined(_MSC_VER) && !defined(__INTEL_COMPILER)
-#  pragma warning(pop)
-#elif defined(__GNUG__) && !defined(__clang__)
-#  pragma GCC diagnostic pop
-#endif
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/stl.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/stl.h`

 * *Files 10% similar despite different names*

```diff
@@ -6,117 +6,133 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "pybind11.h"
-#include <set>
-#include <unordered_set>
+#include "detail/common.h"
+
+#include <deque>
+#include <list>
 #include <map>
+#include <ostream>
+#include <set>
 #include <unordered_map>
-#include <iostream>
-#include <list>
-#include <deque>
+#include <unordered_set>
 #include <valarray>
 
-#if defined(_MSC_VER)
-#pragma warning(push)
-#pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#endif
-
-#ifdef __has_include
-// std::optional (but including it in c++14 mode isn't allowed)
-#  if defined(PYBIND11_CPP17) && __has_include(<optional>)
+// See `detail/common.h` for implementation of these guards.
+#if defined(PYBIND11_HAS_OPTIONAL)
 #    include <optional>
-#    define PYBIND11_HAS_OPTIONAL 1
-#  endif
-// std::experimental::optional (but not allowed in c++11 mode)
-#  if defined(PYBIND11_CPP14) && (__has_include(<experimental/optional>) && \
-                                 !__has_include(<optional>))
+#elif defined(PYBIND11_HAS_EXP_OPTIONAL)
 #    include <experimental/optional>
-#    define PYBIND11_HAS_EXP_OPTIONAL 1
-#  endif
-// std::variant
-#  if defined(PYBIND11_CPP17) && __has_include(<variant>)
+#endif
+
+#if defined(PYBIND11_HAS_VARIANT)
 #    include <variant>
-#    define PYBIND11_HAS_VARIANT 1
-#  endif
-#elif defined(_MSC_VER) && defined(PYBIND11_CPP17)
-#  include <optional>
-#  include <variant>
-#  define PYBIND11_HAS_OPTIONAL 1
-#  define PYBIND11_HAS_VARIANT 1
 #endif
 
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_BEGIN(detail)
 
 /// Extracts an const lvalue reference or rvalue reference for U based on the type of T (e.g. for
 /// forwarding a container element).  Typically used indirect via forwarded_type(), below.
 template <typename T, typename U>
-using forwarded_type = conditional_t<
-    std::is_lvalue_reference<T>::value, remove_reference_t<U> &, remove_reference_t<U> &&>;
+using forwarded_type = conditional_t<std::is_lvalue_reference<T>::value,
+                                     remove_reference_t<U> &,
+                                     remove_reference_t<U> &&>;
 
 /// Forwards a value U as rvalue or lvalue according to whether T is rvalue or lvalue; typically
 /// used for forwarding a container's elements.
 template <typename T, typename U>
-forwarded_type<T, U> forward_like(U &&u) {
+constexpr forwarded_type<T, U> forward_like(U &&u) {
     return std::forward<detail::forwarded_type<T, U>>(std::forward<U>(u));
 }
 
-template <typename Type, typename Key> struct set_caster {
+// Checks if a container has a STL style reserve method.
+// This will only return true for a `reserve()` with a `void` return.
+template <typename C>
+using has_reserve_method = std::is_same<decltype(std::declval<C>().reserve(0)), void>;
+
+template <typename Type, typename Key>
+struct set_caster {
     using type = Type;
     using key_conv = make_caster<Key>;
 
+private:
+    template <typename T = Type, enable_if_t<has_reserve_method<T>::value, int> = 0>
+    void reserve_maybe(const anyset &s, Type *) {
+        value.reserve(s.size());
+    }
+    void reserve_maybe(const anyset &, void *) {}
+
+public:
     bool load(handle src, bool convert) {
-        if (!isinstance<pybind11::set>(src))
+        if (!isinstance<anyset>(src)) {
             return false;
-        auto s = reinterpret_borrow<pybind11::set>(src);
+        }
+        auto s = reinterpret_borrow<anyset>(src);
         value.clear();
+        reserve_maybe(s, &value);
         for (auto entry : s) {
             key_conv conv;
-            if (!conv.load(entry, convert))
+            if (!conv.load(entry, convert)) {
                 return false;
+            }
             value.insert(cast_op<Key &&>(std::move(conv)));
         }
         return true;
     }
 
     template <typename T>
     static handle cast(T &&src, return_value_policy policy, handle parent) {
-        if (!std::is_lvalue_reference<T>::value)
+        if (!std::is_lvalue_reference<T>::value) {
             policy = return_value_policy_override<Key>::policy(policy);
+        }
         pybind11::set s;
         for (auto &&value : src) {
-            auto value_ = reinterpret_steal<object>(key_conv::cast(forward_like<T>(value), policy, parent));
-            if (!value_ || !s.add(value_))
+            auto value_ = reinterpret_steal<object>(
+                key_conv::cast(detail::forward_like<T>(value), policy, parent));
+            if (!value_ || !s.add(std::move(value_))) {
                 return handle();
+            }
         }
         return s.release();
     }
 
-    PYBIND11_TYPE_CASTER(type, _("Set[") + key_conv::name + _("]"));
+    PYBIND11_TYPE_CASTER(type, const_name("Set[") + key_conv::name + const_name("]"));
 };
 
-template <typename Type, typename Key, typename Value> struct map_caster {
-    using key_conv   = make_caster<Key>;
+template <typename Type, typename Key, typename Value>
+struct map_caster {
+    using key_conv = make_caster<Key>;
     using value_conv = make_caster<Value>;
 
+private:
+    template <typename T = Type, enable_if_t<has_reserve_method<T>::value, int> = 0>
+    void reserve_maybe(const dict &d, Type *) {
+        value.reserve(d.size());
+    }
+    void reserve_maybe(const dict &, void *) {}
+
+public:
     bool load(handle src, bool convert) {
-        if (!isinstance<dict>(src))
+        if (!isinstance<dict>(src)) {
             return false;
+        }
         auto d = reinterpret_borrow<dict>(src);
         value.clear();
+        reserve_maybe(d, &value);
         for (auto it : d) {
             key_conv kconv;
             value_conv vconv;
-            if (!kconv.load(it.first.ptr(), convert) ||
-                !vconv.load(it.second.ptr(), convert))
+            if (!kconv.load(it.first.ptr(), convert) || !vconv.load(it.second.ptr(), convert)) {
                 return false;
+            }
             value.emplace(cast_op<Key &&>(std::move(kconv)), cast_op<Value &&>(std::move(vconv)));
         }
         return true;
     }
 
     template <typename T>
     static handle cast(T &&src, return_value_policy policy, handle parent) {
@@ -124,186 +140,224 @@
         return_value_policy policy_key = policy;
         return_value_policy policy_value = policy;
         if (!std::is_lvalue_reference<T>::value) {
             policy_key = return_value_policy_override<Key>::policy(policy_key);
             policy_value = return_value_policy_override<Value>::policy(policy_value);
         }
         for (auto &&kv : src) {
-            auto key = reinterpret_steal<object>(key_conv::cast(forward_like<T>(kv.first), policy_key, parent));
-            auto value = reinterpret_steal<object>(value_conv::cast(forward_like<T>(kv.second), policy_value, parent));
-            if (!key || !value)
+            auto key = reinterpret_steal<object>(
+                key_conv::cast(detail::forward_like<T>(kv.first), policy_key, parent));
+            auto value = reinterpret_steal<object>(
+                value_conv::cast(detail::forward_like<T>(kv.second), policy_value, parent));
+            if (!key || !value) {
                 return handle();
-            d[key] = value;
+            }
+            d[std::move(key)] = std::move(value);
         }
         return d.release();
     }
 
-    PYBIND11_TYPE_CASTER(Type, _("Dict[") + key_conv::name + _(", ") + value_conv::name + _("]"));
+    PYBIND11_TYPE_CASTER(Type,
+                         const_name("Dict[") + key_conv::name + const_name(", ") + value_conv::name
+                             + const_name("]"));
 };
 
-template <typename Type, typename Value> struct list_caster {
+template <typename Type, typename Value>
+struct list_caster {
     using value_conv = make_caster<Value>;
 
     bool load(handle src, bool convert) {
-        if (!isinstance<sequence>(src) || isinstance<str>(src))
+        if (!isinstance<sequence>(src) || isinstance<bytes>(src) || isinstance<str>(src)) {
             return false;
+        }
         auto s = reinterpret_borrow<sequence>(src);
         value.clear();
         reserve_maybe(s, &value);
         for (auto it : s) {
             value_conv conv;
-            if (!conv.load(it, convert))
+            if (!conv.load(it, convert)) {
                 return false;
+            }
             value.push_back(cast_op<Value &&>(std::move(conv)));
         }
         return true;
     }
 
 private:
-    template <typename T = Type,
-              enable_if_t<std::is_same<decltype(std::declval<T>().reserve(0)), void>::value, int> = 0>
-    void reserve_maybe(sequence s, Type *) { value.reserve(s.size()); }
-    void reserve_maybe(sequence, void *) { }
+    template <typename T = Type, enable_if_t<has_reserve_method<T>::value, int> = 0>
+    void reserve_maybe(const sequence &s, Type *) {
+        value.reserve(s.size());
+    }
+    void reserve_maybe(const sequence &, void *) {}
 
 public:
     template <typename T>
     static handle cast(T &&src, return_value_policy policy, handle parent) {
-        if (!std::is_lvalue_reference<T>::value)
+        if (!std::is_lvalue_reference<T>::value) {
             policy = return_value_policy_override<Value>::policy(policy);
+        }
         list l(src.size());
-        size_t index = 0;
+        ssize_t index = 0;
         for (auto &&value : src) {
-            auto value_ = reinterpret_steal<object>(value_conv::cast(forward_like<T>(value), policy, parent));
-            if (!value_)
+            auto value_ = reinterpret_steal<object>(
+                value_conv::cast(detail::forward_like<T>(value), policy, parent));
+            if (!value_) {
                 return handle();
-            PyList_SET_ITEM(l.ptr(), (ssize_t) index++, value_.release().ptr()); // steals a reference
+            }
+            PyList_SET_ITEM(l.ptr(), index++, value_.release().ptr()); // steals a reference
         }
         return l.release();
     }
 
-    PYBIND11_TYPE_CASTER(Type, _("List[") + value_conv::name + _("]"));
+    PYBIND11_TYPE_CASTER(Type, const_name("List[") + value_conv::name + const_name("]"));
 };
 
-template <typename Type, typename Alloc> struct type_caster<std::vector<Type, Alloc>>
- : list_caster<std::vector<Type, Alloc>, Type> { };
+template <typename Type, typename Alloc>
+struct type_caster<std::vector<Type, Alloc>> : list_caster<std::vector<Type, Alloc>, Type> {};
 
-template <typename Type, typename Alloc> struct type_caster<std::deque<Type, Alloc>>
- : list_caster<std::deque<Type, Alloc>, Type> { };
+template <typename Type, typename Alloc>
+struct type_caster<std::deque<Type, Alloc>> : list_caster<std::deque<Type, Alloc>, Type> {};
 
-template <typename Type, typename Alloc> struct type_caster<std::list<Type, Alloc>>
- : list_caster<std::list<Type, Alloc>, Type> { };
+template <typename Type, typename Alloc>
+struct type_caster<std::list<Type, Alloc>> : list_caster<std::list<Type, Alloc>, Type> {};
 
-template <typename ArrayType, typename Value, bool Resizable, size_t Size = 0> struct array_caster {
+template <typename ArrayType, typename Value, bool Resizable, size_t Size = 0>
+struct array_caster {
     using value_conv = make_caster<Value>;
 
 private:
     template <bool R = Resizable>
     bool require_size(enable_if_t<R, size_t> size) {
-        if (value.size() != size)
+        if (value.size() != size) {
             value.resize(size);
+        }
         return true;
     }
     template <bool R = Resizable>
     bool require_size(enable_if_t<!R, size_t> size) {
         return size == Size;
     }
 
 public:
     bool load(handle src, bool convert) {
-        if (!isinstance<sequence>(src))
+        if (!isinstance<sequence>(src)) {
             return false;
+        }
         auto l = reinterpret_borrow<sequence>(src);
-        if (!require_size(l.size()))
+        if (!require_size(l.size())) {
             return false;
+        }
         size_t ctr = 0;
         for (auto it : l) {
             value_conv conv;
-            if (!conv.load(it, convert))
+            if (!conv.load(it, convert)) {
                 return false;
+            }
             value[ctr++] = cast_op<Value &&>(std::move(conv));
         }
         return true;
     }
 
     template <typename T>
     static handle cast(T &&src, return_value_policy policy, handle parent) {
         list l(src.size());
-        size_t index = 0;
+        ssize_t index = 0;
         for (auto &&value : src) {
-            auto value_ = reinterpret_steal<object>(value_conv::cast(forward_like<T>(value), policy, parent));
-            if (!value_)
+            auto value_ = reinterpret_steal<object>(
+                value_conv::cast(detail::forward_like<T>(value), policy, parent));
+            if (!value_) {
                 return handle();
-            PyList_SET_ITEM(l.ptr(), (ssize_t) index++, value_.release().ptr()); // steals a reference
+            }
+            PyList_SET_ITEM(l.ptr(), index++, value_.release().ptr()); // steals a reference
         }
         return l.release();
     }
 
-    PYBIND11_TYPE_CASTER(ArrayType, _("List[") + value_conv::name + _<Resizable>(_(""), _("[") + _<Size>() + _("]")) + _("]"));
+    PYBIND11_TYPE_CASTER(ArrayType,
+                         const_name("List[") + value_conv::name
+                             + const_name<Resizable>(const_name(""),
+                                                     const_name("[") + const_name<Size>()
+                                                         + const_name("]"))
+                             + const_name("]"));
 };
 
-template <typename Type, size_t Size> struct type_caster<std::array<Type, Size>>
- : array_caster<std::array<Type, Size>, Type, false, Size> { };
-
-template <typename Type> struct type_caster<std::valarray<Type>>
- : array_caster<std::valarray<Type>, Type, true> { };
-
-template <typename Key, typename Compare, typename Alloc> struct type_caster<std::set<Key, Compare, Alloc>>
-  : set_caster<std::set<Key, Compare, Alloc>, Key> { };
-
-template <typename Key, typename Hash, typename Equal, typename Alloc> struct type_caster<std::unordered_set<Key, Hash, Equal, Alloc>>
-  : set_caster<std::unordered_set<Key, Hash, Equal, Alloc>, Key> { };
-
-template <typename Key, typename Value, typename Compare, typename Alloc> struct type_caster<std::map<Key, Value, Compare, Alloc>>
-  : map_caster<std::map<Key, Value, Compare, Alloc>, Key, Value> { };
-
-template <typename Key, typename Value, typename Hash, typename Equal, typename Alloc> struct type_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>>
-  : map_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>, Key, Value> { };
+template <typename Type, size_t Size>
+struct type_caster<std::array<Type, Size>>
+    : array_caster<std::array<Type, Size>, Type, false, Size> {};
+
+template <typename Type>
+struct type_caster<std::valarray<Type>> : array_caster<std::valarray<Type>, Type, true> {};
+
+template <typename Key, typename Compare, typename Alloc>
+struct type_caster<std::set<Key, Compare, Alloc>>
+    : set_caster<std::set<Key, Compare, Alloc>, Key> {};
+
+template <typename Key, typename Hash, typename Equal, typename Alloc>
+struct type_caster<std::unordered_set<Key, Hash, Equal, Alloc>>
+    : set_caster<std::unordered_set<Key, Hash, Equal, Alloc>, Key> {};
+
+template <typename Key, typename Value, typename Compare, typename Alloc>
+struct type_caster<std::map<Key, Value, Compare, Alloc>>
+    : map_caster<std::map<Key, Value, Compare, Alloc>, Key, Value> {};
+
+template <typename Key, typename Value, typename Hash, typename Equal, typename Alloc>
+struct type_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>>
+    : map_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>, Key, Value> {};
 
 // This type caster is intended to be used for std::optional and std::experimental::optional
-template<typename T> struct optional_caster {
-    using value_conv = make_caster<typename T::value_type>;
+template <typename Type, typename Value = typename Type::value_type>
+struct optional_caster {
+    using value_conv = make_caster<Value>;
 
-    template <typename T_>
-    static handle cast(T_ &&src, return_value_policy policy, handle parent) {
-        if (!src)
-            return none().inc_ref();
-        policy = return_value_policy_override<typename T::value_type>::policy(policy);
-        return value_conv::cast(*std::forward<T_>(src), policy, parent);
+    template <typename T>
+    static handle cast(T &&src, return_value_policy policy, handle parent) {
+        if (!src) {
+            return none().release();
+        }
+        if (!std::is_lvalue_reference<T>::value) {
+            policy = return_value_policy_override<Value>::policy(policy);
+        }
+        // NOLINTNEXTLINE(bugprone-unchecked-optional-access)
+        return value_conv::cast(*std::forward<T>(src), policy, parent);
     }
 
     bool load(handle src, bool convert) {
         if (!src) {
             return false;
-        } else if (src.is_none()) {
-            return true;  // default-constructed value is already empty
+        }
+        if (src.is_none()) {
+            return true; // default-constructed value is already empty
         }
         value_conv inner_caster;
-        if (!inner_caster.load(src, convert))
+        if (!inner_caster.load(src, convert)) {
             return false;
+        }
 
-        value.emplace(cast_op<typename T::value_type &&>(std::move(inner_caster)));
+        value.emplace(cast_op<Value &&>(std::move(inner_caster)));
         return true;
     }
 
-    PYBIND11_TYPE_CASTER(T, _("Optional[") + value_conv::name + _("]"));
+    PYBIND11_TYPE_CASTER(Type, const_name("Optional[") + value_conv::name + const_name("]"));
 };
 
-#if PYBIND11_HAS_OPTIONAL
-template<typename T> struct type_caster<std::optional<T>>
-    : public optional_caster<std::optional<T>> {};
+#if defined(PYBIND11_HAS_OPTIONAL)
+template <typename T>
+struct type_caster<std::optional<T>> : public optional_caster<std::optional<T>> {};
 
-template<> struct type_caster<std::nullopt_t>
-    : public void_caster<std::nullopt_t> {};
+template <>
+struct type_caster<std::nullopt_t> : public void_caster<std::nullopt_t> {};
 #endif
 
-#if PYBIND11_HAS_EXP_OPTIONAL
-template<typename T> struct type_caster<std::experimental::optional<T>>
+#if defined(PYBIND11_HAS_EXP_OPTIONAL)
+template <typename T>
+struct type_caster<std::experimental::optional<T>>
     : public optional_caster<std::experimental::optional<T>> {};
 
-template<> struct type_caster<std::experimental::nullopt_t>
+template <>
+struct type_caster<std::experimental::nullopt_t>
     : public void_caster<std::experimental::nullopt_t> {};
 #endif
 
 /// Visit a variant and cast any found type to Python
 struct variant_caster_visitor {
     return_value_policy policy;
     handle parent;
@@ -316,71 +370,78 @@
     }
 };
 
 /// Helper class which abstracts away variant's `visit` function. `std::variant` and similar
 /// `namespace::variant` types which provide a `namespace::visit()` function are handled here
 /// automatically using argument-dependent lookup. Users can provide specializations for other
 /// variant-like classes, e.g. `boost::variant` and `boost::apply_visitor`.
-template <template<typename...> class Variant>
+template <template <typename...> class Variant>
 struct visit_helper {
     template <typename... Args>
     static auto call(Args &&...args) -> decltype(visit(std::forward<Args>(args)...)) {
         return visit(std::forward<Args>(args)...);
     }
 };
 
 /// Generic variant caster
-template <typename Variant> struct variant_caster;
+template <typename Variant>
+struct variant_caster;
 
-template <template<typename...> class V, typename... Ts>
+template <template <typename...> class V, typename... Ts>
 struct variant_caster<V<Ts...>> {
     static_assert(sizeof...(Ts) > 0, "Variant must consist of at least one alternative.");
 
     template <typename U, typename... Us>
     bool load_alternative(handle src, bool convert, type_list<U, Us...>) {
         auto caster = make_caster<U>();
         if (caster.load(src, convert)) {
-            value = cast_op<U>(caster);
+            value = cast_op<U>(std::move(caster));
             return true;
         }
         return load_alternative(src, convert, type_list<Us...>{});
     }
 
     bool load_alternative(handle, bool, type_list<>) { return false; }
 
     bool load(handle src, bool convert) {
         // Do a first pass without conversions to improve constructor resolution.
         // E.g. `py::int_(1).cast<variant<double, int>>()` needs to fill the `int`
         // slot of the variant. Without two-pass loading `double` would be filled
         // because it appears first and a conversion is possible.
-        if (convert && load_alternative(src, false, type_list<Ts...>{}))
+        if (convert && load_alternative(src, false, type_list<Ts...>{})) {
             return true;
+        }
         return load_alternative(src, convert, type_list<Ts...>{});
     }
 
     template <typename Variant>
     static handle cast(Variant &&src, return_value_policy policy, handle parent) {
         return visit_helper<V>::call(variant_caster_visitor{policy, parent},
                                      std::forward<Variant>(src));
     }
 
     using Type = V<Ts...>;
-    PYBIND11_TYPE_CASTER(Type, _("Union[") + detail::concat(make_caster<Ts>::name...) + _("]"));
+    PYBIND11_TYPE_CASTER(Type,
+                         const_name("Union[") + detail::concat(make_caster<Ts>::name...)
+                             + const_name("]"));
 };
 
-#if PYBIND11_HAS_VARIANT
+#if defined(PYBIND11_HAS_VARIANT)
 template <typename... Ts>
-struct type_caster<std::variant<Ts...>> : variant_caster<std::variant<Ts...>> { };
+struct type_caster<std::variant<Ts...>> : variant_caster<std::variant<Ts...>> {};
+
+template <>
+struct type_caster<std::monostate> : public void_caster<std::monostate> {};
 #endif
 
-NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(detail)
 
 inline std::ostream &operator<<(std::ostream &os, const handle &obj) {
+#ifdef PYBIND11_HAS_STRING_VIEW
+    os << str(obj).cast<std::string_view>();
+#else
     os << (std::string) str(obj);
+#endif
     return os;
 }
 
-NAMESPACE_END(PYBIND11_NAMESPACE)
-
-#if defined(_MSC_VER)
-#pragma warning(pop)
-#endif
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `stopeight-0.3.14/pybind11/include/pybind11/stl_bind.h` & `stopeight-0.3.22/stopeight-clibs/pybind11/include/pybind11/stl_bind.h`

 * *Files 16% similar despite different names*

```diff
@@ -6,430 +6,498 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "detail/common.h"
+#include "detail/type_caster_base.h"
+#include "cast.h"
 #include "operators.h"
 
 #include <algorithm>
 #include <sstream>
+#include <type_traits>
 
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_BEGIN(detail)
 
 /* SFINAE helper class used by 'is_comparable */
-template <typename T>  struct container_traits {
-    template <typename T2> static std::true_type test_comparable(decltype(std::declval<const T2 &>() == std::declval<const T2 &>())*);
-    template <typename T2> static std::false_type test_comparable(...);
-    template <typename T2> static std::true_type test_value(typename T2::value_type *);
-    template <typename T2> static std::false_type test_value(...);
-    template <typename T2> static std::true_type test_pair(typename T2::first_type *, typename T2::second_type *);
-    template <typename T2> static std::false_type test_pair(...);
-
-    static constexpr const bool is_comparable = std::is_same<std::true_type, decltype(test_comparable<T>(nullptr))>::value;
-    static constexpr const bool is_pair = std::is_same<std::true_type, decltype(test_pair<T>(nullptr, nullptr))>::value;
-    static constexpr const bool is_vector = std::is_same<std::true_type, decltype(test_value<T>(nullptr))>::value;
+template <typename T>
+struct container_traits {
+    template <typename T2>
+    static std::true_type
+    test_comparable(decltype(std::declval<const T2 &>() == std::declval<const T2 &>()) *);
+    template <typename T2>
+    static std::false_type test_comparable(...);
+    template <typename T2>
+    static std::true_type test_value(typename T2::value_type *);
+    template <typename T2>
+    static std::false_type test_value(...);
+    template <typename T2>
+    static std::true_type test_pair(typename T2::first_type *, typename T2::second_type *);
+    template <typename T2>
+    static std::false_type test_pair(...);
+
+    static constexpr const bool is_comparable
+        = std::is_same<std::true_type, decltype(test_comparable<T>(nullptr))>::value;
+    static constexpr const bool is_pair
+        = std::is_same<std::true_type, decltype(test_pair<T>(nullptr, nullptr))>::value;
+    static constexpr const bool is_vector
+        = std::is_same<std::true_type, decltype(test_value<T>(nullptr))>::value;
     static constexpr const bool is_element = !is_pair && !is_vector;
 };
 
 /* Default: is_comparable -> std::false_type */
 template <typename T, typename SFINAE = void>
-struct is_comparable : std::false_type { };
+struct is_comparable : std::false_type {};
 
 /* For non-map data structures, check whether operator== can be instantiated */
 template <typename T>
 struct is_comparable<
-    T, enable_if_t<container_traits<T>::is_element &&
-                   container_traits<T>::is_comparable>>
-    : std::true_type { };
+    T,
+    enable_if_t<container_traits<T>::is_element && container_traits<T>::is_comparable>>
+    : std::true_type {};
 
-/* For a vector/map data structure, recursively check the value type (which is std::pair for maps) */
+/* For a vector/map data structure, recursively check the value type
+   (which is std::pair for maps) */
 template <typename T>
 struct is_comparable<T, enable_if_t<container_traits<T>::is_vector>> {
-    static constexpr const bool value =
-        is_comparable<typename T::value_type>::value;
+    static constexpr const bool value = is_comparable<typename T::value_type>::value;
 };
 
 /* For pairs, recursively check the two data types */
 template <typename T>
 struct is_comparable<T, enable_if_t<container_traits<T>::is_pair>> {
-    static constexpr const bool value =
-        is_comparable<typename T::first_type>::value &&
-        is_comparable<typename T::second_type>::value;
+    static constexpr const bool value = is_comparable<typename T::first_type>::value
+                                        && is_comparable<typename T::second_type>::value;
 };
 
 /* Fallback functions */
-template <typename, typename, typename... Args> void vector_if_copy_constructible(const Args &...) { }
-template <typename, typename, typename... Args> void vector_if_equal_operator(const Args &...) { }
-template <typename, typename, typename... Args> void vector_if_insertion_operator(const Args &...) { }
-template <typename, typename, typename... Args> void vector_modifiers(const Args &...) { }
+template <typename, typename, typename... Args>
+void vector_if_copy_constructible(const Args &...) {}
+template <typename, typename, typename... Args>
+void vector_if_equal_operator(const Args &...) {}
+template <typename, typename, typename... Args>
+void vector_if_insertion_operator(const Args &...) {}
+template <typename, typename, typename... Args>
+void vector_modifiers(const Args &...) {}
 
-template<typename Vector, typename Class_>
+template <typename Vector, typename Class_>
 void vector_if_copy_constructible(enable_if_t<is_copy_constructible<Vector>::value, Class_> &cl) {
     cl.def(init<const Vector &>(), "Copy constructor");
 }
 
-template<typename Vector, typename Class_>
+template <typename Vector, typename Class_>
 void vector_if_equal_operator(enable_if_t<is_comparable<Vector>::value, Class_> &cl) {
     using T = typename Vector::value_type;
 
     cl.def(self == self);
     cl.def(self != self);
 
-    cl.def("count",
-        [](const Vector &v, const T &x) {
-            return std::count(v.begin(), v.end(), x);
-        },
+    cl.def(
+        "count",
+        [](const Vector &v, const T &x) { return std::count(v.begin(), v.end(), x); },
         arg("x"),
-        "Return the number of times ``x`` appears in the list"
-    );
+        "Return the number of times ``x`` appears in the list");
 
-    cl.def("remove", [](Vector &v, const T &x) {
+    cl.def(
+        "remove",
+        [](Vector &v, const T &x) {
             auto p = std::find(v.begin(), v.end(), x);
-            if (p != v.end())
+            if (p != v.end()) {
                 v.erase(p);
-            else
+            } else {
                 throw value_error();
+            }
         },
         arg("x"),
         "Remove the first item from the list whose value is x. "
-        "It is an error if there is no such item."
-    );
+        "It is an error if there is no such item.");
 
-    cl.def("__contains__",
-        [](const Vector &v, const T &x) {
-            return std::find(v.begin(), v.end(), x) != v.end();
-        },
+    cl.def(
+        "__contains__",
+        [](const Vector &v, const T &x) { return std::find(v.begin(), v.end(), x) != v.end(); },
         arg("x"),
-        "Return true the container contains ``x``"
-    );
+        "Return true the container contains ``x``");
 }
 
 // Vector modifiers -- requires a copyable vector_type:
-// (Technically, some of these (pop and __delitem__) don't actually require copyability, but it seems
-// silly to allow deletion but not insertion, so include them here too.)
+// (Technically, some of these (pop and __delitem__) don't actually require copyability, but it
+// seems silly to allow deletion but not insertion, so include them here too.)
 template <typename Vector, typename Class_>
-void vector_modifiers(enable_if_t<is_copy_constructible<typename Vector::value_type>::value, Class_> &cl) {
+void vector_modifiers(
+    enable_if_t<is_copy_constructible<typename Vector::value_type>::value, Class_> &cl) {
     using T = typename Vector::value_type;
     using SizeType = typename Vector::size_type;
     using DiffType = typename Vector::difference_type;
 
     auto wrap_i = [](DiffType i, SizeType n) {
-        if (i < 0)
+        if (i < 0) {
             i += n;
-        if (i < 0 || (SizeType)i >= n)
+        }
+        if (i < 0 || (SizeType) i >= n) {
             throw index_error();
+        }
         return i;
     };
 
-    cl.def("append",
-           [](Vector &v, const T &value) { v.push_back(value); },
-           arg("x"),
-           "Add an item to the end of the list");
+    cl.def(
+        "append",
+        [](Vector &v, const T &value) { v.push_back(value); },
+        arg("x"),
+        "Add an item to the end of the list");
 
-    cl.def(init([](iterable it) {
+    cl.def(init([](const iterable &it) {
         auto v = std::unique_ptr<Vector>(new Vector());
         v->reserve(len_hint(it));
-        for (handle h : it)
-           v->push_back(h.cast<T>());
+        for (handle h : it) {
+            v->push_back(h.cast<T>());
+        }
         return v.release();
     }));
 
-    cl.def("clear",
-        [](Vector &v) {
-            v.clear();
-        },
-        "Clear the contents"
-    );
-
-    cl.def("extend",
-       [](Vector &v, const Vector &src) {
-           v.insert(v.end(), src.begin(), src.end());
-       },
-       arg("L"),
-       "Extend the list by appending all the items in the given list"
-    );
+    cl.def(
+        "clear", [](Vector &v) { v.clear(); }, "Clear the contents");
 
-    cl.def("extend",
-       [](Vector &v, iterable it) {
-           const size_t old_size = v.size();
-           v.reserve(old_size + len_hint(it));
-           try {
-               for (handle h : it) {
-                   v.push_back(h.cast<T>());
-               }
-           } catch (const cast_error &) {
-               v.erase(v.begin() + static_cast<typename Vector::difference_type>(old_size), v.end());
-               try {
-                   v.shrink_to_fit();
-               } catch (const std::exception &) {
-                   // Do nothing
-               }
-               throw;
-           }
-       },
-       arg("L"),
-       "Extend the list by appending all the items in the given list"
-    );
+    cl.def(
+        "extend",
+        [](Vector &v, const Vector &src) { v.insert(v.end(), src.begin(), src.end()); },
+        arg("L"),
+        "Extend the list by appending all the items in the given list");
+
+    cl.def(
+        "extend",
+        [](Vector &v, const iterable &it) {
+            const size_t old_size = v.size();
+            v.reserve(old_size + len_hint(it));
+            try {
+                for (handle h : it) {
+                    v.push_back(h.cast<T>());
+                }
+            } catch (const cast_error &) {
+                v.erase(v.begin() + static_cast<typename Vector::difference_type>(old_size),
+                        v.end());
+                try {
+                    v.shrink_to_fit();
+                } catch (const std::exception &) {
+                    // Do nothing
+                }
+                throw;
+            }
+        },
+        arg("L"),
+        "Extend the list by appending all the items in the given list");
 
-    cl.def("insert",
+    cl.def(
+        "insert",
         [](Vector &v, DiffType i, const T &x) {
             // Can't use wrap_i; i == v.size() is OK
-            if (i < 0)
+            if (i < 0) {
                 i += v.size();
-            if (i < 0 || (SizeType)i > v.size())
+            }
+            if (i < 0 || (SizeType) i > v.size()) {
                 throw index_error();
+            }
             v.insert(v.begin() + i, x);
         },
-        arg("i") , arg("x"),
-        "Insert an item at a given position."
-    );
+        arg("i"),
+        arg("x"),
+        "Insert an item at a given position.");
 
-    cl.def("pop",
+    cl.def(
+        "pop",
         [](Vector &v) {
-            if (v.empty())
+            if (v.empty()) {
                 throw index_error();
-            T t = v.back();
+            }
+            T t = std::move(v.back());
             v.pop_back();
             return t;
         },
-        "Remove and return the last item"
-    );
+        "Remove and return the last item");
 
-    cl.def("pop",
+    cl.def(
+        "pop",
         [wrap_i](Vector &v, DiffType i) {
             i = wrap_i(i, v.size());
-            T t = v[(SizeType) i];
-            v.erase(v.begin() + i);
+            T t = std::move(v[(SizeType) i]);
+            v.erase(std::next(v.begin(), i));
             return t;
         },
         arg("i"),
-        "Remove and return the item at index ``i``"
-    );
+        "Remove and return the item at index ``i``");
 
-    cl.def("__setitem__",
-        [wrap_i](Vector &v, DiffType i, const T &t) {
-            i = wrap_i(i, v.size());
-            v[(SizeType)i] = t;
-        }
-    );
+    cl.def("__setitem__", [wrap_i](Vector &v, DiffType i, const T &t) {
+        i = wrap_i(i, v.size());
+        v[(SizeType) i] = t;
+    });
 
     /// Slicing protocol
-    cl.def("__getitem__",
-        [](const Vector &v, slice slice) -> Vector * {
-            size_t start, stop, step, slicelength;
+    cl.def(
+        "__getitem__",
+        [](const Vector &v, const slice &slice) -> Vector * {
+            size_t start = 0, stop = 0, step = 0, slicelength = 0;
 
-            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))
+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {
                 throw error_already_set();
+            }
 
-            Vector *seq = new Vector();
+            auto *seq = new Vector();
             seq->reserve((size_t) slicelength);
 
-            for (size_t i=0; i<slicelength; ++i) {
+            for (size_t i = 0; i < slicelength; ++i) {
                 seq->push_back(v[start]);
                 start += step;
             }
             return seq;
         },
         arg("s"),
-        "Retrieve list elements using a slice object"
-    );
+        "Retrieve list elements using a slice object");
 
-    cl.def("__setitem__",
-        [](Vector &v, slice slice,  const Vector &value) {
-            size_t start, stop, step, slicelength;
-            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))
+    cl.def(
+        "__setitem__",
+        [](Vector &v, const slice &slice, const Vector &value) {
+            size_t start = 0, stop = 0, step = 0, slicelength = 0;
+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {
                 throw error_already_set();
+            }
 
-            if (slicelength != value.size())
-                throw std::runtime_error("Left and right hand size of slice assignment have different sizes!");
+            if (slicelength != value.size()) {
+                throw std::runtime_error(
+                    "Left and right hand size of slice assignment have different sizes!");
+            }
 
-            for (size_t i=0; i<slicelength; ++i) {
+            for (size_t i = 0; i < slicelength; ++i) {
                 v[start] = value[i];
                 start += step;
             }
         },
-        "Assign list elements using a slice object"
-    );
+        "Assign list elements using a slice object");
 
-    cl.def("__delitem__",
+    cl.def(
+        "__delitem__",
         [wrap_i](Vector &v, DiffType i) {
             i = wrap_i(i, v.size());
             v.erase(v.begin() + i);
         },
-        "Delete the list elements at index ``i``"
-    );
+        "Delete the list elements at index ``i``");
 
-    cl.def("__delitem__",
-        [](Vector &v, slice slice) {
-            size_t start, stop, step, slicelength;
+    cl.def(
+        "__delitem__",
+        [](Vector &v, const slice &slice) {
+            size_t start = 0, stop = 0, step = 0, slicelength = 0;
 
-            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))
+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {
                 throw error_already_set();
+            }
 
             if (step == 1 && false) {
                 v.erase(v.begin() + (DiffType) start, v.begin() + DiffType(start + slicelength));
             } else {
                 for (size_t i = 0; i < slicelength; ++i) {
                     v.erase(v.begin() + DiffType(start));
                     start += step - 1;
                 }
             }
         },
-        "Delete list elements using a slice object"
-    );
-
+        "Delete list elements using a slice object");
 }
 
 // If the type has an operator[] that doesn't return a reference (most notably std::vector<bool>),
 // we have to access by copying; otherwise we return by reference.
-template <typename Vector> using vector_needs_copy = negation<
-    std::is_same<decltype(std::declval<Vector>()[typename Vector::size_type()]), typename Vector::value_type &>>;
+template <typename Vector>
+using vector_needs_copy
+    = negation<std::is_same<decltype(std::declval<Vector>()[typename Vector::size_type()]),
+                            typename Vector::value_type &>>;
 
 // The usual case: access and iterate by reference
 template <typename Vector, typename Class_>
 void vector_accessor(enable_if_t<!vector_needs_copy<Vector>::value, Class_> &cl) {
     using T = typename Vector::value_type;
     using SizeType = typename Vector::size_type;
     using DiffType = typename Vector::difference_type;
-    using ItType   = typename Vector::iterator;
+    using ItType = typename Vector::iterator;
 
     auto wrap_i = [](DiffType i, SizeType n) {
-        if (i < 0)
+        if (i < 0) {
             i += n;
-        if (i < 0 || (SizeType)i >= n)
+        }
+        if (i < 0 || (SizeType) i >= n) {
             throw index_error();
+        }
         return i;
     };
 
-    cl.def("__getitem__",
+    cl.def(
+        "__getitem__",
         [wrap_i](Vector &v, DiffType i) -> T & {
             i = wrap_i(i, v.size());
-            return v[(SizeType)i];
+            return v[(SizeType) i];
         },
         return_value_policy::reference_internal // ref + keepalive
     );
 
-    cl.def("__iter__",
-           [](Vector &v) {
-               return make_iterator<
-                   return_value_policy::reference_internal, ItType, ItType, T&>(
-                   v.begin(), v.end());
-           },
-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
+    cl.def(
+        "__iter__",
+        [](Vector &v) {
+            return make_iterator<return_value_policy::reference_internal, ItType, ItType, T &>(
+                v.begin(), v.end());
+        },
+        keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
     );
 }
 
 // The case for special objects, like std::vector<bool>, that have to be returned-by-copy:
 template <typename Vector, typename Class_>
 void vector_accessor(enable_if_t<vector_needs_copy<Vector>::value, Class_> &cl) {
     using T = typename Vector::value_type;
     using SizeType = typename Vector::size_type;
     using DiffType = typename Vector::difference_type;
-    using ItType   = typename Vector::iterator;
-    cl.def("__getitem__",
-        [](const Vector &v, DiffType i) -> T {
-            if (i < 0 && (i += v.size()) < 0)
+    using ItType = typename Vector::iterator;
+    cl.def("__getitem__", [](const Vector &v, DiffType i) -> T {
+        if (i < 0) {
+            i += v.size();
+            if (i < 0) {
                 throw index_error();
-            if ((SizeType)i >= v.size())
-                throw index_error();
-            return v[(SizeType)i];
+            }
         }
-    );
+        auto i_st = static_cast<SizeType>(i);
+        if (i_st >= v.size()) {
+            throw index_error();
+        }
+        return v[i_st];
+    });
 
-    cl.def("__iter__",
-           [](Vector &v) {
-               return make_iterator<
-                   return_value_policy::copy, ItType, ItType, T>(
-                   v.begin(), v.end());
-           },
-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
+    cl.def(
+        "__iter__",
+        [](Vector &v) {
+            return make_iterator<return_value_policy::copy, ItType, ItType, T>(v.begin(), v.end());
+        },
+        keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
     );
 }
 
-template <typename Vector, typename Class_> auto vector_if_insertion_operator(Class_ &cl, std::string const &name)
-    -> decltype(std::declval<std::ostream&>() << std::declval<typename Vector::value_type>(), void()) {
+template <typename Vector, typename Class_>
+auto vector_if_insertion_operator(Class_ &cl, std::string const &name)
+    -> decltype(std::declval<std::ostream &>() << std::declval<typename Vector::value_type>(),
+                void()) {
     using size_type = typename Vector::size_type;
 
-    cl.def("__repr__",
-           [name](Vector &v) {
+    cl.def(
+        "__repr__",
+        [name](Vector &v) {
             std::ostringstream s;
             s << name << '[';
-            for (size_type i=0; i < v.size(); ++i) {
+            for (size_type i = 0; i < v.size(); ++i) {
                 s << v[i];
-                if (i != v.size() - 1)
+                if (i != v.size() - 1) {
                     s << ", ";
+                }
             }
             s << ']';
             return s.str();
         },
-        "Return the canonical string representation of this list."
-    );
+        "Return the canonical string representation of this list.");
 }
 
 // Provide the buffer interface for vectors if we have data() and we have a format for it
-// GCC seems to have "void std::vector<bool>::data()" - doing SFINAE on the existence of data() is insufficient, we need to check it returns an appropriate pointer
+// GCC seems to have "void std::vector<bool>::data()" - doing SFINAE on the existence of data()
+// is insufficient, we need to check it returns an appropriate pointer
 template <typename Vector, typename = void>
 struct vector_has_data_and_format : std::false_type {};
 template <typename Vector>
-struct vector_has_data_and_format<Vector, enable_if_t<std::is_same<decltype(format_descriptor<typename Vector::value_type>::format(), std::declval<Vector>().data()), typename Vector::value_type*>::value>> : std::true_type {};
+struct vector_has_data_and_format<
+    Vector,
+    enable_if_t<std::is_same<decltype(format_descriptor<typename Vector::value_type>::format(),
+                                      std::declval<Vector>().data()),
+                             typename Vector::value_type *>::value>> : std::true_type {};
+
+// [workaround(intel)] Separate function required here
+// Workaround as the Intel compiler does not compile the enable_if_t part below
+// (tested with icc (ICC) 2021.1 Beta 20200827)
+template <typename... Args>
+constexpr bool args_any_are_buffer() {
+    return detail::any_of<std::is_same<Args, buffer_protocol>...>::value;
+}
+
+// [workaround(intel)] Separate function required here
+// [workaround(msvc)] Can't use constexpr bool in return type
 
 // Add the buffer interface to a vector
 template <typename Vector, typename Class_, typename... Args>
-enable_if_t<detail::any_of<std::is_same<Args, buffer_protocol>...>::value>
-vector_buffer(Class_& cl) {
+void vector_buffer_impl(Class_ &cl, std::true_type) {
     using T = typename Vector::value_type;
 
-    static_assert(vector_has_data_and_format<Vector>::value, "There is not an appropriate format descriptor for this vector");
+    static_assert(vector_has_data_and_format<Vector>::value,
+                  "There is not an appropriate format descriptor for this vector");
 
-    // numpy.h declares this for arbitrary types, but it may raise an exception and crash hard at runtime if PYBIND11_NUMPY_DTYPE hasn't been called, so check here
+    // numpy.h declares this for arbitrary types, but it may raise an exception and crash hard
+    // at runtime if PYBIND11_NUMPY_DTYPE hasn't been called, so check here
     format_descriptor<T>::format();
 
-    cl.def_buffer([](Vector& v) -> buffer_info {
-        return buffer_info(v.data(), static_cast<ssize_t>(sizeof(T)), format_descriptor<T>::format(), 1, {v.size()}, {sizeof(T)});
+    cl.def_buffer([](Vector &v) -> buffer_info {
+        return buffer_info(v.data(),
+                           static_cast<ssize_t>(sizeof(T)),
+                           format_descriptor<T>::format(),
+                           1,
+                           {v.size()},
+                           {sizeof(T)});
     });
 
-    cl.def(init([](buffer buf) {
+    cl.def(init([](const buffer &buf) {
         auto info = buf.request();
-        if (info.ndim != 1 || info.strides[0] % static_cast<ssize_t>(sizeof(T)))
+        if (info.ndim != 1 || info.strides[0] % static_cast<ssize_t>(sizeof(T))) {
             throw type_error("Only valid 1D buffers can be copied to a vector");
-        if (!detail::compare_buffer_info<T>::compare(info) || (ssize_t) sizeof(T) != info.itemsize)
-            throw type_error("Format mismatch (Python: " + info.format + " C++: " + format_descriptor<T>::format() + ")");
+        }
+        if (!detail::compare_buffer_info<T>::compare(info)
+            || (ssize_t) sizeof(T) != info.itemsize) {
+            throw type_error("Format mismatch (Python: " + info.format
+                             + " C++: " + format_descriptor<T>::format() + ")");
+        }
 
-        auto vec = std::unique_ptr<Vector>(new Vector());
-        vec->reserve((size_t) info.shape[0]);
-        T *p = static_cast<T*>(info.ptr);
+        T *p = static_cast<T *>(info.ptr);
         ssize_t step = info.strides[0] / static_cast<ssize_t>(sizeof(T));
         T *end = p + info.shape[0] * step;
-        for (; p != end; p += step)
-            vec->push_back(*p);
-        return vec.release();
+        if (step == 1) {
+            return Vector(p, end);
+        }
+        Vector vec;
+        vec.reserve((size_t) info.shape[0]);
+        for (; p != end; p += step) {
+            vec.push_back(*p);
+        }
+        return vec;
     }));
 
     return;
 }
 
 template <typename Vector, typename Class_, typename... Args>
-enable_if_t<!detail::any_of<std::is_same<Args, buffer_protocol>...>::value> vector_buffer(Class_&) {}
+void vector_buffer_impl(Class_ &, std::false_type) {}
 
-NAMESPACE_END(detail)
+template <typename Vector, typename Class_, typename... Args>
+void vector_buffer(Class_ &cl) {
+    vector_buffer_impl<Vector, Class_, Args...>(
+        cl, detail::any_of<std::is_same<Args, buffer_protocol>...>{});
+}
+
+PYBIND11_NAMESPACE_END(detail)
 
 //
 // std::vector
 //
 template <typename Vector, typename holder_type = std::unique_ptr<Vector>, typename... Args>
-class_<Vector, holder_type> bind_vector(handle scope, std::string const &name, Args&&... args) {
+class_<Vector, holder_type> bind_vector(handle scope, std::string const &name, Args &&...args) {
     using Class_ = class_<Vector, holder_type>;
 
     // If the value_type is unregistered (e.g. a converting type) or is itself registered
     // module-local then make the vector binding module-local as well:
     using vtype = typename Vector::value_type;
-    auto vtype_info = detail::get_type_info(typeid(vtype));
+    auto *vtype_info = detail::get_type_info(typeid(vtype));
     bool local = !vtype_info || vtype_info->module_local;
 
     Class_ cl(scope, name.c_str(), pybind11::module_local(local), std::forward<Args>(args)...);
 
     // Declare the buffer interface if a buffer_protocol() is passed in
     detail::vector_buffer<Vector, Class_, Args...>(cl);
 
@@ -446,26 +514,21 @@
 
     // Modifiers require copyable vector value type
     detail::vector_modifiers<Vector, Class_>(cl);
 
     // Accessor and iterator; return by value if copyable, otherwise we return by ref + keep-alive
     detail::vector_accessor<Vector, Class_>(cl);
 
-    cl.def("__bool__",
-        [](const Vector &v) -> bool {
-            return !v.empty();
-        },
-        "Check whether the list is nonempty"
-    );
+    cl.def(
+        "__bool__",
+        [](const Vector &v) -> bool { return !v.empty(); },
+        "Check whether the list is nonempty");
 
     cl.def("__len__", &Vector::size);
 
-
-
-
 #if 0
     // C++ style functions deprecated, leaving it here as an example
     cl.def(init<size_type>());
 
     cl.def("resize",
          (void (Vector::*) (size_type count)) & Vector::resize,
          "changes the number of elements stored");
@@ -501,156 +564,286 @@
     }, "access the last element ");
 
 #endif
 
     return cl;
 }
 
-
-
 //
 // std::map, std::unordered_map
 //
 
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(detail)
 
 /* Fallback functions */
-template <typename, typename, typename... Args> void map_if_insertion_operator(const Args &...) { }
-template <typename, typename, typename... Args> void map_assignment(const Args &...) { }
+template <typename, typename, typename... Args>
+void map_if_insertion_operator(const Args &...) {}
+template <typename, typename, typename... Args>
+void map_assignment(const Args &...) {}
 
 // Map assignment when copy-assignable: just copy the value
 template <typename Map, typename Class_>
-void map_assignment(enable_if_t<is_copy_assignable<typename Map::mapped_type>::value, Class_> &cl) {
+void map_assignment(
+    enable_if_t<is_copy_assignable<typename Map::mapped_type>::value, Class_> &cl) {
     using KeyType = typename Map::key_type;
     using MappedType = typename Map::mapped_type;
 
-    cl.def("__setitem__",
-           [](Map &m, const KeyType &k, const MappedType &v) {
-               auto it = m.find(k);
-               if (it != m.end()) it->second = v;
-               else m.emplace(k, v);
-           }
-    );
+    cl.def("__setitem__", [](Map &m, const KeyType &k, const MappedType &v) {
+        auto it = m.find(k);
+        if (it != m.end()) {
+            it->second = v;
+        } else {
+            m.emplace(k, v);
+        }
+    });
 }
 
-// Not copy-assignable, but still copy-constructible: we can update the value by erasing and reinserting
-template<typename Map, typename Class_>
-void map_assignment(enable_if_t<
-        !is_copy_assignable<typename Map::mapped_type>::value &&
-        is_copy_constructible<typename Map::mapped_type>::value,
-        Class_> &cl) {
+// Not copy-assignable, but still copy-constructible: we can update the value by erasing and
+// reinserting
+template <typename Map, typename Class_>
+void map_assignment(enable_if_t<!is_copy_assignable<typename Map::mapped_type>::value
+                                    && is_copy_constructible<typename Map::mapped_type>::value,
+                                Class_> &cl) {
     using KeyType = typename Map::key_type;
     using MappedType = typename Map::mapped_type;
 
-    cl.def("__setitem__",
-           [](Map &m, const KeyType &k, const MappedType &v) {
-               // We can't use m[k] = v; because value type might not be default constructable
-               auto r = m.emplace(k, v);
-               if (!r.second) {
-                   // value type is not copy assignable so the only way to insert it is to erase it first...
-                   m.erase(r.first);
-                   m.emplace(k, v);
-               }
-           }
-    );
+    cl.def("__setitem__", [](Map &m, const KeyType &k, const MappedType &v) {
+        // We can't use m[k] = v; because value type might not be default constructable
+        auto r = m.emplace(k, v);
+        if (!r.second) {
+            // value type is not copy assignable so the only way to insert it is to erase it
+            // first...
+            m.erase(r.first);
+            m.emplace(k, v);
+        }
+    });
 }
 
-
-template <typename Map, typename Class_> auto map_if_insertion_operator(Class_ &cl, std::string const &name)
--> decltype(std::declval<std::ostream&>() << std::declval<typename Map::key_type>() << std::declval<typename Map::mapped_type>(), void()) {
-
-    cl.def("__repr__",
-           [name](Map &m) {
+template <typename Map, typename Class_>
+auto map_if_insertion_operator(Class_ &cl, std::string const &name)
+    -> decltype(std::declval<std::ostream &>() << std::declval<typename Map::key_type>()
+                                               << std::declval<typename Map::mapped_type>(),
+                void()) {
+
+    cl.def(
+        "__repr__",
+        [name](Map &m) {
             std::ostringstream s;
             s << name << '{';
             bool f = false;
             for (auto const &kv : m) {
-                if (f)
+                if (f) {
                     s << ", ";
+                }
                 s << kv.first << ": " << kv.second;
                 f = true;
             }
             s << '}';
             return s.str();
         },
-        "Return the canonical string representation of this map."
-    );
+        "Return the canonical string representation of this map.");
 }
 
+template <typename KeyType>
+struct keys_view {
+    virtual size_t len() = 0;
+    virtual iterator iter() = 0;
+    virtual bool contains(const KeyType &k) = 0;
+    virtual bool contains(const object &k) = 0;
+    virtual ~keys_view() = default;
+};
+
+template <typename MappedType>
+struct values_view {
+    virtual size_t len() = 0;
+    virtual iterator iter() = 0;
+    virtual ~values_view() = default;
+};
+
+template <typename KeyType, typename MappedType>
+struct items_view {
+    virtual size_t len() = 0;
+    virtual iterator iter() = 0;
+    virtual ~items_view() = default;
+};
+
+template <typename Map, typename KeysView>
+struct KeysViewImpl : public KeysView {
+    explicit KeysViewImpl(Map &map) : map(map) {}
+    size_t len() override { return map.size(); }
+    iterator iter() override { return make_key_iterator(map.begin(), map.end()); }
+    bool contains(const typename Map::key_type &k) override { return map.find(k) != map.end(); }
+    bool contains(const object &) override { return false; }
+    Map &map;
+};
 
-NAMESPACE_END(detail)
+template <typename Map, typename ValuesView>
+struct ValuesViewImpl : public ValuesView {
+    explicit ValuesViewImpl(Map &map) : map(map) {}
+    size_t len() override { return map.size(); }
+    iterator iter() override { return make_value_iterator(map.begin(), map.end()); }
+    Map &map;
+};
+
+template <typename Map, typename ItemsView>
+struct ItemsViewImpl : public ItemsView {
+    explicit ItemsViewImpl(Map &map) : map(map) {}
+    size_t len() override { return map.size(); }
+    iterator iter() override { return make_iterator(map.begin(), map.end()); }
+    Map &map;
+};
+
+PYBIND11_NAMESPACE_END(detail)
 
 template <typename Map, typename holder_type = std::unique_ptr<Map>, typename... Args>
-class_<Map, holder_type> bind_map(handle scope, const std::string &name, Args&&... args) {
+class_<Map, holder_type> bind_map(handle scope, const std::string &name, Args &&...args) {
     using KeyType = typename Map::key_type;
     using MappedType = typename Map::mapped_type;
+    using StrippedKeyType = detail::remove_cvref_t<KeyType>;
+    using StrippedMappedType = detail::remove_cvref_t<MappedType>;
+    using KeysView = detail::keys_view<StrippedKeyType>;
+    using ValuesView = detail::values_view<StrippedMappedType>;
+    using ItemsView = detail::items_view<StrippedKeyType, StrippedMappedType>;
     using Class_ = class_<Map, holder_type>;
 
     // If either type is a non-module-local bound type then make the map binding non-local as well;
     // otherwise (e.g. both types are either module-local or converting) the map will be
     // module-local.
-    auto tinfo = detail::get_type_info(typeid(MappedType));
+    auto *tinfo = detail::get_type_info(typeid(MappedType));
     bool local = !tinfo || tinfo->module_local;
     if (local) {
         tinfo = detail::get_type_info(typeid(KeyType));
         local = !tinfo || tinfo->module_local;
     }
 
     Class_ cl(scope, name.c_str(), pybind11::module_local(local), std::forward<Args>(args)...);
+    static constexpr auto key_type_descr = detail::make_caster<KeyType>::name;
+    static constexpr auto mapped_type_descr = detail::make_caster<MappedType>::name;
+    std::string key_type_name(key_type_descr.text), mapped_type_name(mapped_type_descr.text);
+
+    // If key type isn't properly wrapped, fall back to C++ names
+    if (key_type_name == "%") {
+        key_type_name = detail::type_info_description(typeid(KeyType));
+    }
+    // Similarly for value type:
+    if (mapped_type_name == "%") {
+        mapped_type_name = detail::type_info_description(typeid(MappedType));
+    }
+
+    // Wrap KeysView[KeyType] if it wasn't already wrapped
+    if (!detail::get_type_info(typeid(KeysView))) {
+        class_<KeysView> keys_view(
+            scope, ("KeysView[" + key_type_name + "]").c_str(), pybind11::module_local(local));
+        keys_view.def("__len__", &KeysView::len);
+        keys_view.def("__iter__",
+                      &KeysView::iter,
+                      keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */
+        );
+        keys_view.def("__contains__",
+                      static_cast<bool (KeysView::*)(const KeyType &)>(&KeysView::contains));
+        // Fallback for when the object is not of the key type
+        keys_view.def("__contains__",
+                      static_cast<bool (KeysView::*)(const object &)>(&KeysView::contains));
+    }
+    // Similarly for ValuesView:
+    if (!detail::get_type_info(typeid(ValuesView))) {
+        class_<ValuesView> values_view(scope,
+                                       ("ValuesView[" + mapped_type_name + "]").c_str(),
+                                       pybind11::module_local(local));
+        values_view.def("__len__", &ValuesView::len);
+        values_view.def("__iter__",
+                        &ValuesView::iter,
+                        keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */
+        );
+    }
+    // Similarly for ItemsView:
+    if (!detail::get_type_info(typeid(ItemsView))) {
+        class_<ItemsView> items_view(
+            scope,
+            ("ItemsView[" + key_type_name + ", ").append(mapped_type_name + "]").c_str(),
+            pybind11::module_local(local));
+        items_view.def("__len__", &ItemsView::len);
+        items_view.def("__iter__",
+                       &ItemsView::iter,
+                       keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */
+        );
+    }
 
     cl.def(init<>());
 
     // Register stream insertion operator (if possible)
     detail::map_if_insertion_operator<Map, Class_>(cl, name);
 
-    cl.def("__bool__",
+    cl.def(
+        "__bool__",
         [](const Map &m) -> bool { return !m.empty(); },
-        "Check whether the map is nonempty"
+        "Check whether the map is nonempty");
+
+    cl.def(
+        "__iter__",
+        [](Map &m) { return make_key_iterator(m.begin(), m.end()); },
+        keep_alive<0, 1>() /* Essential: keep map alive while iterator exists */
+    );
+
+    cl.def(
+        "keys",
+        [](Map &m) {
+            return std::unique_ptr<KeysView>(new detail::KeysViewImpl<Map, KeysView>(m));
+        },
+        keep_alive<0, 1>() /* Essential: keep map alive while view exists */
     );
 
-    cl.def("__iter__",
-           [](Map &m) { return make_key_iterator(m.begin(), m.end()); },
-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
+    cl.def(
+        "values",
+        [](Map &m) {
+            return std::unique_ptr<ValuesView>(new detail::ValuesViewImpl<Map, ValuesView>(m));
+        },
+        keep_alive<0, 1>() /* Essential: keep map alive while view exists */
     );
 
-    cl.def("items",
-           [](Map &m) { return make_iterator(m.begin(), m.end()); },
-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
+    cl.def(
+        "items",
+        [](Map &m) {
+            return std::unique_ptr<ItemsView>(new detail::ItemsViewImpl<Map, ItemsView>(m));
+        },
+        keep_alive<0, 1>() /* Essential: keep map alive while view exists */
     );
 
-    cl.def("__getitem__",
+    cl.def(
+        "__getitem__",
         [](Map &m, const KeyType &k) -> MappedType & {
             auto it = m.find(k);
-            if (it == m.end())
-              throw key_error();
-           return it->second;
+            if (it == m.end()) {
+                throw key_error();
+            }
+            return it->second;
         },
         return_value_policy::reference_internal // ref + keepalive
     );
 
-    cl.def("__contains__",
-        [](Map &m, const KeyType &k) -> bool {
-            auto it = m.find(k);
-            if (it == m.end())
-              return false;
-           return true;
+    cl.def("__contains__", [](Map &m, const KeyType &k) -> bool {
+        auto it = m.find(k);
+        if (it == m.end()) {
+            return false;
         }
-    );
+        return true;
+    });
+    // Fallback for when the object is not of the key type
+    cl.def("__contains__", [](Map &, const object &) -> bool { return false; });
 
     // Assignment provided only if the type is copyable
     detail::map_assignment<Map, Class_>(cl);
 
-    cl.def("__delitem__",
-           [](Map &m, const KeyType &k) {
-               auto it = m.find(k);
-               if (it == m.end())
-                   throw key_error();
-               m.erase(it);
-           }
-    );
+    cl.def("__delitem__", [](Map &m, const KeyType &k) {
+        auto it = m.find(k);
+        if (it == m.end()) {
+            throw key_error();
+        }
+        m.erase(it);
+    });
 
     cl.def("__len__", &Map::size);
 
     return cl;
 }
 
-NAMESPACE_END(PYBIND11_NAMESPACE)
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `stopeight-0.3.14/pybind11/tests/CMakeLists.txt` & `stopeight-0.3.22/stopeight-clibs/pybind11/tools/pybind11Tools.cmake`

 * *Files 23% similar despite different names*

```diff
@@ -1,259 +1,233 @@
-# CMakeLists.txt -- Build system for the pybind11 test suite
+# tools/pybind11Tools.cmake -- Build system for the pybind11 modules
 #
-# Copyright (c) 2015 Wenzel Jakob <wenzel@inf.ethz.ch>
+# Copyright (c) 2020 Wenzel Jakob <wenzel.jakob@epfl.ch>
 #
 # All rights reserved. Use of this source code is governed by a
 # BSD-style license that can be found in the LICENSE file.
 
-cmake_minimum_required(VERSION 2.8.12)
-
-option(PYBIND11_WERROR  "Report all warnings as errors"  OFF)
-
-if (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
-    # We're being loaded directly, i.e. not via add_subdirectory, so make this
-    # work as its own project and load the pybind11Config to get the tools we need
-    project(pybind11_tests CXX)
-
-    find_package(pybind11 REQUIRED CONFIG)
+# include_guard(global) (pre-CMake 3.10)
+if(TARGET pybind11::python_headers)
+  return()
 endif()
 
-if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
-  message(STATUS "Setting tests build type to MinSizeRel as none was specified")
-  set(CMAKE_BUILD_TYPE MinSizeRel CACHE STRING "Choose the type of build." FORCE)
-  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release"
-    "MinSizeRel" "RelWithDebInfo")
-endif()
+# Built-in in CMake 3.5+
+include(CMakeParseArguments)
 
-# Full set of test files (you can override these; see below)
-set(PYBIND11_TEST_FILES
-  test_async.cpp
-  test_buffers.cpp
-  test_builtin_casters.cpp
-  test_call_policies.cpp
-  test_callbacks.cpp
-  test_chrono.cpp
-  test_class.cpp
-  test_constants_and_functions.cpp
-  test_copy_move.cpp
-  test_docstring_options.cpp
-  test_eigen.cpp
-  test_enum.cpp
-  test_eval.cpp
-  test_exceptions.cpp
-  test_factory_constructors.cpp
-  test_gil_scoped.cpp
-  test_iostream.cpp
-  test_kwargs_and_defaults.cpp
-  test_local_bindings.cpp
-  test_methods_and_attributes.cpp
-  test_modules.cpp
-  test_multiple_inheritance.cpp
-  test_numpy_array.cpp
-  test_numpy_dtypes.cpp
-  test_numpy_vectorize.cpp
-  test_opaque_types.cpp
-  test_operator_overloading.cpp
-  test_pickling.cpp
-  test_pytypes.cpp
-  test_sequences_and_iterators.cpp
-  test_smart_ptr.cpp
-  test_stl.cpp
-  test_stl_binders.cpp
-  test_tagbased_polymorphic.cpp
-  test_union.cpp
-  test_virtual_functions.cpp
-)
-
-# Invoking cmake with something like:
-#     cmake -DPYBIND11_TEST_OVERRIDE="test_callbacks.cpp;test_picking.cpp" ..
-# lets you override the tests that get compiled and run.  You can restore to all tests with:
-#     cmake -DPYBIND11_TEST_OVERRIDE= ..
-if (PYBIND11_TEST_OVERRIDE)
-  set(PYBIND11_TEST_FILES ${PYBIND11_TEST_OVERRIDE})
+if(pybind11_FIND_QUIETLY)
+  set(_pybind11_quiet QUIET)
+else()
+  set(_pybind11_quiet "")
 endif()
 
-# Skip test_async for Python < 3.5
-list(FIND PYBIND11_TEST_FILES test_async.cpp PYBIND11_TEST_FILES_ASYNC_I)
-if((PYBIND11_TEST_FILES_ASYNC_I GREATER -1) AND ("${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR}" VERSION_LESS 3.5))
-  message(STATUS "Skipping test_async because Python version ${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR} < 3.5")
-  list(REMOVE_AT PYBIND11_TEST_FILES ${PYBIND11_TEST_FILES_ASYNC_I})
+# If this is the first run, PYTHON_VERSION can stand in for PYBIND11_PYTHON_VERSION
+if(NOT DEFINED PYBIND11_PYTHON_VERSION AND DEFINED PYTHON_VERSION)
+  message(WARNING "Set PYBIND11_PYTHON_VERSION to search for a specific version, not "
+                  "PYTHON_VERSION (which is an output). Assuming that is what you "
+                  "meant to do and continuing anyway.")
+  set(PYBIND11_PYTHON_VERSION
+      "${PYTHON_VERSION}"
+      CACHE STRING "Python version to use for compiling modules")
+  unset(PYTHON_VERSION)
+  unset(PYTHON_VERSION CACHE)
+elseif(DEFINED PYBIND11_PYTHON_VERSION)
+  # If this is set as a normal variable, promote it
+  set(PYBIND11_PYTHON_VERSION
+      "${PYBIND11_PYTHON_VERSION}"
+      CACHE STRING "Python version to use for compiling modules")
+else()
+  # Make an empty cache variable.
+  set(PYBIND11_PYTHON_VERSION
+      ""
+      CACHE STRING "Python version to use for compiling modules")
+endif()
+
+# A user can set versions manually too
+set(Python_ADDITIONAL_VERSIONS
+    "3.11;3.10;3.9;3.8;3.7;3.6"
+    CACHE INTERNAL "")
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}")
+find_package(PythonLibsNew ${PYBIND11_PYTHON_VERSION} MODULE REQUIRED ${_pybind11_quiet})
+list(REMOVE_AT CMAKE_MODULE_PATH -1)
+
+# Makes a normal variable a cached variable
+macro(_PYBIND11_PROMOTE_TO_CACHE NAME)
+  set(_tmp_ptc "${${NAME}}")
+  # CMake 3.21 complains if a cached variable is shadowed by a normal one
+  unset(${NAME})
+  set(${NAME}
+      "${_tmp_ptc}"
+      CACHE INTERNAL "")
+endmacro()
+
+# Cache variables so pybind11_add_module can be used in parent projects
+_pybind11_promote_to_cache(PYTHON_INCLUDE_DIRS)
+_pybind11_promote_to_cache(PYTHON_LIBRARIES)
+_pybind11_promote_to_cache(PYTHON_MODULE_PREFIX)
+_pybind11_promote_to_cache(PYTHON_MODULE_EXTENSION)
+_pybind11_promote_to_cache(PYTHON_VERSION_MAJOR)
+_pybind11_promote_to_cache(PYTHON_VERSION_MINOR)
+_pybind11_promote_to_cache(PYTHON_VERSION)
+_pybind11_promote_to_cache(PYTHON_IS_DEBUG)
+
+if(PYBIND11_MASTER_PROJECT)
+  if(PYTHON_MODULE_EXTENSION MATCHES "pypy")
+    if(NOT DEFINED PYPY_VERSION)
+      execute_process(
+        COMMAND ${PYTHON_EXECUTABLE} -c
+                [=[import sys; sys.stdout.write(".".join(map(str, sys.pypy_version_info[:3])))]=]
+        OUTPUT_VARIABLE pypy_version)
+      set(PYPY_VERSION
+          ${pypy_version}
+          CACHE INTERNAL "")
+    endif()
+    message(STATUS "PYPY ${PYPY_VERSION} (Py ${PYTHON_VERSION})")
+  else()
+    message(STATUS "PYTHON ${PYTHON_VERSION}")
+  endif()
 endif()
 
-string(REPLACE ".cpp" ".py" PYBIND11_PYTEST_FILES "${PYBIND11_TEST_FILES}")
+# Only add Python for build - must be added during the import for config since
+# it has to be re-discovered.
+#
+# This needs to be an target to it is included after the local pybind11
+# directory, just in case there are multiple versions of pybind11, we want the
+# one we expect.
+add_library(pybind11::python_headers INTERFACE IMPORTED)
+set_property(TARGET pybind11::python_headers PROPERTY INTERFACE_INCLUDE_DIRECTORIES
+                                                      "$<BUILD_INTERFACE:${PYTHON_INCLUDE_DIRS}>")
+set_property(
+  TARGET pybind11::pybind11
+  APPEND
+  PROPERTY INTERFACE_LINK_LIBRARIES pybind11::python_headers)
+
+set(pybind11_INCLUDE_DIRS
+    "${pybind11_INCLUDE_DIR}" "${PYTHON_INCLUDE_DIRS}"
+    CACHE INTERNAL "Directories where pybind11 and possibly Python headers are located")
+
+# Python debug libraries expose slightly different objects before 3.8
+# https://docs.python.org/3.6/c-api/intro.html#debugging-builds
+# https://stackoverflow.com/questions/39161202/how-to-work-around-missing-pymodule-create2-in-amd64-win-python35-d-lib
+if(PYTHON_IS_DEBUG)
+  set_property(
+    TARGET pybind11::pybind11
+    APPEND
+    PROPERTY INTERFACE_COMPILE_DEFINITIONS Py_DEBUG)
+endif()
+
+# The <3.11 code here does not support release/debug builds at the same time, like on vcpkg
+if(CMAKE_VERSION VERSION_LESS 3.11)
+  set_property(
+    TARGET pybind11::module
+    APPEND
+    PROPERTY
+      INTERFACE_LINK_LIBRARIES
+      pybind11::python_link_helper
+      "$<$<OR:$<PLATFORM_ID:Windows>,$<PLATFORM_ID:Cygwin>>:$<BUILD_INTERFACE:${PYTHON_LIBRARIES}>>"
+  )
+
+  set_property(
+    TARGET pybind11::embed
+    APPEND
+    PROPERTY INTERFACE_LINK_LIBRARIES pybind11::pybind11 $<BUILD_INTERFACE:${PYTHON_LIBRARIES}>)
+else()
+  # The IMPORTED INTERFACE library here is to ensure that "debug" and "release" get processed outside
+  # of a generator expression - https://gitlab.kitware.com/cmake/cmake/-/issues/18424, as they are
+  # target_link_library keywords rather than real libraries.
+  add_library(pybind11::_ClassicPythonLibraries IMPORTED INTERFACE)
+  target_link_libraries(pybind11::_ClassicPythonLibraries INTERFACE ${PYTHON_LIBRARIES})
+  target_link_libraries(
+    pybind11::module
+    INTERFACE
+      pybind11::python_link_helper
+      "$<$<OR:$<PLATFORM_ID:Windows>,$<PLATFORM_ID:Cygwin>>:pybind11::_ClassicPythonLibraries>")
+
+  target_link_libraries(pybind11::embed INTERFACE pybind11::pybind11
+                                                  pybind11::_ClassicPythonLibraries)
+endif()
+
+function(pybind11_extension name)
+  # The prefix and extension are provided by FindPythonLibsNew.cmake
+  set_target_properties(${name} PROPERTIES PREFIX "${PYTHON_MODULE_PREFIX}"
+                                           SUFFIX "${PYTHON_MODULE_EXTENSION}")
+endfunction()
 
-# Contains the set of test files that require pybind11_cross_module_tests to be
-# built; if none of these are built (i.e. because TEST_OVERRIDE is used and
-# doesn't include them) the second module doesn't get built.
-set(PYBIND11_CROSS_MODULE_TESTS
-  test_exceptions.py
-  test_local_bindings.py
-  test_stl.py
-  test_stl_binders.py
-)
-
-set(PYBIND11_CROSS_MODULE_GIL_TESTS
-  test_gil_scoped.py
-)
-
-# Check if Eigen is available; if not, remove from PYBIND11_TEST_FILES (but
-# keep it in PYBIND11_PYTEST_FILES, so that we get the "eigen is not installed"
-# skip message).
-list(FIND PYBIND11_TEST_FILES test_eigen.cpp PYBIND11_TEST_FILES_EIGEN_I)
-if(PYBIND11_TEST_FILES_EIGEN_I GREATER -1)
-  # Try loading via newer Eigen's Eigen3Config first (bypassing tools/FindEigen3.cmake).
-  # Eigen 3.3.1+ exports a cmake 3.0+ target for handling dependency requirements, but also
-  # produces a fatal error if loaded from a pre-3.0 cmake.
-  if (NOT CMAKE_VERSION VERSION_LESS 3.0)
-    find_package(Eigen3 3.2.7 QUIET CONFIG)
-    if (EIGEN3_FOUND)
-      if (EIGEN3_VERSION_STRING AND NOT EIGEN3_VERSION_STRING VERSION_LESS 3.3.1)
-        set(PYBIND11_EIGEN_VIA_TARGET 1)
-      endif()
-    endif()
-  endif()
-  if (NOT EIGEN3_FOUND)
-    # Couldn't load via target, so fall back to allowing module mode finding, which will pick up
-    # tools/FindEigen3.cmake
-    find_package(Eigen3 3.2.7 QUIET)
+# Build a Python extension module:
+# pybind11_add_module(<name> [MODULE | SHARED] [EXCLUDE_FROM_ALL]
+#                     [NO_EXTRAS] [THIN_LTO] [OPT_SIZE] source1 [source2 ...])
+#
+function(pybind11_add_module target_name)
+  set(options "MODULE;SHARED;EXCLUDE_FROM_ALL;NO_EXTRAS;SYSTEM;THIN_LTO;OPT_SIZE")
+  cmake_parse_arguments(ARG "${options}" "" "" ${ARGN})
+
+  if(ARG_MODULE AND ARG_SHARED)
+    message(FATAL_ERROR "Can't be both MODULE and SHARED")
+  elseif(ARG_SHARED)
+    set(lib_type SHARED)
+  else()
+    set(lib_type MODULE)
   endif()
 
-  if(EIGEN3_FOUND)
-    # Eigen 3.3.1+ cmake sets EIGEN3_VERSION_STRING (and hard codes the version when installed
-    # rather than looking it up in the cmake script); older versions, and the
-    # tools/FindEigen3.cmake, set EIGEN3_VERSION instead.
-    if(NOT EIGEN3_VERSION AND EIGEN3_VERSION_STRING)
-      set(EIGEN3_VERSION ${EIGEN3_VERSION_STRING})
-    endif()
-    message(STATUS "Building tests with Eigen v${EIGEN3_VERSION}")
+  if(ARG_EXCLUDE_FROM_ALL)
+    set(exclude_from_all EXCLUDE_FROM_ALL)
   else()
-    list(REMOVE_AT PYBIND11_TEST_FILES ${PYBIND11_TEST_FILES_EIGEN_I})
-    message(STATUS "Building tests WITHOUT Eigen")
+    set(exclude_from_all "")
   endif()
-endif()
 
-# Optional dependency for some tests (boost::variant is only supported with version >= 1.56)
-find_package(Boost 1.56)
+  add_library(${target_name} ${lib_type} ${exclude_from_all} ${ARG_UNPARSED_ARGUMENTS})
 
-# Compile with compiler warnings turned on
-function(pybind11_enable_warnings target_name)
-  if(MSVC)
-    target_compile_options(${target_name} PRIVATE /W4)
-  elseif(CMAKE_CXX_COMPILER_ID MATCHES "(GNU|Intel|Clang)")
-      target_compile_options(${target_name} PRIVATE -Wall -Wextra -Wconversion -Wcast-qual -Wdeprecated)
-  endif()
+  target_link_libraries(${target_name} PRIVATE pybind11::module)
 
-  if(PYBIND11_WERROR)
-    if(MSVC)
-      target_compile_options(${target_name} PRIVATE /WX)
-    elseif(CMAKE_CXX_COMPILER_ID MATCHES "(GNU|Intel|Clang)")
-      target_compile_options(${target_name} PRIVATE -Werror)
-    endif()
+  if(ARG_SYSTEM)
+    message(
+      STATUS
+        "Warning: this does not have an effect - use NO_SYSTEM_FROM_IMPORTED if using imported targets"
+    )
   endif()
-endfunction()
 
-set(test_targets pybind11_tests)
+  pybind11_extension(${target_name})
 
-# Build pybind11_cross_module_tests if any test_whatever.py are being built that require it
-foreach(t ${PYBIND11_CROSS_MODULE_TESTS})
-  list(FIND PYBIND11_PYTEST_FILES ${t} i)
-  if (i GREATER -1)
-    list(APPEND test_targets pybind11_cross_module_tests)
-    break()
-  endif()
-endforeach()
-
-foreach(t ${PYBIND11_CROSS_MODULE_GIL_TESTS})
-  list(FIND PYBIND11_PYTEST_FILES ${t} i)
-  if (i GREATER -1)
-    list(APPEND test_targets cross_module_gil_utils)
-    break()
-  endif()
-endforeach()
-
-set(testdir ${CMAKE_CURRENT_SOURCE_DIR})
-foreach(target ${test_targets})
-  set(test_files ${PYBIND11_TEST_FILES})
-  if(NOT target STREQUAL "pybind11_tests")
-    set(test_files "")
-  endif()
-
-  # Create the binding library
-  pybind11_add_module(${target} THIN_LTO ${target}.cpp ${test_files} ${PYBIND11_HEADERS})
-  pybind11_enable_warnings(${target})
+  # -fvisibility=hidden is required to allow multiple modules compiled against
+  # different pybind versions to work properly, and for some features (e.g.
+  # py::module_local).  We force it on everything inside the `pybind11`
+  # namespace; also turning it on for a pybind module compilation here avoids
+  # potential warnings or issues from having mixed hidden/non-hidden types.
+  if(NOT DEFINED CMAKE_CXX_VISIBILITY_PRESET)
+    set_target_properties(${target_name} PROPERTIES CXX_VISIBILITY_PRESET "hidden")
+  endif()
 
-  if(MSVC)
-    target_compile_options(${target} PRIVATE /utf-8)
+  if(NOT DEFINED CMAKE_CUDA_VISIBILITY_PRESET)
+    set_target_properties(${target_name} PROPERTIES CUDA_VISIBILITY_PRESET "hidden")
+  endif()
+
+  if(ARG_NO_EXTRAS)
+    return()
   endif()
 
-  if(EIGEN3_FOUND)
-    if (PYBIND11_EIGEN_VIA_TARGET)
-      target_link_libraries(${target} PRIVATE Eigen3::Eigen)
+  if(NOT DEFINED CMAKE_INTERPROCEDURAL_OPTIMIZATION)
+    if(ARG_THIN_LTO)
+      target_link_libraries(${target_name} PRIVATE pybind11::thin_lto)
     else()
-      target_include_directories(${target} PRIVATE ${EIGEN3_INCLUDE_DIR})
+      target_link_libraries(${target_name} PRIVATE pybind11::lto)
     endif()
-    target_compile_definitions(${target} PRIVATE -DPYBIND11_TEST_EIGEN)
   endif()
 
-  if(Boost_FOUND)
-    target_include_directories(${target} PRIVATE ${Boost_INCLUDE_DIRS})
-    target_compile_definitions(${target} PRIVATE -DPYBIND11_TEST_BOOST)
-  endif()
-
-  # Always write the output file directly into the 'tests' directory (even on MSVC)
-  if(NOT CMAKE_LIBRARY_OUTPUT_DIRECTORY)
-    set_target_properties(${target} PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${testdir})
-    foreach(config ${CMAKE_CONFIGURATION_TYPES})
-      string(TOUPPER ${config} config)
-      set_target_properties(${target} PROPERTIES LIBRARY_OUTPUT_DIRECTORY_${config} ${testdir})
-    endforeach()
-  endif()
-endforeach()
-
-# Make sure pytest is found or produce a fatal error
-if(NOT PYBIND11_PYTEST_FOUND)
-  execute_process(COMMAND ${PYTHON_EXECUTABLE} -c "import pytest; print(pytest.__version__)"
-                  RESULT_VARIABLE pytest_not_found OUTPUT_VARIABLE pytest_version ERROR_QUIET)
-  if(pytest_not_found)
-    message(FATAL_ERROR "Running the tests requires pytest. Please install it manually"
-                        " (try: ${PYTHON_EXECUTABLE} -m pip install pytest)")
-  elseif(pytest_version VERSION_LESS 3.0)
-    message(FATAL_ERROR "Running the tests requires pytest >= 3.0. Found: ${pytest_version}"
-                        "Please update it (try: ${PYTHON_EXECUTABLE} -m pip install -U pytest)")
+  # Use case-insensitive comparison to match the result of $<CONFIG:cfgs>
+  string(TOUPPER "${CMAKE_BUILD_TYPE}" uppercase_CMAKE_BUILD_TYPE)
+  if(NOT MSVC AND NOT "${uppercase_CMAKE_BUILD_TYPE}" MATCHES DEBUG|RELWITHDEBINFO)
+    pybind11_strip(${target_name})
   endif()
-  set(PYBIND11_PYTEST_FOUND TRUE CACHE INTERNAL "")
-endif()
-
-if(CMAKE_VERSION VERSION_LESS 3.2)
-  set(PYBIND11_USES_TERMINAL "")
-else()
-  set(PYBIND11_USES_TERMINAL "USES_TERMINAL")
-endif()
 
-# A single command to compile and run the tests
-add_custom_target(pytest COMMAND ${PYTHON_EXECUTABLE} -m pytest ${PYBIND11_PYTEST_FILES}
-                  DEPENDS ${test_targets} WORKING_DIRECTORY ${testdir} ${PYBIND11_USES_TERMINAL})
-
-if(PYBIND11_TEST_OVERRIDE)
-  add_custom_command(TARGET pytest POST_BUILD
-    COMMAND ${CMAKE_COMMAND} -E echo "Note: not all tests run: -DPYBIND11_TEST_OVERRIDE is in effect")
-endif()
-
-# Add a check target to run all the tests, starting with pytest (we add dependencies to this below)
-add_custom_target(check DEPENDS pytest)
-
-# The remaining tests only apply when being built as part of the pybind11 project, but not if the
-# tests are being built independently.
-if (NOT PROJECT_NAME STREQUAL "pybind11")
-  return()
-endif()
-
-# Add a post-build comment to show the primary test suite .so size and, if a previous size, compare it:
-add_custom_command(TARGET pybind11_tests POST_BUILD
-  COMMAND ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/tools/libsize.py
-  $<TARGET_FILE:pybind11_tests> ${CMAKE_CURRENT_BINARY_DIR}/sosize-$<TARGET_FILE_NAME:pybind11_tests>.txt)
+  if(MSVC)
+    target_link_libraries(${target_name} PRIVATE pybind11::windows_extras)
+  endif()
 
-# Test embedding the interpreter. Provides the `cpptest` target.
-add_subdirectory(test_embed)
+  if(ARG_OPT_SIZE)
+    target_link_libraries(${target_name} PRIVATE pybind11::opt_size)
+  endif()
+endfunction()
 
-# Test CMake build using functions and targets from subdirectory or installed location
-add_subdirectory(test_cmake_build)
+# Provide general way to call common Python commands in "common" file.
+set(_Python
+    PYTHON
+    CACHE INTERNAL "" FORCE)
```

### Comparing `stopeight-0.3.14/pybind11/tests/test_cmake_build/CMakeLists.txt` & `stopeight-0.3.22/stopeight-clibs/pybind11/tests/test_cmake_build/CMakeLists.txt`

 * *Files 25% similar despite different names*

```diff
@@ -1,58 +1,84 @@
-add_custom_target(test_cmake_build)
+# Built-in in CMake 3.5+
+include(CMakeParseArguments)
 
-if(CMAKE_VERSION VERSION_LESS 3.1)
-  # 3.0 needed for interface library for subdirectory_target/installed_target
-  # 3.1 needed for cmake -E env for testing
-  return()
-endif()
+add_custom_target(test_cmake_build)
 
-include(CMakeParseArguments)
 function(pybind11_add_build_test name)
   cmake_parse_arguments(ARG "INSTALL" "" "" ${ARGN})
 
-  set(build_options "-DCMAKE_PREFIX_PATH=${PROJECT_BINARY_DIR}/mock_install"
-                    "-DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}"
-                    "-DPYTHON_EXECUTABLE:FILEPATH=${PYTHON_EXECUTABLE}"
-                    "-DPYBIND11_CPP_STANDARD=${PYBIND11_CPP_STANDARD}")
+  set(build_options "-DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}")
+
+  if(PYBIND11_FINDPYTHON)
+    list(APPEND build_options "-DPYBIND11_FINDPYTHON=${PYBIND11_FINDPYTHON}")
+
+    if(DEFINED Python_ROOT_DIR)
+      list(APPEND build_options "-DPython_ROOT_DIR=${Python_ROOT_DIR}")
+    endif()
+
+    list(APPEND build_options "-DPython_EXECUTABLE=${Python_EXECUTABLE}")
+  else()
+    list(APPEND build_options "-DPYTHON_EXECUTABLE=${PYTHON_EXECUTABLE}")
+  endif()
+
+  if(DEFINED CMAKE_CXX_STANDARD)
+    list(APPEND build_options "-DCMAKE_CXX_STANDARD=${CMAKE_CXX_STANDARD}")
+  endif()
+
   if(NOT ARG_INSTALL)
-    list(APPEND build_options "-DPYBIND11_PROJECT_DIR=${PROJECT_SOURCE_DIR}")
+    list(APPEND build_options "-Dpybind11_SOURCE_DIR=${pybind11_SOURCE_DIR}")
+  else()
+    list(APPEND build_options "-DCMAKE_PREFIX_PATH=${pybind11_BINARY_DIR}/mock_install")
   endif()
 
-  add_custom_target(test_${name} ${CMAKE_CTEST_COMMAND}
-    --quiet --output-log ${name}.log
-    --build-and-test "${CMAKE_CURRENT_SOURCE_DIR}/${name}"
-                     "${CMAKE_CURRENT_BINARY_DIR}/${name}"
-    --build-config Release
+  add_custom_target(
+    test_build_${name}
+    ${CMAKE_CTEST_COMMAND}
+    --build-and-test
+    "${CMAKE_CURRENT_SOURCE_DIR}/${name}"
+    "${CMAKE_CURRENT_BINARY_DIR}/${name}"
+    --build-config
+    Release
     --build-noclean
-    --build-generator ${CMAKE_GENERATOR}
-    $<$<BOOL:${CMAKE_GENERATOR_PLATFORM}>:--build-generator-platform> ${CMAKE_GENERATOR_PLATFORM}
-    --build-makeprogram ${CMAKE_MAKE_PROGRAM}
-    --build-target check
-    --build-options ${build_options}
-  )
+    --build-generator
+    ${CMAKE_GENERATOR}
+    $<$<BOOL:${CMAKE_GENERATOR_PLATFORM}>:--build-generator-platform>
+    ${CMAKE_GENERATOR_PLATFORM}
+    --build-makeprogram
+    ${CMAKE_MAKE_PROGRAM}
+    --build-target
+    check_${name}
+    --build-options
+    ${build_options})
   if(ARG_INSTALL)
-    add_dependencies(test_${name} mock_install)
+    add_dependencies(test_build_${name} mock_install)
   endif()
-  add_dependencies(test_cmake_build test_${name})
+  add_dependencies(test_cmake_build test_build_${name})
 endfunction()
 
+possibly_uninitialized(PYTHON_MODULE_EXTENSION Python_INTERPRETER_ID)
+
 pybind11_add_build_test(subdirectory_function)
 pybind11_add_build_test(subdirectory_target)
-if(NOT ${PYTHON_MODULE_EXTENSION} MATCHES "pypy")
+if("${PYTHON_MODULE_EXTENSION}" MATCHES "pypy" OR "${Python_INTERPRETER_ID}" STREQUAL "PyPy")
+  message(STATUS "Skipping embed test on PyPy")
+else()
   pybind11_add_build_test(subdirectory_embed)
 endif()
 
 if(PYBIND11_INSTALL)
-  add_custom_target(mock_install ${CMAKE_COMMAND}
-    "-DCMAKE_INSTALL_PREFIX=${PROJECT_BINARY_DIR}/mock_install"
-    -P "${PROJECT_BINARY_DIR}/cmake_install.cmake"
-  )
+  add_custom_target(
+    mock_install ${CMAKE_COMMAND} "-DCMAKE_INSTALL_PREFIX=${pybind11_BINARY_DIR}/mock_install" -P
+                 "${pybind11_BINARY_DIR}/cmake_install.cmake")
 
   pybind11_add_build_test(installed_function INSTALL)
   pybind11_add_build_test(installed_target INSTALL)
-  if(NOT ${PYTHON_MODULE_EXTENSION} MATCHES "pypy")
+  if(NOT ("${PYTHON_MODULE_EXTENSION}" MATCHES "pypy" OR "${Python_INTERPRETER_ID}" STREQUAL "PyPy"
+         ))
     pybind11_add_build_test(installed_embed INSTALL)
   endif()
 endif()
 
 add_dependencies(check test_cmake_build)
+
+add_subdirectory(subdirectory_target EXCLUDE_FROM_ALL)
+add_subdirectory(subdirectory_embed EXCLUDE_FROM_ALL)
```

### Comparing `stopeight-0.3.14/pybind11/tools/FindCatch.cmake` & `stopeight-0.3.22/stopeight-clibs/pybind11/tools/FindCatch.cmake`

 * *Files 13% similar despite different names*

```diff
@@ -5,44 +5,60 @@
 # a suitable version isn't found locally, the single header file
 # will be downloaded and placed in the build dir: PROJECT_BINARY_DIR.
 #
 # This code sets the following variables:
 #  CATCH_INCLUDE_DIR      - path to catch.hpp
 #  CATCH_VERSION          - version number
 
+option(DOWNLOAD_CATCH "Download catch2 if not found")
+
 if(NOT Catch_FIND_VERSION)
   message(FATAL_ERROR "A version number must be specified.")
 elseif(Catch_FIND_REQUIRED)
   message(FATAL_ERROR "This module assumes Catch is not required.")
 elseif(Catch_FIND_VERSION_EXACT)
   message(FATAL_ERROR "Exact version numbers are not supported, only minimum.")
 endif()
 
 # Extract the version number from catch.hpp
 function(_get_catch_version)
-  file(STRINGS "${CATCH_INCLUDE_DIR}/catch.hpp" version_line REGEX "Catch v.*" LIMIT_COUNT 1)
+  file(
+    STRINGS "${CATCH_INCLUDE_DIR}/catch.hpp" version_line
+    REGEX "Catch v.*"
+    LIMIT_COUNT 1)
   if(version_line MATCHES "Catch v([0-9]+)\\.([0-9]+)\\.([0-9]+)")
-    set(CATCH_VERSION "${CMAKE_MATCH_1}.${CMAKE_MATCH_2}.${CMAKE_MATCH_3}" PARENT_SCOPE)
+    set(CATCH_VERSION
+        "${CMAKE_MATCH_1}.${CMAKE_MATCH_2}.${CMAKE_MATCH_3}"
+        PARENT_SCOPE)
   endif()
 endfunction()
 
 # Download the single-header version of Catch
 function(_download_catch version destination_dir)
   message(STATUS "Downloading catch v${version}...")
   set(url https://github.com/philsquared/Catch/releases/download/v${version}/catch.hpp)
-  file(DOWNLOAD ${url} "${destination_dir}/catch.hpp" STATUS status)
+  file(
+    DOWNLOAD ${url} "${destination_dir}/catch.hpp"
+    STATUS status
+    LOG log)
   list(GET status 0 error)
   if(error)
-    message(FATAL_ERROR "Could not download ${url}")
+    string(REPLACE "\n" "\n  " log "  ${log}")
+    message(FATAL_ERROR "Could not download URL:\n" "  ${url}\n" "Log:\n" "${log}")
   endif()
-  set(CATCH_INCLUDE_DIR "${destination_dir}" CACHE INTERNAL "")
+  set(CATCH_INCLUDE_DIR
+      "${destination_dir}"
+      CACHE INTERNAL "")
 endfunction()
 
 # Look for catch locally
-find_path(CATCH_INCLUDE_DIR NAMES catch.hpp PATH_SUFFIXES catch)
+find_path(
+  CATCH_INCLUDE_DIR
+  NAMES catch.hpp
+  PATH_SUFFIXES catch2)
 if(CATCH_INCLUDE_DIR)
   _get_catch_version()
 endif()
 
 # Download the header if it wasn't found or if it's outdated
 if(NOT CATCH_VERSION OR CATCH_VERSION VERSION_LESS ${Catch_FIND_VERSION})
   if(DOWNLOAD_CATCH)
@@ -50,8 +66,11 @@
     _get_catch_version()
   else()
     set(CATCH_FOUND FALSE)
     return()
   endif()
 endif()
 
+add_library(Catch2::Catch2 IMPORTED INTERFACE)
+set_property(TARGET Catch2::Catch2 PROPERTY INTERFACE_INCLUDE_DIRECTORIES "${CATCH_INCLUDE_DIR}")
+
 set(CATCH_FOUND TRUE)
```

### Comparing `stopeight-0.3.14/pybind11/tools/FindEigen3.cmake` & `stopeight-0.3.22/stopeight-clibs/pybind11/tools/FindEigen3.cmake`

 * *Files 8% similar despite different names*

```diff
@@ -22,25 +22,29 @@
   if(NOT Eigen3_FIND_VERSION_MINOR)
     set(Eigen3_FIND_VERSION_MINOR 91)
   endif(NOT Eigen3_FIND_VERSION_MINOR)
   if(NOT Eigen3_FIND_VERSION_PATCH)
     set(Eigen3_FIND_VERSION_PATCH 0)
   endif(NOT Eigen3_FIND_VERSION_PATCH)
 
-  set(Eigen3_FIND_VERSION "${Eigen3_FIND_VERSION_MAJOR}.${Eigen3_FIND_VERSION_MINOR}.${Eigen3_FIND_VERSION_PATCH}")
+  set(Eigen3_FIND_VERSION
+      "${Eigen3_FIND_VERSION_MAJOR}.${Eigen3_FIND_VERSION_MINOR}.${Eigen3_FIND_VERSION_PATCH}")
 endif(NOT Eigen3_FIND_VERSION)
 
 macro(_eigen3_check_version)
   file(READ "${EIGEN3_INCLUDE_DIR}/Eigen/src/Core/util/Macros.h" _eigen3_version_header)
 
-  string(REGEX MATCH "define[ \t]+EIGEN_WORLD_VERSION[ \t]+([0-9]+)" _eigen3_world_version_match "${_eigen3_version_header}")
+  string(REGEX MATCH "define[ \t]+EIGEN_WORLD_VERSION[ \t]+([0-9]+)" _eigen3_world_version_match
+               "${_eigen3_version_header}")
   set(EIGEN3_WORLD_VERSION "${CMAKE_MATCH_1}")
-  string(REGEX MATCH "define[ \t]+EIGEN_MAJOR_VERSION[ \t]+([0-9]+)" _eigen3_major_version_match "${_eigen3_version_header}")
+  string(REGEX MATCH "define[ \t]+EIGEN_MAJOR_VERSION[ \t]+([0-9]+)" _eigen3_major_version_match
+               "${_eigen3_version_header}")
   set(EIGEN3_MAJOR_VERSION "${CMAKE_MATCH_1}")
-  string(REGEX MATCH "define[ \t]+EIGEN_MINOR_VERSION[ \t]+([0-9]+)" _eigen3_minor_version_match "${_eigen3_version_header}")
+  string(REGEX MATCH "define[ \t]+EIGEN_MINOR_VERSION[ \t]+([0-9]+)" _eigen3_minor_version_match
+               "${_eigen3_version_header}")
   set(EIGEN3_MINOR_VERSION "${CMAKE_MATCH_1}")
 
   set(EIGEN3_VERSION ${EIGEN3_WORLD_VERSION}.${EIGEN3_MAJOR_VERSION}.${EIGEN3_MINOR_VERSION})
   if(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
     set(EIGEN3_VERSION_OK FALSE)
   else(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
     set(EIGEN3_VERSION_OK TRUE)
@@ -49,33 +53,34 @@
   if(NOT EIGEN3_VERSION_OK)
 
     message(STATUS "Eigen3 version ${EIGEN3_VERSION} found in ${EIGEN3_INCLUDE_DIR}, "
                    "but at least version ${Eigen3_FIND_VERSION} is required")
   endif(NOT EIGEN3_VERSION_OK)
 endmacro(_eigen3_check_version)
 
-if (EIGEN3_INCLUDE_DIR)
+if(EIGEN3_INCLUDE_DIR)
 
   # in cache already
   _eigen3_check_version()
   set(EIGEN3_FOUND ${EIGEN3_VERSION_OK})
 
-else (EIGEN3_INCLUDE_DIR)
-
-  find_path(EIGEN3_INCLUDE_DIR NAMES signature_of_eigen3_matrix_library
-      PATHS
-      ${CMAKE_INSTALL_PREFIX}/include
-      ${KDE4_INCLUDE_DIR}
-      PATH_SUFFIXES eigen3 eigen
-    )
+else(EIGEN3_INCLUDE_DIR)
+  if(NOT DEFINED KDE4_INCLUDE_DIR)
+    set(KDE4_INCLUDE_DIR "")
+  endif()
+
+  find_path(
+    EIGEN3_INCLUDE_DIR
+    NAMES signature_of_eigen3_matrix_library
+    PATHS ${CMAKE_INSTALL_PREFIX}/include ${KDE4_INCLUDE_DIR}
+    PATH_SUFFIXES eigen3 eigen)
 
   if(EIGEN3_INCLUDE_DIR)
     _eigen3_check_version()
   endif(EIGEN3_INCLUDE_DIR)
 
   include(FindPackageHandleStandardArgs)
   find_package_handle_standard_args(Eigen3 DEFAULT_MSG EIGEN3_INCLUDE_DIR EIGEN3_VERSION_OK)
 
   mark_as_advanced(EIGEN3_INCLUDE_DIR)
 
 endif(EIGEN3_INCLUDE_DIR)
-
```

### Comparing `stopeight-0.3.14/pybind11/tools/FindPythonLibsNew.cmake` & `stopeight-0.3.22/stopeight-clibs/pybind11/tools/FindPythonLibsNew.cmake`

 * *Files 24% similar despite different names*

```diff
@@ -48,155 +48,240 @@
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #=============================================================================
 
 # Checking for the extension makes sure that `LibsNew` was found and not just `Libs`.
 if(PYTHONLIBS_FOUND AND PYTHON_MODULE_EXTENSION)
-    return()
+  return()
 endif()
 
-# Use the Python interpreter to find the libs.
-if(PythonLibsNew_FIND_REQUIRED)
-    find_package(PythonInterp ${PythonLibsNew_FIND_VERSION} REQUIRED)
+if(PythonLibsNew_FIND_QUIETLY)
+  set(_pythonlibs_quiet QUIET)
 else()
-    find_package(PythonInterp ${PythonLibsNew_FIND_VERSION})
+  set(_pythonlibs_quiet "")
+endif()
+
+if(PythonLibsNew_FIND_REQUIRED)
+  set(_pythonlibs_required REQUIRED)
+endif()
+
+# Check to see if the `python` command is present and from a virtual
+# environment, conda, or GHA activation - if it is, try to use that.
+
+if(NOT DEFINED PYTHON_EXECUTABLE)
+  if(DEFINED ENV{VIRTUAL_ENV})
+    find_program(
+      PYTHON_EXECUTABLE python
+      PATHS "$ENV{VIRTUAL_ENV}" "$ENV{VIRTUAL_ENV}/bin"
+      NO_DEFAULT_PATH)
+  elseif(DEFINED ENV{CONDA_PREFIX})
+    find_program(
+      PYTHON_EXECUTABLE python
+      PATHS "$ENV{CONDA_PREFIX}" "$ENV{CONDA_PREFIX}/bin"
+      NO_DEFAULT_PATH)
+  elseif(DEFINED ENV{pythonLocation})
+    find_program(
+      PYTHON_EXECUTABLE python
+      PATHS "$ENV{pythonLocation}" "$ENV{pythonLocation}/bin"
+      NO_DEFAULT_PATH)
+  endif()
+  if(NOT PYTHON_EXECUTABLE)
+    unset(PYTHON_EXECUTABLE)
+  endif()
+endif()
+
+# Use the Python interpreter to find the libs.
+if(NOT PythonLibsNew_FIND_VERSION)
+  set(PythonLibsNew_FIND_VERSION "3.6")
 endif()
 
+find_package(PythonInterp ${PythonLibsNew_FIND_VERSION} ${_pythonlibs_required}
+             ${_pythonlibs_quiet})
+
 if(NOT PYTHONINTERP_FOUND)
-    set(PYTHONLIBS_FOUND FALSE)
-    set(PythonLibsNew_FOUND FALSE)
-    return()
+  set(PYTHONLIBS_FOUND FALSE)
+  set(PythonLibsNew_FOUND FALSE)
+  return()
 endif()
 
-# According to http://stackoverflow.com/questions/646518/python-how-to-detect-debug-interpreter
+# According to https://stackoverflow.com/questions/646518/python-how-to-detect-debug-interpreter
 # testing whether sys has the gettotalrefcount function is a reliable, cross-platform
 # way to detect a CPython debug interpreter.
 #
 # The library suffix is from the config var LDVERSION sometimes, otherwise
 # VERSION. VERSION will typically be like "2.7" on unix, and "27" on windows.
-execute_process(COMMAND "${PYTHON_EXECUTABLE}" "-c"
-    "from distutils import sysconfig as s;import sys;import struct;
+execute_process(
+  COMMAND
+    "${PYTHON_EXECUTABLE}" "-c" "
+import sys;import struct;
+import sysconfig as s
+USE_SYSCONFIG = sys.version_info >= (3, 10)
+if not USE_SYSCONFIG:
+    from distutils import sysconfig as ds
 print('.'.join(str(v) for v in sys.version_info));
 print(sys.prefix);
-print(s.get_python_inc(plat_specific=True));
-print(s.get_python_lib(plat_specific=True));
-print(s.get_config_var('SO'));
+if USE_SYSCONFIG:
+    scheme = s.get_default_scheme()
+    if scheme == 'posix_local':
+        # Debian's default scheme installs to /usr/local/ but we want to find headers in /usr/
+        scheme = 'posix_prefix'
+    print(s.get_path('platinclude', scheme))
+    print(s.get_path('platlib'))
+    print(s.get_config_var('EXT_SUFFIX') or s.get_config_var('SO'))
+else:
+    print(ds.get_python_inc(plat_specific=True));
+    print(ds.get_python_lib(plat_specific=True));
+    print(ds.get_config_var('EXT_SUFFIX') or ds.get_config_var('SO'));
 print(hasattr(sys, 'gettotalrefcount')+0);
 print(struct.calcsize('@P'));
 print(s.get_config_var('LDVERSION') or s.get_config_var('VERSION'));
 print(s.get_config_var('LIBDIR') or '');
 print(s.get_config_var('MULTIARCH') or '');
 "
-    RESULT_VARIABLE _PYTHON_SUCCESS
-    OUTPUT_VARIABLE _PYTHON_VALUES
-    ERROR_VARIABLE _PYTHON_ERROR_VALUE)
+  RESULT_VARIABLE _PYTHON_SUCCESS
+  OUTPUT_VARIABLE _PYTHON_VALUES
+  ERROR_VARIABLE _PYTHON_ERROR_VALUE)
 
 if(NOT _PYTHON_SUCCESS MATCHES 0)
-    if(PythonLibsNew_FIND_REQUIRED)
-        message(FATAL_ERROR
-            "Python config failure:\n${_PYTHON_ERROR_VALUE}")
-    endif()
-    set(PYTHONLIBS_FOUND FALSE)
-    set(PythonLibsNew_FOUND FALSE)
-    return()
-endif()
+  if(PythonLibsNew_FIND_REQUIRED)
+    message(FATAL_ERROR "Python config failure:\n${_PYTHON_ERROR_VALUE}")
+  endif()
+  set(PYTHONLIBS_FOUND FALSE)
+  set(PythonLibsNew_FOUND FALSE)
+  return()
+endif()
+
+option(
+  PYBIND11_PYTHONLIBS_OVERWRITE
+  "Overwrite cached values read from Python library (classic search). Turn off if cross-compiling and manually setting these values."
+  ON)
+# Can manually set values when cross-compiling
+macro(_PYBIND11_GET_IF_UNDEF lst index name)
+  if(PYBIND11_PYTHONLIBS_OVERWRITE OR NOT DEFINED "${name}")
+    list(GET "${lst}" "${index}" "${name}")
+  endif()
+endmacro()
 
 # Convert the process output into a list
 if(WIN32)
-    string(REGEX REPLACE "\\\\" "/" _PYTHON_VALUES ${_PYTHON_VALUES})
+  string(REGEX REPLACE "\\\\" "/" _PYTHON_VALUES ${_PYTHON_VALUES})
 endif()
 string(REGEX REPLACE ";" "\\\\;" _PYTHON_VALUES ${_PYTHON_VALUES})
 string(REGEX REPLACE "\n" ";" _PYTHON_VALUES ${_PYTHON_VALUES})
-list(GET _PYTHON_VALUES 0 _PYTHON_VERSION_LIST)
-list(GET _PYTHON_VALUES 1 PYTHON_PREFIX)
-list(GET _PYTHON_VALUES 2 PYTHON_INCLUDE_DIR)
-list(GET _PYTHON_VALUES 3 PYTHON_SITE_PACKAGES)
-list(GET _PYTHON_VALUES 4 PYTHON_MODULE_EXTENSION)
-list(GET _PYTHON_VALUES 5 PYTHON_IS_DEBUG)
-list(GET _PYTHON_VALUES 6 PYTHON_SIZEOF_VOID_P)
-list(GET _PYTHON_VALUES 7 PYTHON_LIBRARY_SUFFIX)
-list(GET _PYTHON_VALUES 8 PYTHON_LIBDIR)
-list(GET _PYTHON_VALUES 9 PYTHON_MULTIARCH)
+_pybind11_get_if_undef(_PYTHON_VALUES 0 _PYTHON_VERSION_LIST)
+_pybind11_get_if_undef(_PYTHON_VALUES 1 PYTHON_PREFIX)
+_pybind11_get_if_undef(_PYTHON_VALUES 2 PYTHON_INCLUDE_DIR)
+_pybind11_get_if_undef(_PYTHON_VALUES 3 PYTHON_SITE_PACKAGES)
+_pybind11_get_if_undef(_PYTHON_VALUES 4 PYTHON_MODULE_EXTENSION)
+_pybind11_get_if_undef(_PYTHON_VALUES 5 PYTHON_IS_DEBUG)
+_pybind11_get_if_undef(_PYTHON_VALUES 6 PYTHON_SIZEOF_VOID_P)
+_pybind11_get_if_undef(_PYTHON_VALUES 7 PYTHON_LIBRARY_SUFFIX)
+_pybind11_get_if_undef(_PYTHON_VALUES 8 PYTHON_LIBDIR)
+_pybind11_get_if_undef(_PYTHON_VALUES 9 PYTHON_MULTIARCH)
 
 # Make sure the Python has the same pointer-size as the chosen compiler
 # Skip if CMAKE_SIZEOF_VOID_P is not defined
-if(CMAKE_SIZEOF_VOID_P AND (NOT "${PYTHON_SIZEOF_VOID_P}" STREQUAL "${CMAKE_SIZEOF_VOID_P}"))
-    if(PythonLibsNew_FIND_REQUIRED)
-        math(EXPR _PYTHON_BITS "${PYTHON_SIZEOF_VOID_P} * 8")
-        math(EXPR _CMAKE_BITS "${CMAKE_SIZEOF_VOID_P} * 8")
-        message(FATAL_ERROR
-            "Python config failure: Python is ${_PYTHON_BITS}-bit, "
-            "chosen compiler is  ${_CMAKE_BITS}-bit")
-    endif()
-    set(PYTHONLIBS_FOUND FALSE)
-    set(PythonLibsNew_FOUND FALSE)
-    return()
+# This should be skipped for (non-Apple) cross-compiles (like EMSCRIPTEN)
+if(NOT CMAKE_CROSSCOMPILING
+   AND CMAKE_SIZEOF_VOID_P
+   AND (NOT "${PYTHON_SIZEOF_VOID_P}" STREQUAL "${CMAKE_SIZEOF_VOID_P}"))
+  if(PythonLibsNew_FIND_REQUIRED)
+    math(EXPR _PYTHON_BITS "${PYTHON_SIZEOF_VOID_P} * 8")
+    math(EXPR _CMAKE_BITS "${CMAKE_SIZEOF_VOID_P} * 8")
+    message(FATAL_ERROR "Python config failure: Python is ${_PYTHON_BITS}-bit, "
+                        "chosen compiler is  ${_CMAKE_BITS}-bit")
+  endif()
+  set(PYTHONLIBS_FOUND FALSE)
+  set(PythonLibsNew_FOUND FALSE)
+  return()
 endif()
 
 # The built-in FindPython didn't always give the version numbers
 string(REGEX REPLACE "\\." ";" _PYTHON_VERSION_LIST ${_PYTHON_VERSION_LIST})
 list(GET _PYTHON_VERSION_LIST 0 PYTHON_VERSION_MAJOR)
 list(GET _PYTHON_VERSION_LIST 1 PYTHON_VERSION_MINOR)
 list(GET _PYTHON_VERSION_LIST 2 PYTHON_VERSION_PATCH)
+set(PYTHON_VERSION "${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR}.${PYTHON_VERSION_PATCH}")
 
 # Make sure all directory separators are '/'
 string(REGEX REPLACE "\\\\" "/" PYTHON_PREFIX "${PYTHON_PREFIX}")
 string(REGEX REPLACE "\\\\" "/" PYTHON_INCLUDE_DIR "${PYTHON_INCLUDE_DIR}")
 string(REGEX REPLACE "\\\\" "/" PYTHON_SITE_PACKAGES "${PYTHON_SITE_PACKAGES}")
 
-if(CMAKE_HOST_WIN32 AND NOT (MINGW AND DEFINED ENV{MSYSTEM}))
-    set(PYTHON_LIBRARY
-        "${PYTHON_PREFIX}/libs/Python${PYTHON_LIBRARY_SUFFIX}.lib")
-
-    # when run in a venv, PYTHON_PREFIX points to it. But the libraries remain in the
-    # original python installation. They may be found relative to PYTHON_INCLUDE_DIR.
-    if(NOT EXISTS "${PYTHON_LIBRARY}")
-        get_filename_component(_PYTHON_ROOT ${PYTHON_INCLUDE_DIR} DIRECTORY)
-        set(PYTHON_LIBRARY
-            "${_PYTHON_ROOT}/libs/Python${PYTHON_LIBRARY_SUFFIX}.lib")
-    endif()
-
-    # raise an error if the python libs are still not found.
-    if(NOT EXISTS "${PYTHON_LIBRARY}")
-        message(FATAL_ERROR "Python libraries not found")
-    endif()
-
-else()
+if(DEFINED PYTHON_LIBRARY)
+  # Don't write to PYTHON_LIBRARY if it's already set
+elseif(CMAKE_HOST_WIN32)
+  set(PYTHON_LIBRARY "${PYTHON_PREFIX}/libs/python${PYTHON_LIBRARY_SUFFIX}.lib")
+
+  # when run in a venv, PYTHON_PREFIX points to it. But the libraries remain in the
+  # original python installation. They may be found relative to PYTHON_INCLUDE_DIR.
+  if(NOT EXISTS "${PYTHON_LIBRARY}")
+    get_filename_component(_PYTHON_ROOT ${PYTHON_INCLUDE_DIR} DIRECTORY)
+    set(PYTHON_LIBRARY "${_PYTHON_ROOT}/libs/python${PYTHON_LIBRARY_SUFFIX}.lib")
+  endif()
+
+  # if we are in MSYS & MINGW, and we didn't find windows python lib, look for system python lib
+  if(DEFINED ENV{MSYSTEM}
+     AND MINGW
+     AND NOT EXISTS "${PYTHON_LIBRARY}")
     if(PYTHON_MULTIARCH)
-        set(_PYTHON_LIBS_SEARCH "${PYTHON_LIBDIR}/${PYTHON_MULTIARCH}" "${PYTHON_LIBDIR}")
+      set(_PYTHON_LIBS_SEARCH "${PYTHON_LIBDIR}/${PYTHON_MULTIARCH}" "${PYTHON_LIBDIR}")
     else()
-        set(_PYTHON_LIBS_SEARCH "${PYTHON_LIBDIR}")
-    endif()
-    #message(STATUS "Searching for Python libs in ${_PYTHON_LIBS_SEARCH}")
-    # Probably this needs to be more involved. It would be nice if the config
-    # information the python interpreter itself gave us were more complete.
-    find_library(PYTHON_LIBRARY
-        NAMES "python${PYTHON_LIBRARY_SUFFIX}"
-        PATHS ${_PYTHON_LIBS_SEARCH}
-        NO_DEFAULT_PATH)
-
-    # If all else fails, just set the name/version and let the linker figure out the path.
-    if(NOT PYTHON_LIBRARY)
-        set(PYTHON_LIBRARY python${PYTHON_LIBRARY_SUFFIX})
+      set(_PYTHON_LIBS_SEARCH "${PYTHON_LIBDIR}")
     endif()
+    unset(PYTHON_LIBRARY)
+    find_library(
+      PYTHON_LIBRARY
+      NAMES "python${PYTHON_LIBRARY_SUFFIX}"
+      PATHS ${_PYTHON_LIBS_SEARCH}
+      NO_DEFAULT_PATH)
+  endif()
+
+  # raise an error if the python libs are still not found.
+  if(NOT EXISTS "${PYTHON_LIBRARY}")
+    message(FATAL_ERROR "Python libraries not found")
+  endif()
+
+else()
+  if(PYTHON_MULTIARCH)
+    set(_PYTHON_LIBS_SEARCH "${PYTHON_LIBDIR}/${PYTHON_MULTIARCH}" "${PYTHON_LIBDIR}")
+  else()
+    set(_PYTHON_LIBS_SEARCH "${PYTHON_LIBDIR}")
+  endif()
+  #message(STATUS "Searching for Python libs in ${_PYTHON_LIBS_SEARCH}")
+  # Probably this needs to be more involved. It would be nice if the config
+  # information the python interpreter itself gave us were more complete.
+  find_library(
+    PYTHON_LIBRARY
+    NAMES "python${PYTHON_LIBRARY_SUFFIX}"
+    PATHS ${_PYTHON_LIBS_SEARCH}
+    NO_DEFAULT_PATH)
+
+  # If all else fails, just set the name/version and let the linker figure out the path.
+  if(NOT PYTHON_LIBRARY)
+    set(PYTHON_LIBRARY python${PYTHON_LIBRARY_SUFFIX})
+  endif()
 endif()
 
-MARK_AS_ADVANCED(
-  PYTHON_LIBRARY
-  PYTHON_INCLUDE_DIR
-)
+mark_as_advanced(PYTHON_LIBRARY PYTHON_INCLUDE_DIR)
 
 # We use PYTHON_INCLUDE_DIR, PYTHON_LIBRARY and PYTHON_DEBUG_LIBRARY for the
 # cache entries because they are meant to specify the location of a single
 # library. We now set the variables listed by the documentation for this
 # module.
-SET(PYTHON_INCLUDE_DIRS "${PYTHON_INCLUDE_DIR}")
-SET(PYTHON_LIBRARIES "${PYTHON_LIBRARY}")
-SET(PYTHON_DEBUG_LIBRARIES "${PYTHON_DEBUG_LIBRARY}")
-
-find_package_message(PYTHON
-    "Found PythonLibs: ${PYTHON_LIBRARY}"
-    "${PYTHON_EXECUTABLE}${PYTHON_VERSION}")
+set(PYTHON_INCLUDE_DIRS "${PYTHON_INCLUDE_DIR}")
+set(PYTHON_LIBRARIES "${PYTHON_LIBRARY}")
+if(NOT PYTHON_DEBUG_LIBRARY)
+  set(PYTHON_DEBUG_LIBRARY "")
+endif()
+set(PYTHON_DEBUG_LIBRARIES "${PYTHON_DEBUG_LIBRARY}")
+
+find_package_message(PYTHON "Found PythonLibs: ${PYTHON_LIBRARIES}"
+                     "${PYTHON_EXECUTABLE}${PYTHON_VERSION_STRING}")
 
 set(PYTHONLIBS_FOUND TRUE)
 set(PythonLibsNew_FOUND TRUE)
+
+if(NOT PYTHON_MODULE_PREFIX)
+  set(PYTHON_MODULE_PREFIX "")
+endif()
```

### Comparing `stopeight-0.3.14/pybind11/tools/pybind11Tools.cmake` & `stopeight-0.3.22/stopeight-clibs/pybind11/tools/pybind11NewTools.cmake`

 * *Files 27% similar despite different names*

```diff
@@ -1,243 +1,256 @@
-# tools/pybind11Tools.cmake -- Build system for the pybind11 modules
+# tools/pybind11NewTools.cmake -- Build system for the pybind11 modules
 #
-# Copyright (c) 2015 Wenzel Jakob <wenzel@inf.ethz.ch>
+# Copyright (c) 2020 Wenzel Jakob <wenzel@inf.ethz.ch> and Henry Schreiner
 #
 # All rights reserved. Use of this source code is governed by a
 # BSD-style license that can be found in the LICENSE file.
 
-cmake_minimum_required(VERSION 2.8.12)
+if(CMAKE_VERSION VERSION_LESS 3.12)
+  message(FATAL_ERROR "You cannot use the new FindPython module with CMake < 3.12")
+endif()
 
-# Add a CMake parameter for choosing a desired Python version
-if(NOT PYBIND11_PYTHON_VERSION)
-  set(PYBIND11_PYTHON_VERSION "" CACHE STRING "Python version to use for compiling modules")
-endif()
-
-set(Python_ADDITIONAL_VERSIONS 3.9 3.8 3.7 3.6 3.5 3.4)
-find_package(PythonLibsNew ${PYBIND11_PYTHON_VERSION} REQUIRED)
-
-include(CheckCXXCompilerFlag)
-include(CMakeParseArguments)
-
-# Use the language standards abstraction if CMake supports it with the current compiler
-if(NOT CMAKE_VERSION VERSION_LESS 3.1)
-  if(NOT CMAKE_CXX_STANDARD)
-    if(CMAKE_CXX14_STANDARD_COMPILE_OPTION)
-      set(CMAKE_CXX_STANDARD 14)
-    elseif(CMAKE_CXX11_STANDARD_COMPILE_OPTION)
-      set(CMAKE_CXX_STANDARD 11)
-    endif()
+include_guard(DIRECTORY)
+
+get_property(
+  is_config
+  TARGET pybind11::headers
+  PROPERTY IMPORTED)
+
+if(pybind11_FIND_QUIETLY)
+  set(_pybind11_quiet QUIET)
+else()
+  set(_pybind11_quiet "")
+endif()
+
+if(NOT Python_FOUND AND NOT Python3_FOUND)
+  if(NOT DEFINED Python_FIND_IMPLEMENTATIONS)
+    set(Python_FIND_IMPLEMENTATIONS CPython PyPy)
   endif()
-  if(CMAKE_CXX_STANDARD)
-    set(CMAKE_CXX_EXTENSIONS OFF)
-    set(CMAKE_CXX_STANDARD_REQUIRED ON)
+
+  # GitHub Actions like activation
+  if(NOT DEFINED Python_ROOT_DIR AND DEFINED ENV{pythonLocation})
+    set(Python_ROOT_DIR "$ENV{pythonLocation}")
   endif()
-endif()
 
-# Fall back to heuristics 
-if(NOT PYBIND11_CPP_STANDARD AND NOT CMAKE_CXX_STANDARD)
-  if(MSVC)
-    set(PYBIND11_CPP_STANDARD /std:c++14)
-  else()
-    check_cxx_compiler_flag("-std=c++14" HAS_CPP14_FLAG)
-    if(HAS_CPP14_FLAG)
-      set(PYBIND11_CPP_STANDARD -std=c++14)
-    else()
-      check_cxx_compiler_flag("-std=c++11" HAS_CPP11_FLAG)
-      if(HAS_CPP11_FLAG)
-        set(PYBIND11_CPP_STANDARD -std=c++11)
-      endif()
+  find_package(Python 3.6 REQUIRED COMPONENTS Interpreter Development ${_pybind11_quiet})
+
+  # If we are in submodule mode, export the Python targets to global targets.
+  # If this behavior is not desired, FindPython _before_ pybind11.
+  if(NOT is_config)
+    set_property(TARGET Python::Python PROPERTY IMPORTED_GLOBAL TRUE)
+    set_property(TARGET Python::Interpreter PROPERTY IMPORTED_GLOBAL TRUE)
+    if(TARGET Python::Module)
+      set_property(TARGET Python::Module PROPERTY IMPORTED_GLOBAL TRUE)
     endif()
   endif()
+endif()
 
-  if(NOT PYBIND11_CPP_STANDARD)
-    message(FATAL_ERROR "Unsupported compiler -- pybind11 requires C++11 support!")
-  endif()
-  set(PYBIND11_CPP_STANDARD ${PYBIND11_CPP_STANDARD} CACHE STRING
-      "C++ standard flag, e.g. -std=c++11, -std=c++14, /std:c++14.  Defaults to C++14 mode." FORCE)
+if(Python_FOUND)
+  set(_Python
+      Python
+      CACHE INTERNAL "" FORCE)
+elseif(Python3_FOUND)
+  set(_Python
+      Python3
+      CACHE INTERNAL "" FORCE)
 endif()
 
-# Checks whether the given CXX/linker flags can compile and link a cxx file.  cxxflags and
-# linkerflags are lists of flags to use.  The result variable is a unique variable name for each set
-# of flags: the compilation result will be cached base on the result variable.  If the flags work,
-# sets them in cxxflags_out/linkerflags_out internal cache variables (in addition to ${result}).
-function(_pybind11_return_if_cxx_and_linker_flags_work result cxxflags linkerflags cxxflags_out linkerflags_out)
-  set(CMAKE_REQUIRED_LIBRARIES ${linkerflags})
-  check_cxx_compiler_flag("${cxxflags}" ${result})
-  if (${result})
-    set(${cxxflags_out} "${cxxflags}" CACHE INTERNAL "" FORCE)
-    set(${linkerflags_out} "${linkerflags}" CACHE INTERNAL "" FORCE)
+if(PYBIND11_MASTER_PROJECT)
+  if(${_Python}_INTERPRETER_ID MATCHES "PyPy")
+    message(STATUS "PyPy ${${_Python}_PyPy_VERSION} (Py ${${_Python}_VERSION})")
+  else()
+    message(STATUS "${_Python} ${${_Python}_VERSION}")
   endif()
-endfunction()
+endif()
 
-# Internal: find the appropriate link time optimization flags for this compiler
-function(_pybind11_add_lto_flags target_name prefer_thin_lto)
-  if (NOT DEFINED PYBIND11_LTO_CXX_FLAGS)
-    set(PYBIND11_LTO_CXX_FLAGS "" CACHE INTERNAL "")
-    set(PYBIND11_LTO_LINKER_FLAGS "" CACHE INTERNAL "")
-
-    if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
-      set(cxx_append "")
-      set(linker_append "")
-      if (CMAKE_CXX_COMPILER_ID MATCHES "Clang" AND NOT APPLE)
-        # Clang Gold plugin does not support -Os; append -O3 to MinSizeRel builds to override it
-        set(linker_append ";$<$<CONFIG:MinSizeRel>:-O3>")
-      elseif(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
-        set(cxx_append ";-fno-fat-lto-objects")
-      endif()
-
-      if (CMAKE_CXX_COMPILER_ID MATCHES "Clang" AND prefer_thin_lto)
-        _pybind11_return_if_cxx_and_linker_flags_work(HAS_FLTO_THIN
-          "-flto=thin${cxx_append}" "-flto=thin${linker_append}"
-          PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)
-      endif()
-
-      if (NOT HAS_FLTO_THIN)
-        _pybind11_return_if_cxx_and_linker_flags_work(HAS_FLTO
-          "-flto${cxx_append}" "-flto${linker_append}"
-          PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)
-      endif()
-    elseif (CMAKE_CXX_COMPILER_ID MATCHES "Intel")
-      # Intel equivalent to LTO is called IPO
-      _pybind11_return_if_cxx_and_linker_flags_work(HAS_INTEL_IPO
-      "-ipo" "-ipo" PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)
-    elseif(MSVC)
-      # cmake only interprets libraries as linker flags when they start with a - (otherwise it
-      # converts /LTCG to \LTCG as if it was a Windows path).  Luckily MSVC supports passing flags
-      # with - instead of /, even if it is a bit non-standard:
-      _pybind11_return_if_cxx_and_linker_flags_work(HAS_MSVC_GL_LTCG
-        "/GL" "-LTCG" PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)
-    endif()
+# If a user finds Python, they may forget to include the Interpreter component
+# and the following two steps require it. It is highly recommended by CMake
+# when finding development libraries anyway, so we will require it.
+if(NOT DEFINED ${_Python}_EXECUTABLE)
+  message(
+    FATAL_ERROR
+      "${_Python} was found without the Interpreter component. Pybind11 requires this component.")
 
-    if (PYBIND11_LTO_CXX_FLAGS)
-      message(STATUS "LTO enabled")
-    else()
-      message(STATUS "LTO disabled (not supported by the compiler and/or linker)")
-    endif()
-  endif()
+endif()
 
-  # Enable LTO flags if found, except for Debug builds
-  if (PYBIND11_LTO_CXX_FLAGS)
-    target_compile_options(${target_name} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:${PYBIND11_LTO_CXX_FLAGS}>")
-  endif()
-  if (PYBIND11_LTO_LINKER_FLAGS)
-    target_link_libraries(${target_name} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:${PYBIND11_LTO_LINKER_FLAGS}>")
-  endif()
-endfunction()
+if(NOT ${_Python}_EXECUTABLE STREQUAL PYBIND11_PYTHON_EXECUTABLE_LAST)
+  # Detect changes to the Python version/binary in subsequent CMake runs, and refresh config if needed
+  unset(PYTHON_IS_DEBUG CACHE)
+  unset(PYTHON_MODULE_EXTENSION CACHE)
+  set(PYBIND11_PYTHON_EXECUTABLE_LAST
+      "${${_Python}_EXECUTABLE}"
+      CACHE INTERNAL "Python executable during the last CMake run")
+endif()
 
-# Build a Python extension module:
-# pybind11_add_module(<name> [MODULE | SHARED] [EXCLUDE_FROM_ALL]
-#                     [NO_EXTRAS] [SYSTEM] [THIN_LTO] source1 [source2 ...])
-#
+if(NOT DEFINED PYTHON_IS_DEBUG)
+  # Debug check - see https://stackoverflow.com/questions/646518/python-how-to-detect-debug-Interpreter
+  execute_process(
+    COMMAND "${${_Python}_EXECUTABLE}" "-c"
+            "import sys; sys.exit(hasattr(sys, 'gettotalrefcount'))"
+    RESULT_VARIABLE _PYTHON_IS_DEBUG)
+  set(PYTHON_IS_DEBUG
+      "${_PYTHON_IS_DEBUG}"
+      CACHE INTERNAL "Python debug status")
+endif()
+
+# Get the suffix - SO is deprecated, should use EXT_SUFFIX, but this is
+# required for PyPy3 (as of 7.3.1)
+if(NOT DEFINED PYTHON_MODULE_EXTENSION)
+  execute_process(
+    COMMAND
+      "${${_Python}_EXECUTABLE}" "-c"
+      "import sys, importlib; s = importlib.import_module('distutils.sysconfig' if sys.version_info < (3, 10) else 'sysconfig'); print(s.get_config_var('EXT_SUFFIX') or s.get_config_var('SO'))"
+    OUTPUT_VARIABLE _PYTHON_MODULE_EXTENSION
+    ERROR_VARIABLE _PYTHON_MODULE_EXTENSION_ERR
+    OUTPUT_STRIP_TRAILING_WHITESPACE)
+
+  if(_PYTHON_MODULE_EXTENSION STREQUAL "")
+    message(
+      FATAL_ERROR "pybind11 could not query the module file extension, likely the 'distutils'"
+                  "package is not installed. Full error message:\n${_PYTHON_MODULE_EXTENSION_ERR}")
+  endif()
+
+  # This needs to be available for the pybind11_extension function
+  set(PYTHON_MODULE_EXTENSION
+      "${_PYTHON_MODULE_EXTENSION}"
+      CACHE INTERNAL "")
+endif()
+
+# Python debug libraries expose slightly different objects before 3.8
+# https://docs.python.org/3.6/c-api/intro.html#debugging-builds
+# https://stackoverflow.com/questions/39161202/how-to-work-around-missing-pymodule-create2-in-amd64-win-python35-d-lib
+if(PYTHON_IS_DEBUG)
+  set_property(
+    TARGET pybind11::pybind11
+    APPEND
+    PROPERTY INTERFACE_COMPILE_DEFINITIONS Py_DEBUG)
+endif()
+
+# Check on every access - since Python can change - do nothing in that case.
+
+if(DEFINED ${_Python}_INCLUDE_DIRS)
+  # Only add Python for build - must be added during the import for config
+  # since it has to be re-discovered.
+  #
+  # This needs to be a target to be included after the local pybind11
+  # directory, just in case there there is an installed pybind11 sitting
+  # next to Python's includes. It also ensures Python is a SYSTEM library.
+  add_library(pybind11::python_headers INTERFACE IMPORTED)
+  set_property(
+    TARGET pybind11::python_headers PROPERTY INTERFACE_INCLUDE_DIRECTORIES
+                                             "$<BUILD_INTERFACE:${${_Python}_INCLUDE_DIRS}>")
+  set_property(
+    TARGET pybind11::pybind11
+    APPEND
+    PROPERTY INTERFACE_LINK_LIBRARIES pybind11::python_headers)
+  set(pybind11_INCLUDE_DIRS
+      "${pybind11_INCLUDE_DIR}" "${${_Python}_INCLUDE_DIRS}"
+      CACHE INTERNAL "Directories where pybind11 and possibly Python headers are located")
+endif()
+
+# In CMake 3.18+, you can find these separately, so include an if
+if(TARGET ${_Python}::Python)
+  set_property(
+    TARGET pybind11::embed
+    APPEND
+    PROPERTY INTERFACE_LINK_LIBRARIES ${_Python}::Python)
+endif()
+
+# CMake 3.15+ has this
+if(TARGET ${_Python}::Module)
+  set_property(
+    TARGET pybind11::module
+    APPEND
+    PROPERTY INTERFACE_LINK_LIBRARIES ${_Python}::Module)
+else()
+  set_property(
+    TARGET pybind11::module
+    APPEND
+    PROPERTY INTERFACE_LINK_LIBRARIES pybind11::python_link_helper)
+endif()
+
+# WITHOUT_SOABI and WITH_SOABI will disable the custom extension handling used by pybind11.
+# WITH_SOABI is passed on to python_add_library.
 function(pybind11_add_module target_name)
-  set(options MODULE SHARED EXCLUDE_FROM_ALL NO_EXTRAS SYSTEM THIN_LTO)
-  cmake_parse_arguments(ARG "${options}" "" "" ${ARGN})
+  cmake_parse_arguments(PARSE_ARGV 1 ARG
+                        "STATIC;SHARED;MODULE;THIN_LTO;OPT_SIZE;NO_EXTRAS;WITHOUT_SOABI" "" "")
 
-  if(ARG_MODULE AND ARG_SHARED)
-    message(FATAL_ERROR "Can't be both MODULE and SHARED")
+  if(ARG_STATIC)
+    set(lib_type STATIC)
   elseif(ARG_SHARED)
     set(lib_type SHARED)
   else()
     set(lib_type MODULE)
   endif()
 
-  if(ARG_EXCLUDE_FROM_ALL)
-    set(exclude_from_all EXCLUDE_FROM_ALL)
+  if("${_Python}" STREQUAL "Python")
+    python_add_library(${target_name} ${lib_type} ${ARG_UNPARSED_ARGUMENTS})
+  elseif("${_Python}" STREQUAL "Python3")
+    python3_add_library(${target_name} ${lib_type} ${ARG_UNPARSED_ARGUMENTS})
+  else()
+    message(FATAL_ERROR "Cannot detect FindPython version: ${_Python}")
   endif()
 
-  add_library(${target_name} ${lib_type} ${exclude_from_all} ${ARG_UNPARSED_ARGUMENTS})
+  target_link_libraries(${target_name} PRIVATE pybind11::headers)
 
-  if(ARG_SYSTEM)
-    set(inc_isystem SYSTEM)
+  if(lib_type STREQUAL "MODULE")
+    target_link_libraries(${target_name} PRIVATE pybind11::module)
+  else()
+    target_link_libraries(${target_name} PRIVATE pybind11::embed)
   endif()
 
-  target_include_directories(${target_name} ${inc_isystem}
-    PRIVATE ${PYBIND11_INCLUDE_DIR}  # from project CMakeLists.txt
-    PRIVATE ${pybind11_INCLUDE_DIR}  # from pybind11Config
-    PRIVATE ${PYTHON_INCLUDE_DIRS})
-
-  # Python debug libraries expose slightly different objects
-  # https://docs.python.org/3.6/c-api/intro.html#debugging-builds
-  # https://stackoverflow.com/questions/39161202/how-to-work-around-missing-pymodule-create2-in-amd64-win-python35-d-lib
-  if(PYTHON_IS_DEBUG)
-    target_compile_definitions(${target_name} PRIVATE Py_DEBUG)
+  if(MSVC)
+    target_link_libraries(${target_name} PRIVATE pybind11::windows_extras)
   endif()
 
-  # The prefix and extension are provided by FindPythonLibsNew.cmake
-  set_target_properties(${target_name} PROPERTIES PREFIX "${PYTHON_MODULE_PREFIX}")
-  set_target_properties(${target_name} PROPERTIES SUFFIX "${PYTHON_MODULE_EXTENSION}")
-
   # -fvisibility=hidden is required to allow multiple modules compiled against
   # different pybind versions to work properly, and for some features (e.g.
   # py::module_local).  We force it on everything inside the `pybind11`
   # namespace; also turning it on for a pybind module compilation here avoids
   # potential warnings or issues from having mixed hidden/non-hidden types.
-  set_target_properties(${target_name} PROPERTIES CXX_VISIBILITY_PRESET "hidden")
-  set_target_properties(${target_name} PROPERTIES CUDA_VISIBILITY_PRESET "hidden")
+  if(NOT DEFINED CMAKE_CXX_VISIBILITY_PRESET)
+    set_target_properties(${target_name} PROPERTIES CXX_VISIBILITY_PRESET "hidden")
+  endif()
 
-  if(WIN32 OR CYGWIN)
-    # Link against the Python shared library on Windows
-    target_link_libraries(${target_name} PRIVATE ${PYTHON_LIBRARIES})
-  elseif(APPLE)
-    # It's quite common to have multiple copies of the same Python version
-    # installed on one's system. E.g.: one copy from the OS and another copy
-    # that's statically linked into an application like Blender or Maya.
-    # If we link our plugin library against the OS Python here and import it
-    # into Blender or Maya later on, this will cause segfaults when multiple
-    # conflicting Python instances are active at the same time (even when they
-    # are of the same version).
-
-    # Windows is not affected by this issue since it handles DLL imports
-    # differently. The solution for Linux and Mac OS is simple: we just don't
-    # link against the Python library. The resulting shared library will have
-    # missing symbols, but that's perfectly fine -- they will be resolved at
-    # import time.
-
-    target_link_libraries(${target_name} PRIVATE "-undefined dynamic_lookup")
-
-    if(ARG_SHARED)
-      # Suppress CMake >= 3.0 warning for shared libraries
-      set_target_properties(${target_name} PROPERTIES MACOSX_RPATH ON)
-    endif()
+  if(NOT DEFINED CMAKE_CUDA_VISIBILITY_PRESET)
+    set_target_properties(${target_name} PROPERTIES CUDA_VISIBILITY_PRESET "hidden")
   endif()
 
-  # Make sure C++11/14 are enabled
-  if(CMAKE_VERSION VERSION_LESS 3.3)
-    target_compile_options(${target_name} PUBLIC ${PYBIND11_CPP_STANDARD})
-  else()
-    target_compile_options(${target_name} PUBLIC $<$<COMPILE_LANGUAGE:CXX>:${PYBIND11_CPP_STANDARD}>)
+  # If we don't pass a WITH_SOABI or WITHOUT_SOABI, use our own default handling of extensions
+  if(NOT ARG_WITHOUT_SOABI AND NOT "WITH_SOABI" IN_LIST ARG_UNPARSED_ARGUMENTS)
+    pybind11_extension(${target_name})
   endif()
 
   if(ARG_NO_EXTRAS)
     return()
   endif()
 
-  _pybind11_add_lto_flags(${target_name} ${ARG_THIN_LTO})
-
-  if (NOT MSVC AND NOT ${CMAKE_BUILD_TYPE} MATCHES Debug|RelWithDebInfo)
-    # Strip unnecessary sections of the binary on Linux/Mac OS
-    if(CMAKE_STRIP)
-      if(APPLE)
-        add_custom_command(TARGET ${target_name} POST_BUILD
-                           COMMAND ${CMAKE_STRIP} -x $<TARGET_FILE:${target_name}>)
-      else()
-        add_custom_command(TARGET ${target_name} POST_BUILD
-                           COMMAND ${CMAKE_STRIP} $<TARGET_FILE:${target_name}>)
-      endif()
+  if(NOT DEFINED CMAKE_INTERPROCEDURAL_OPTIMIZATION)
+    if(ARG_THIN_LTO)
+      target_link_libraries(${target_name} PRIVATE pybind11::thin_lto)
+    else()
+      target_link_libraries(${target_name} PRIVATE pybind11::lto)
     endif()
   endif()
 
+  # Use case-insensitive comparison to match the result of $<CONFIG:cfgs>
+  string(TOUPPER "${CMAKE_BUILD_TYPE}" uppercase_CMAKE_BUILD_TYPE)
+  if(NOT MSVC AND NOT "${uppercase_CMAKE_BUILD_TYPE}" MATCHES DEBUG|RELWITHDEBINFO)
+    # Strip unnecessary sections of the binary on Linux/macOS
+    pybind11_strip(${target_name})
+  endif()
+
   if(MSVC)
-    # /MP enables multithreaded builds (relevant when there are many files), /bigobj is
-    # needed for bigger binding projects due to the limit to 64k addressable sections
-    target_compile_options(${target_name} PRIVATE /bigobj)
-    if(CMAKE_VERSION VERSION_LESS 3.11)
-      target_compile_options(${target_name} PRIVATE $<$<NOT:$<CONFIG:Debug>>:/MP>)
-    else()
-      # Only set these options for C++ files.  This is important so that, for
-      # instance, projects that include other types of source files like CUDA
-      # .cu files don't get these options propagated to nvcc since that would
-      # cause the build to fail.
-      target_compile_options(${target_name} PRIVATE $<$<NOT:$<CONFIG:Debug>>:$<$<COMPILE_LANGUAGE:CXX>:/MP>>)
-    endif()
+    target_link_libraries(${target_name} PRIVATE pybind11::windows_extras)
+  endif()
+
+  if(ARG_OPT_SIZE)
+    target_link_libraries(${target_name} PRIVATE pybind11::opt_size)
   endif()
 endfunction()
+
+function(pybind11_extension name)
+  # The extension is precomputed
+  set_target_properties(${name} PROPERTIES PREFIX "" SUFFIX "${PYTHON_MODULE_EXTENSION}")
+
+endfunction()
```

### Comparing `stopeight-0.3.14/setup.cfg` & `stopeight-0.3.22/setup.cfg`

 * *Files 17% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 [metadata]
-metadata-version = 2.1
+metadata_version = 2.1
 name = stopeight
 description = stopeight: Comparing sequences of points in 2 dimensions
 long_description = stopeight: Comparing sequences of points in 2 dimensions by visually overlapping them using matrix transformations (translation, scaling and rotation) and getting a boolean result.
 keywords = signal-analysis time-series pen-stroke
 author = Fassio Blatter
 author_email = fassio@specpose.com
 license = GNU General Public License, version 2
@@ -17,17 +17,25 @@
 	Topic :: Scientific/Engineering
 	Topic :: Scientific/Engineering :: Visualization
 	Topic :: Scientific/Engineering :: Information Analysis
 	License :: OSI Approved :: GNU General Public License v2 (GPLv2)
 	Operating System :: OS Independent
 	Programming Language :: Python :: 3
 	Programming Language :: Python :: 3 :: Only
-	Programming Language :: Python :: 3.8
+	Programming Language :: Python :: 3.10
 
 [options]
 zip_safe = False
-python_requires = >=3.5
+python_requires = >=3.7
+install_requires = 
+	PySide2
+	numpy
+	matplotlib
+
+[options.entry_points]
+gui_scripts = 
+	stopeight-editor = stopeight.util.editor.dispatch:main
 
 [egg_info]
 tag_build = 
 tag_date = 0
```

### Comparing `stopeight-0.3.14/stopeight/comparator/lineMatch.py` & `stopeight-0.3.22/stopeight/comparator/lineMatch.py`

 * *Files 1% similar despite different names*

```diff
@@ -154,15 +154,14 @@
             log.info('We have a match!')
             return True
         else:
             log.info('No match.')
             return False
 
 if __name__ == "__main__":
-    from stopeight.util import runnable
     log = logSwitch.logPrint()
     log.info('Starting lineMatch...')
     input = array([[20,20],[55,130],[80,60],[120,85],[200,10]]).view(vectorTools.NumpyLine)
     log.info('rendering input.svg')
     #input.printVectors('input')
     dbrecord = array([[13,40],[50,125],[80,61],[123,79],[191,11]]).view(vectorTools.NumpyLine)
     log.info('rendering dbrecord.svg')
```

### Comparing `stopeight-0.3.14/stopeight/comparator/matrix.py` & `stopeight-0.3.22/stopeight/comparator/matrix.py`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight/comparator/matrixTools.py` & `stopeight-0.3.22/stopeight/comparator/matrixTools.py`

 * *Files 4% similar despite different names*

```diff
@@ -35,15 +35,14 @@
     b[1]= a[0] * m[0][1] + a[1]* m[1][1] + m[2][1]
     return b
 
 def center(a):
     return transform(a,translate(array([0,0])))
 
 if __name__ == '__main__':
-    from stopeight.util import runnable
     a = array([30,30])
     m = idmatrix()
     print ('rotate vector with matrix:')
     m = dot(translate(array([10,15])),m)
     #m = dot(scale(array([0.5,0.5])),m)
     m = dot(rotate(-90),m)
     result = transform(a,m)
```

### Comparing `stopeight-0.3.14/stopeight/comparator/matrixTools_new.py` & `stopeight-0.3.22/stopeight/comparator/matrixTools_new.py`

 * *Files 3% similar despite different names*

```diff
@@ -30,15 +30,14 @@
     b[1] = sin(m.rot) * a[0] + cos(m.rot) * a[1] + m.y
     return b
 
 #def center(a):
 #    return transform(a,translate(array([0,0])))
 
 if __name__ == '__main__':
-    from stopeight.util import runnable
     a = array([30,30])
     #m = idmatrix()
     print ('rotate vector with matrix:')
     #m = dot(translate(array([10,15])),m)
     #m = dot(scale(array([0.5,0.5])),m)
     #m = dot(rotate(-90),m)
     m = Matrix([10,15],-90)
```

### Comparing `stopeight-0.3.14/stopeight/comparator/shapeMatch.py` & `stopeight-0.3.22/stopeight/comparator/shapeMatch.py`

 * *Files 2% similar despite different names*

```diff
@@ -52,15 +52,14 @@
             log.info('We have a match!')
             return True
         else:
             log.info('No match.')
             return False
 
 if __name__ == "__main__":
-    from stopeight.util import runnable
     from stopeight.comparator import vectorTools
     from numpy import array
     log.disable(log.NOTSET)
     log.info('Starting shapeMatch...')
     input = array([[20,20],[55,130],[80,60],[120,85],[200,10]]).view(vectorTools.NumpyLine)
     log.info('rendering input.svg')
     input.printVectors('input')
```

### Comparing `stopeight-0.3.14/stopeight/comparator/shapeMatchSubSection.py` & `stopeight-0.3.22/stopeight/comparator/shapeMatchSubSection.py`

 * *Files 4% similar despite different names*

```diff
@@ -34,15 +34,14 @@
             reordered = long.reorderToNStart(count)
             reordered = reordered[0:len(short)]
             unweightedReverse = ShapeMatchClass(short,self.toleranceDivider)
             if unweightedReverse.match(reordered):
                 return True
 
 if __name__ == "__main__":
-    from stopeight.util import runnable
     from stopeight.comparator import vectorTools
     log.info('Starting shapeMatch...')
     input = array([[20,20],[55,130],[80,60],[120,85],[200,10]]).view(vectorTools.NumpyLine)
     log.info('rendering input.svg')
     input.printVectors('input')
     dbrecord = array([[5,5],[13,40],[50,125],[80,61],[123,79],[191,11],[10,10]]).view(vectorTools.NumpyLine)
     log.info('rendering dbrecord.svg')
```

### Comparing `stopeight-0.3.14/stopeight/comparator/vectorTools.py` & `stopeight-0.3.22/stopeight/comparator/vectorTools.py`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight/logging/__init__.py` & `stopeight-0.3.22/stopeight/logging/__init__.py`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight/multiprocessing/pooling.py` & `stopeight-0.3.22/stopeight/multiprocessing/pooling.py`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight/test/test_comparator.py` & `stopeight-0.3.22/stopeight/test/test_comparator.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 def test_comparator():
     from stopeight.util.parser import process_directory
     from stopeight import legacy
     from stopeight.multiprocessing import pooling
     from numpy import array
-    listoflines = process_directory('stopeight-clibs/legacy/tests/','.sp',legacy.parse_file,legacy.stroke_sequential)
+    import os
+    listoflines = process_directory(os.path.join('stopeight-clibs','legacy','test-data'),'.sp',legacy.parse_file,legacy.stroke_sequential)
     listofarrays = []
     for line in listoflines:
         listofarrays.append(array(line))
     comparator = pooling.MPLine(listofarrays)
     for i,line in enumerate(listofarrays):
         matches = comparator.matchLine(line)
         print('Line ' + str(i) + ' matched ' + str(len(matches)) + ' occurences ' + str(matches))
```

### Comparing `stopeight-0.3.14/stopeight/test/test_grapher.py` & `stopeight-0.3.22/stopeight/test/test_grapher.py`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight/util/SVG.py` & `stopeight-0.3.22/stopeight/util/SVG.py`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight/util/TCT_printer.py` & `stopeight-0.3.22/stopeight/util/TCT_printer.py`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight/util/editor/callwindow.py` & `stopeight-0.3.22/stopeight/util/editor/callwindow.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
-from PyQt5.QtWidgets import QDockWidget,QTextEdit,QVBoxLayout,QGroupBox
-from PyQt5.QtCore import Qt, QSize
-from stopeight.util.runnable import EditorApp
+from PySide2.QtWidgets import QDockWidget,QTextEdit,QVBoxLayout,QGroupBox
+from PySide2.QtCore import Qt, QSize
+from stopeight.util.editor.runnable import EditorApp
 
 import sys
 import os
 import io
 
 class outwindow(QDockWidget):
     def __init__(self,parent=EditorApp().window):
```

### Comparing `stopeight-0.3.14/stopeight/util/editor/command.py` & `stopeight-0.3.22/stopeight/util/editor/command.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 # Copyright (C) 2018 Fassio Blatter
 
-from stopeight.util import runnable
+from stopeight.util.editor import runnable
 from sys import modules as loader
 
-from PyQt5.QtWidgets import QComboBox,QPushButton
+from PySide2.QtWidgets import QComboBox,QPushButton
 
 import stopeight.logging as log
 _LOGDIR = '.stopeight' # this is not for logging messages; it is for data files
 
 from inspect import signature
 class Algorithm_Select(dict):
     def __init__(self, module, **kwargs):
@@ -98,15 +98,15 @@
                     del outputdata[:]
                     if (len(outputdata)>0):
                         raise Exception("outputdata clear failed!")
                 except TypeError:
                     pass
         return outputdata
     
-from PyQt5.QtCore import Qt
+from PySide2.QtCore import Qt
 from contextlib import redirect_stdout,redirect_stderr
 #def zoo(a: str)->int:
     #if (signature(zoo).return_annotation!=Signature.empty):
 class Connector:
     def __init__(self,command,outputObjects,logwindow):
         self.logwindow = logwindow
         self._outputs = outputObjects
```

### Comparing `stopeight-0.3.14/stopeight/util/editor/data.py` & `stopeight-0.3.22/stopeight/util/editor/data.py`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight/util/editor/dispatch.py` & `stopeight-0.3.22/stopeight/util/editor/dispatch.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,26 +1,17 @@
 #!/usr/bin/env python
 
 # Copyright (C) 2017 Fassio Blatter
 import stopeight.logging as log
 log.basicConfig(level=log.DEBUG)
 
-try:
-    # new location for sip
-    # https://www.riverbankcomputing.com/static/Docs/PyQt5/incompatibilities.html#pyqt-v5-11
-   from PyQt5 import sip
-except ImportError:
-    from PyQt5 import QtCore
-    import sip
-from PyQt5.QtWidgets import QApplication,QMainWindow
+from stopeight.util.editor.runnable import EditorApp
 
-from stopeight.util.runnable import EditorApp
-
-from PyQt5 import QtWidgets
-from PyQt5.QtWidgets import QToolBar,QGroupBox,QHBoxLayout
+from PySide2 import QtWidgets
+from PySide2.QtWidgets import QToolBar,QGroupBox,QHBoxLayout
 
 # False: Is part of a compiled library
 _DATA = {'Modules': [
 #                            ('stopeight.util.editor.modules.legacy', False),
                             ('stopeight.util.editor.modules.file', True),
                             ('stopeight.util.editor.modules.file_wave',True),
                             ('stopeight.util.editor.modules.grapher', False),
@@ -74,15 +65,15 @@
     EditorApp().window.setCentralWidget(wave.canvas)
     #EditorApp().window.addDockWidget(Qt.TopDockWidgetArea,wave)    
 
     # Create results area
     from stopeight.util.editor.scribble import ScribbleArea
     scribble = ScribbleArea()
     outputs.append(scribble)
-    from PyQt5.QtCore import Qt
+    from PySide2.QtCore import Qt
     scribble.setAllowedAreas(Qt.AllDockWidgetAreas)
     EditorApp().window.addDockWidget(Qt.RightDockWidgetArea,scribble)
 
     # Find modules
     callables = []
     for module in _DATA['Modules']:
         callables.append(module)
@@ -108,8 +99,8 @@
     EditorApp().window.addToolBar(Qt.BottomToolBarArea,toolbox)
     #EditorApp().window.addDockWidget(Qt.BottomDockWidgetArea,toolbox)
     
     EditorApp().window.show()
     sys.exit(EditorApp().exec_())
 
 if __name__ == '__main__':
-    main()
+    main()
```

### Comparing `stopeight-0.3.14/stopeight/util/editor/modules/file.py` & `stopeight-0.3.22/stopeight/util/editor/modules/file.py`

 * *Files 6% similar despite different names*

```diff
@@ -12,27 +12,27 @@
     # this is not a real error but saves us from writing more code
     data=data.data
     log.error("DISREGARD THIS ERROR, IT HAS BEEN TRIGGERED TO SAVE THE FILE")
     raise ValueError
 save_NPY.__annotations__ = {'data': ScribbleArea, 'return': type(None)}
 
 def save_as_NPY(data):
-    from stopeight.util.runnable import EditorApp
-    from PyQt5.QtWidgets import QFileDialog
+    from stopeight.util.editor.runnable import EditorApp
+    from PySide2.QtWidgets import QFileDialog
     filename = QFileDialog.getSaveFileName(EditorApp().window,"QFileDialog.getSaveFileName()","","NumPy Files (*.npy)")
     assert type(filename[0]) == str
     assert len(filename[0]) != 0
     _to_file(filename[0],data.data)
     log.info("Saved to File "+str(filename[0]))
     return filename
 save_as_NPY.__annotations__ = {'data': ScribbleArea, 'return': type(None)}
 
 def open_NPY():
-    from stopeight.util.runnable import EditorApp
-    from PyQt5.QtWidgets import QFileDialog
+    from stopeight.util.editor.runnable import EditorApp
+    from PySide2.QtWidgets import QFileDialog
     filename = QFileDialog.getOpenFileName(EditorApp().window)
     assert type(filename[0]) == str
     assert len(filename[0]) != 0, "No filename"
     log.debug("Reading from File "+str(filename[0]))
     return _read(filename[0])
 open_NPY.__annotations__ = {'return': ScribbleData}
```

### Comparing `stopeight-0.3.14/stopeight/util/editor/modules/file_wave.py` & `stopeight-0.3.22/stopeight/util/editor/modules/file_wave.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,13 +1,12 @@
 # Copyright (C) 2017 Fassio Blatter
 
-from PyQt5.QtWidgets import QFileDialog,QInputDialog
+from PySide2.QtWidgets import QFileDialog,QInputDialog
 from stopeight.util.editor.data import WaveData
 
-import wave
 import numpy as np
 import sys
 
 import stopeight.logging as log
 
 def _getChannel(spf,channel_num=0,total_channels=1):
     #Extract Raw Audio from Wav File
@@ -25,38 +24,40 @@
     assert type(channel_num) is int
     assert type(total_channels) is int
     #left samples[0::2]
     #right samples[1::2]
     return fconverter(np.asarray(np.fromstring(signal, datatype)[channel_num::total_channels], dtype=np.float64)).view(WaveData)
 
 def _selectChannel(spf):
-    from stopeight.util.runnable import EditorApp
+    from stopeight.util.editor.runnable import EditorApp
     n = spf.getnchannels()
     channels = ['{}'.format(i) for i in range(n)]
     channel_num, ok = QInputDialog().getItem(EditorApp().window,"Select Channel","Channel:",channels,0,False)
     if ok:
         return int(channel_num),int(n)
     else:
         return 0,int(n)
 
 def _open(filename):
+    import wave
+    from wave import open
     log.setLevel(log.INFO)
     spf = wave.open(filename,'r')
     if spf.getcomptype()!='NONE':
         raise Exception("Compressed WAV files are not supported.")
     channels = _selectChannel(spf)
     samples = _getChannel(spf,*channels)
     spf.close()
     log.debug("wave ndarray is "+str(type(samples)))
     log.info("Length of samples in track "+str(len(samples)))
     return samples
 
 def open_WAV():
     log.setLevel(log.INFO)
-    from stopeight.util.runnable import EditorApp
+    from stopeight.util.editor.runnable import EditorApp
     filename = QFileDialog.getOpenFileName(EditorApp().window)
     assert type(filename[0]) == str
     assert len(filename[0]) != 0
     log.info("Opening "+str(filename[0]))
     samples = _open(filename[0])
     return samples
-open_WAV.__annotations__ = {'return': WaveData}
+open_WAV.__annotations__ = {'return': WaveData}
```

### Comparing `stopeight-0.3.14/stopeight/util/editor/modules/grapher.py` & `stopeight-0.3.22/stopeight/util/editor/modules/grapher.py`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight/util/editor/modules/legacy.py` & `stopeight-0.3.22/stopeight/util/editor/modules/legacy.py`

 * *Files 22% similar despite different names*

```diff
@@ -19,65 +19,67 @@
 def _convert(legacy_data):
     scribbledata = ScribbleData(size=len(legacy_data))
     for i,v in enumerate(legacy_data):
         scribbledata[i]['coords'] = [v[0],v[1]]
     return scribbledata
 
 def open_SP()->ScribbleData:
-    from stopeight.util.runnable import EditorApp
-    from PyQt5.QtWidgets import QFileDialog
+    from stopeight.util.editor.runnable import EditorApp
+    from PySide2.QtWidgets import QFileDialog
     filename = QFileDialog.getOpenFileName(EditorApp().window)
     assert type(filename[0]) == str
     assert len(filename[0]) != 0
     data = _parse_file(filename[0])
     return data
 
 def TCT_to_bezier(data:ScribbleData)->ScribbleData:
     return stopeight.legacy.TCT_to_bezier(data)
 
-##import stopeight.finders
-##from stopeight.grapher import *
-##
-##def findTurns(data):
-##    log.info("Invoking findTurns...")
-##    ql = stopeight.getters.QListDpoint(data)
-##    turns = stopeight.finders.Turns(ql)
-##    print(turns)
-##    assert type(turns) == list
-##    return turns
-##findTurns.__annotations__ = {'data': ScribbleData, 'return': list}
-##
-##def sequencial(data):
-##    log.info("Invoking findCliffs...")
-##    ql = stopeight.getters.QListDpoint(data)
-##    turns = stopeight.finders.Cliffs(ql)
-##    print(turns)
-##    assert type(turns) == list
-##    return turns
-##sequencial.__annotations__ = {'data': ScribbleData, 'return': list}
-##
-##def parallel(data):
-##    log.info("Invoking findSpiralCliffs...")
-##    ql = stopeight.getters.QListDpoint(data)
-##    turns = stopeight.finders.Spirals(ql)
-##    print(turns)
-##    assert type(turns) == list
-##    return turns
-##parallel.__annotations__ = {'data': ScribbleData, 'return': list}
-##
-##
+import stopeight.finders
+from stopeight.getters import ListSwitchable
+
+def _intList_to_ScribbleData(original: ScribbleData, mylist: list)->ScribbleData:
+    assert len(original)>1
+    newsize=len(mylist)+2
+    data = ScribbleData(size=newsize)
+    data[0]['coords']=[original[0]['coords'][0],original[0]['coords'][1]]
+    data[newsize-1]['coords']=[original[-1]['coords'][0],original[-1]['coords'][1]]
+    for i,index in enumerate(mylist):
+        data[i+1]['coords'] = [original[index]['coords'][0],original[index]['coords'][1]]
+    return data
+
+def sequential(data:ScribbleData)->ScribbleData:
+    log.info("Invoking findCliffs...")
+    ql = stopeight.getters.ListSwitchable(data)
+    turns = stopeight.finders.findCliffs(ql)
+    print(turns)
+    assert type(turns) == list
+    return _intList_to_ScribbleData(data,turns)
+
+def parallel(data:ScribbleData)->ScribbleData:
+    log.info("Invoking findSpiralCliffs...")
+    ql = stopeight.getters.ListSwitchable(data)
+    turns = stopeight.finders.findSpiralCliffs(ql)
+    print(turns)
+    assert type(turns) == list
+    return _intList_to_ScribbleData(data,turns)
+
 import stopeight.getters
 import numpy as np
 
 def getFirstTurnByTriplets(data:ScribbleData)->ScribbleData:
     log.setLevel(log.DEBUG)
     log.info("Invoking getFirstTurnByTriplets with "+str(len(data))+" data points...")
-    #from stopeight.matrix import Vectors
-    #invec = Vectors(data)
-    #log.debug("Creating a legacy QListDpoint from a matrix Vectors length "+str(len(invec)))
-    ql = stopeight.getters.QListDpoint(data)
-    log.debug("Initializing turn chopping algorithm length "+str(len(ql)))
-    ta = stopeight.getters.Turn(ql)
+    ta = stopeight.getters.TurnAnalyzer(data)
     log.debug("Invoking turn chopping algorithm length "+str(len(ta)))
-    out = ta.next()#.__array__()
+    out = ta.getFirstTurnByTriplets(ta)
+    log.debug("Read length of a object of type "+str(type(out))+" and length "+str(len(out)))
+    return out.view(ScribbleData)
+
+def getFirstCorner(data:ScribbleData)->ScribbleData:
+    log.setLevel(log.DEBUG)
+    log.info("Invoking getFirstCorner with "+str(len(data))+" data points...")
+    ql = stopeight.getters.ListSwitchable(data)
+    log.debug("Invoking corner chopping algorithm length "+str(len(ql)))
+    out = stopeight.getters.getFirstCorner(ql)
     log.debug("Read length of a object of type "+str(type(out))+" and length "+str(len(out)))
     return out.view(ScribbleData)
```

### Comparing `stopeight-0.3.14/stopeight/util/editor/scribble.py` & `stopeight-0.3.22/stopeight/util/editor/scribble.py`

 * *Files 8% similar despite different names*

```diff
@@ -39,25 +39,24 @@
 ## (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 ## OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
 ## $QT_END_LICENSE$
 ##
 #############################################################################
 
 
-from PyQt5.QtCore import QDir, QPoint, QRect, QSize, Qt
-from PyQt5.QtGui import QImage, QImageWriter, QPainter, QPen, qRgb
-from PyQt5 import QtWidgets
-from PyQt5.QtWidgets import (QAction, QApplication, QColorDialog, QFileDialog,
-        QInputDialog, QMainWindow, QMenu, QMessageBox, QWidget)
-from PyQt5.QtPrintSupport import QPrintDialog, QPrinter
+from PySide2.QtCore import QPoint, QRect, QSize, Qt
+from PySide2.QtGui import QImage, QPainter, QPen, qRgb
+from PySide2 import QtWidgets
+from PySide2.QtWidgets import (QColorDialog,
+        QInputDialog)
+from PySide2.QtPrintSupport import QPrintDialog, QPrinter
 
-from PyQt5.QtGui import QTabletEvent
-from PyQt5.QtCore import QEvent
+from PySide2.QtCore import QEvent
 
-from stopeight.util.runnable import EditorApp
+from stopeight.util.editor.runnable import EditorApp
 from stopeight.util.editor.data import ScribbleData
 
 import stopeight.logging as log
 
 class ScribbleArea(QtWidgets.QDockWidget):
     def __init__(self, parent=EditorApp().window):
         super(ScribbleArea, self).__init__("ScribbleArea",parent)
```

### Comparing `stopeight-0.3.14/stopeight/util/editor/wave.py` & `stopeight-0.3.22/stopeight/util/editor/wave.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 # https://stackoverflow.com/questions/12459811/how-to-embed-matplotlib-in-pyqt-for-dummies
 # https://stackoverflow.com/questions/18625085/how-to-plot-a-wav-file
 
 import sys
 import numpy
 
-from PyQt5 import QtGui,QtWidgets
-from PyQt5.QtWidgets import QGroupBox
+from PySide2 import QtGui,QtWidgets
+from PySide2.QtWidgets import QGroupBox
 from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
 from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
 from matplotlib.figure import Figure
 
-from stopeight.util.runnable import EditorApp
+from stopeight.util.editor.runnable import EditorApp
 
 from stopeight.util.editor.data import WaveData
-from stopeight.util import runnable
+from stopeight.util.editor import runnable
 
 class WaveArea(QtWidgets.QDockWidget):
     def __init__(self, parent=EditorApp().window):
         super(WaveArea, self).__init__(parent)
 
         # a figure instance to plot on
         self.figure = Figure()
```

### Comparing `stopeight-0.3.14/stopeight/util/parser.py` & `stopeight-0.3.22/stopeight/util/parser.py`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight/util/tableau_printer.py` & `stopeight-0.3.22/stopeight/util/tableau_printer.py`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight/util/test/test_util.py` & `stopeight-0.3.22/stopeight/util/test/test_util.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 def test_linePrinter():
     from stopeight.util.TCT_printer import TCTPrinter
     from stopeight import legacy
+    import os
     myprinter = TCTPrinter('linePrinter.out')
-    fileline = legacy.parse_file('stopeight-clibs/legacy/tests/stage3-build04-authWorking/almostStraightLeg.sp')
+    fileline = legacy.parse_file(os.path.join('stopeight-clibs','legacy','test-data','v0-1-0','stage3-build04-authWorking','almostStraightLeg.sp'))
     myprinter.lines(fileline)
     fileline = legacy.stroke_sequential(fileline)
     fileline = legacy.TCT_to_bezier(fileline)
     myprinter.TCTs(fileline)
     myprinter.write()
 
 def test_tableauPrinter():
@@ -30,8 +31,8 @@
     import numpy
     printer = TCTPrinter('TCTPrinter.out')
     nline = numpy.array(((200,200),(200,300)))
     printer.lines(nline)
     printer.lines(nline)
     printer.lines(nline)
     #printer.scene.add(SVG.Line((200,200),(200,300)))
-    printer.write()
+    printer.write()
```

### Comparing `stopeight-0.3.14/stopeight-clibs/Versioning.cmake` & `stopeight-0.3.22/stopeight-clibs/Versioning.cmake`

 * *Files 22% similar despite different names*

```diff
@@ -2,8 +2,13 @@
 # Variables needed in modules, auto-generated git.h file needed in wrappers
 #############
 set(PRE_CONFIGURE_FILE "${PROJECT_SOURCE_DIR}/cmake-git-version-tracking/better-example/git.cc.in")
 set(POST_CONFIGURE_FILE "${CMAKE_CURRENT_BINARY_DIR}/git.cpp")
 file(APPEND "${CMAKE_CURRENT_BINARY_DIR}/git.cpp" "")
 include(${PROJECT_SOURCE_DIR}/cmake-git-version-tracking/git_watcher.cmake)
 # Danger injection from submodule?
-set(GIT_HEADER_DIR "${PROJECT_SOURCE_DIR}/cmake-git-version-tracking/better-example/")
+set(GIT_HEADER_DIR "${PROJECT_SOURCE_DIR}/cmake-git-version-tracking/better-example/")
+
+# Create a library out of the compiled post-configure file.
+add_library(git STATIC ${POST_CONFIGURE_FILE})
+target_include_directories(git PUBLIC ${GIT_HEADER_DIR})
+add_dependencies(git check_git)
```

### Comparing `stopeight-0.3.14/stopeight-clibs/analyzer/turns.h` & `stopeight-0.3.22/stopeight-clibs/analyzer/turns.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/analyzer-wrappers/IFPyAnalyzer.cpp` & `stopeight-0.3.22/stopeight-clibs/analyzer/python/IFPyAnalyzer.cpp`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/better-example/CMakeLists.txt` & `stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/better-example/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/better-example/git.cc.in` & `stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/better-example/git.cc.in`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/better-example/git.h` & `stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/better-example/git.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/better-example/git_watcher.cmake` & `stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/better-example/git_watcher.cmake`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/git_watcher.cmake` & `stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/git_watcher.cmake`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/hello-world/CMakeLists.txt` & `stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/hello-world/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/cmake-git-version-tracking/hello-world/git_watcher.cmake` & `stopeight-0.3.22/stopeight-clibs/cmake-git-version-tracking/hello-world/git_watcher.cmake`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/grapher/CMakeLists.txt` & `stopeight-0.3.22/stopeight-clibs/analyzer/CMakeLists.txt`

 * *Files 24% similar despite different names*

```diff
@@ -1,27 +1,31 @@
-cmake_minimum_required (VERSION 3.4.3)
-
-project(stopeight-clibs-grapher)
+cmake_minimum_required (VERSION 3.12)
 
+project(stopeight-clibs-analyzer)
 aux_source_directory(. SRC_LIST)
-#file(GLOB SOURCES "*.cpp")
 set(${PROJECT_NAME}_sources
-    containers.cpp
-    algo.cpp
-    grapher.cpp
-    mean.cpp
-    main.cpp
+    turns.cpp
     ${POST_CONFIGURE_FILE}
 )
-
-#add_executable(${PROJECT_NAME} ${${PROJECT_NAME}_sources})
 set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS TRUE)
 add_library(${PROJECT_NAME} SHARED ${${PROJECT_NAME}_sources})
 
-#include_directories(${stopeight-clibs_INCLUDE_DIRS})
+target_link_libraries(${PROJECT_NAME}
+    PRIVATE
+    stopeight-clibs-matrix
+    git
+)
+
 target_include_directories(${PROJECT_NAME}
     PRIVATE
     ${stopeight-clibs_INCLUDE_DIRS}
     ${GIT_HEADER_DIR}
 )
-add_dependencies(${PROJECT_NAME} check_git)
 install(TARGETS ${PROJECT_NAME} DESTINATION lib)
+
+find_package(Python COMPONENTS Development)
+if (Python_Development_FOUND)
+#find_package(pybind11 CONFIG)
+#if (pybind11_FOUND)
+add_subdirectory(python)
+#endif (pybind11_FOUND)
+endif (Python_Development_FOUND)
```

### Comparing `stopeight-0.3.14/stopeight-clibs/grapher/algo.cpp` & `stopeight-0.3.22/stopeight-clibs/grapher/algo.cpp`

 * *Files 22% similar despite different names*

```diff
@@ -8,63 +8,22 @@
 #include "containers.h"
 //#include "iterators.h"
 
 //double define
 //#include <experimental/execution_policy>
 
 #include <algorithm>
+#include <iterator>
 
 #include <vector>
 #include <math.h>
 
 namespace grapher {
-    template<class InputIterator,
-		class OutputIterator,
-		typename>
-		void __differences(InputIterator begin, InputIterator end, OutputIterator begin2)
-    {
-        std::adjacent_difference(begin, end, begin2);
-        //*std::begin(differences) = 0;
-    }
-    template void __differences(std::vector<double>::iterator, std::vector<double>::iterator, std::vector<double>::iterator) ;
-    template void __differences(std::vector<float>::iterator, std::vector<float>::iterator, std::vector<float>::iterator);
-	template void __differences(std::vector<int16_t>::iterator, std::vector<int16_t>::iterator, std::vector<int16_t>::iterator);
-	
-	template<class InputIterator,
-		class OutputIterator,
-		typename
-	>
-		void __calculate_rotations(InputIterator begin, InputIterator end, OutputIterator begin2, sp::sharing_functor<double,double>& angleFunction)
-    {
-		using T = typename std::iterator_traits<InputIterator>::value_type;//todo remove back_inserter -> std::iterator_traits<OutputIterator>::value_type;
-        std::transform(begin, end, begin2, [&angleFunction](T diff) {
-            return angleFunction(diff);
-        });
-    }
-	template void __calculate_rotations(std::vector<double>::iterator, std::vector<double>::iterator, std::vector<double>::iterator, sp::sharing_functor<double,double>&);
-	template void __calculate_rotations(std::vector<float>::iterator, std::vector<float>::iterator, std::vector<float>::iterator, sp::sharing_functor<double,double>&);
-	template void __calculate_rotations(std::vector<int16_t>::iterator, std::vector<int16_t>::iterator, std::vector<int16_t>::iterator, sp::sharing_functor<double,double>&);
-    
-	//todo make par_unseq
-	template<class InputIterator,
-		class OutputIterator,
-		typename
-	>
-		void __calculate_rotations(InputIterator begin, InputIterator end, OutputIterator begin2, sp::readonly_functor<double,double>& angleFunction)
-	{
-		using T = typename std::iterator_traits<InputIterator>::value_type;//todo remove back_inserter -> std::iterator_traits<OutputIterator>::value_type;
-		std::transform(begin, end, begin2, [&angleFunction](T diff) {
-			return angleFunction(diff);
-		});
-	}
-	template void __calculate_rotations(std::vector<double>::iterator, std::vector<double>::iterator, std::vector<double>::iterator, sp::readonly_functor<double,double>&);
-	template void __calculate_rotations(std::vector<float>::iterator, std::vector<float>::iterator, std::vector<float>::iterator, sp::readonly_functor<double,double>&);
-	template void __calculate_rotations(std::vector<int16_t>::iterator, std::vector<int16_t>::iterator, std::vector<int16_t>::iterator, sp::readonly_functor<double,double>&);
-
 
+    //InputIterator = decltype(OutputIterator)<OutputElement::value_type>
     template<class InputIterator
 		, class OutputIterator,
 		typename> void __apply_rotation_matrix(InputIterator begin, InputIterator end, OutputIterator begin2)
     {
 		using OutputElement = typename std::iterator_traits<OutputIterator>::value_type;
 		using T = typename OutputElement::value_type;
 
@@ -129,44 +88,14 @@
             e.first = (begin + p.first);
             e.second = (begin + p.second);
             return e;
         });
     }
     template void _fixpoints::operator()(std::vector<sp::timecode<double>>::iterator begin, std::vector<sp::timecode<double>>::iterator end, std::vector<it_pair<double>>::iterator begin2);
 	template void _fixpoints::operator()(std::vector<sp::timecode<float>>::iterator begin, std::vector<sp::timecode<float>>::iterator end, std::vector<it_pair<float>>::iterator begin2);
-
-    _blocks::_blocks(size_t samplesPerVector) : _samplesPerVector(samplesPerVector) {
-        
-    }
-    _blocks::~_blocks() {
-        
-    }
-    template <class InputIterator, class OutputIterator> void _blocks::operator()(InputIterator begin, InputIterator end, OutputIterator begin2)
-    {
-		using my_pair = typename std::iterator_traits<InputIterator>::value_type;//todo from OutputIterator; remove backinserter
-		auto spV = _samplesPerVector;
-        std::for_each(begin, end, [&begin2, spV](my_pair slice) {
-            auto size = std::distance(slice.first, slice.second);
-            if (size > 0) {
-                auto sectionend = (spV > size) ? size : spV;
-                for (int i = 0; i < (size / sectionend); i++) {
-                    *begin2++ = (my_pair{ (slice.first + (i*sectionend)),(slice.first + (i*sectionend) + sectionend) });
-                }
-                auto remainder = size%sectionend;
-                if (remainder != 0)
-                    *begin2++ = (my_pair{ (slice.second - remainder),slice.second });
-            }
-            else {
-                *begin2++ = (my_pair{ slice.first, slice.first });
-            }
-        });
-    }
-    template void _blocks::operator()(std::vector<it_pair<double>>::iterator begin, std::vector<it_pair<double>>::iterator end, std::vector<it_pair<double>>::iterator begin2);
-	template void _blocks::operator()(std::vector<it_pair<float>>::iterator begin, std::vector<it_pair<float>>::iterator end, std::vector<it_pair<float>>::iterator begin2);
-
     
     template <class InputIterator, class OutputIterator> void _sum_blocks(InputIterator begin, InputIterator end, OutputIterator begin2)
     {
 		using it_pair = typename std::iterator_traits<InputIterator>::value_type;//vector of pairs -> pair//it_pair not available from OutputIterator
 		using tc = typename it_pair::first_type::value_type;//pair -> tc -> T
 		//transforming intput it_pair to sp:element
         std::transform(begin, end, begin2, [](it_pair block) {
@@ -229,44 +158,34 @@
 	template __differences_To_VG<int16_t>::~__differences_To_VG();
 
 	template <class T> template <
 		class UnaryFunction,
 		typename
 	> std::vector<sp::timecode<T>> __differences_To_VG<T>::operator()(std::vector<T>& differences, UnaryFunction& angleFunction)
     {
-        std::vector<T> rotations;
+        auto rotations = std::vector<T>(differences.size()-1);
         //first one is invalid
-        __calculate_rotations(std::begin(differences) + 1, std::end(differences), std::back_inserter(rotations), angleFunction);
-        
+        std::transform(std::begin(differences) + 1, std::end(differences), std::begin(rotations), [&angleFunction](T diff) {
+			return angleFunction(diff);
+		});
+
+
 		auto tc = sp::timecode<T>{};
 		tc.__init({T(_vectorLength),T(0)});
-        const auto vectors_size = std::distance(std::begin(rotations), std::end(rotations));
-        auto vectors = std::vector<sp::timecode<T>>(vectors_size);
-		std::fill_n(std::begin(vectors), vectors_size, tc);//sp::make_timecode<T>(T(_vectorLength), 0));//sp::timecode<T>{T(_vectorLength), 0});
+        auto vectors = std::vector<sp::timecode<T>>(rotations.size());
+		std::fill(std::begin(vectors), std::end(vectors), tc);//sp::make_timecode<T>(T(_vectorLength), 0));//sp::timecode<T>{T(_vectorLength), 0});
         __apply_rotation_matrix(std::begin(rotations), std::end(rotations), std::begin(vectors));
         
+        //BUG No default constructor: iterator allocator? Workaround ranges::view
         std::vector<std::pair< typename std::vector<sp::timecode<T>>::iterator, typename std::vector<sp::timecode<T>>::iterator >> vectors_sliced;
         auto func = _fixpoints(_fixPoint_indices);
         func(std::begin(vectors), std::end(vectors), std::back_inserter(vectors_sliced));
         
-		auto out_vectors = std::vector<sp::timecode<T>>{};//((vectorSize * 2) + add);
-        
-        
-         //HERESTART
-         /* using bounds = std::pair< typename std::vector<sp::timecode<T>>::iterator, typename std::vector<sp::timecode<T>>::iterator >;//same as it_pair shared_types
-         std::vector<bounds> blocks;
-         auto b = _blocks(_samplesPerVector);
-         b(std::begin(vectors_sliced), std::end(vectors_sliced), std::back_inserter(blocks));
-         
-         std::vector<sp::timecode<T>> sums;
-         _sum_blocks(std::begin(blocks), std::end(blocks), std::back_inserter(sums));
-         
-         std::move(std::begin(sums), std::end(sums), std::back_inserter(out_vectors));*/
-         //HEREEND
-         
+		//HACK out_vectors needs to know size from blocks static func. Workaround ranges::view
+        auto out_vectors = std::vector<sp::timecode<T>>{};//((vectorSize * 2) + add);
         
         //hierarchy all to 1
         //std::transform(std::begin(vectors_sliced), std::end(vectors_sliced), std::back_inserter(out_vectors), [_samplesPerVector](decltype(vectors_sliced) v) {
         for (auto v : vectors_sliced) {
             stopeight::blocks<sp::timecode<T>> blocks_vector = stopeight::blocks<sp::timecode<T>>(v, _samplesPerVector);//v is it_pair<T>
             //std::move(slice), _samplesPerVector);
             
@@ -314,15 +233,15 @@
     template samples_To_VG<double>::~samples_To_VG();
     template samples_To_VG<float>::~samples_To_VG();
     template<class T> template <class UnaryFunction> std::vector<sp::timecode<T>> samples_To_VG<T>::operator()(std::vector<T>& samples, UnaryFunction& angleFunction)
     {
         size_t size = std::distance(std::begin(samples), std::end(samples));
         if (size > 0) {
             std::vector<T> differences = std::vector<T>(size, 0);
-            __differences(std::begin(samples), std::end(samples), std::begin(differences));
+            std::adjacent_difference(std::begin(samples), std::end(samples), std::begin(differences));
             
             return __differences_To_VG<T>(_samplesPerVector, _vectorLength, _fixPoint_indices)(differences, angleFunction);
         }
     }
     template std::vector<sp::timecode<double>> samples_To_VG<double>::operator()(std::vector<double>&, angle::sharing_angle&);
 	template std::vector<sp::timecode<float>> samples_To_VG<float>::operator()(std::vector<float>&, angle::sharing_angle&);
```

### Comparing `stopeight-0.3.14/stopeight-clibs/grapher/containers.cpp` & `stopeight-0.3.22/stopeight-clibs/grapher/containers.cpp`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/grapher/containers.h` & `stopeight-0.3.22/stopeight-clibs/grapher/containers.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/grapher/grapher.cpp` & `stopeight-0.3.22/stopeight-clibs/grapher/grapher.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -55,15 +55,15 @@
 	{
         //size_t vectorSize = grapher::samples_To_VG_vectorSize(buf->size(), _samplesPerVector);
         T vectorLength = grapher::samples_To_VG_vectorLength(_showSamples, _unitaryLength);
 		auto output = std::vector<sp::timecode<T>>{};
 
 		if (buf->size() > 2) {
 			std::vector<T> differences = std::vector<T>(buf->size(), 0.0);
-			grapher::__differences(std::begin(*buf), std::end(*buf), std::begin(differences));
+			std::adjacent_difference(std::begin(*buf), std::end(*buf), std::begin(differences));
 
 			//in general if uneven, middle is on left side
 			//-1 differences, -1 size
 			auto dvg = (grapher::__differences_To_VG<T>(_samplesPerVector, vectorLength, std::vector<size_t>(1, (((buf->size() - 1) / 2) - 1))));
 			if (_relative) {
 				angle::relative afunc = angle::relative(std::begin(differences) + 1, std::end(differences),_average,_angleScale);
 				output = dvg(differences, afunc);//((vectorSize * 2) + add);
```

### Comparing `stopeight-0.3.14/stopeight-clibs/grapher/grapher_impl.h` & `stopeight-0.3.22/stopeight-clibs/grapher/grapher_impl.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/grapher/iterators.h` & `stopeight-0.3.22/stopeight-clibs/grapher/iterators.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/grapher/mean.cpp` & `stopeight-0.3.22/stopeight-clibs/grapher/mean.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -20,15 +20,15 @@
 	template Mean<double>::~Mean();
 
 	template<typename T> double Mean<T>::operator()()
 	{
 		const int size = buf->size();
 		if (size > 0) {
 			std::vector<T> differences = std::vector<T>(size, 0.0f);
-			grapher::__differences(std::begin(*buf), std::end(*buf), std::begin(differences));
+			std::adjacent_difference(std::begin(*buf), std::end(*buf), std::begin(differences));
             return angle::__average(std::begin(differences)+1, std::end(differences));
 		}
 		else {
 			return 0.0f;
 		}
 	}
 	template double Mean<float>::operator()();
```

### Comparing `stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/Matrix.h` & `stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/Matrix.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/algo.h` & `stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/algo.h`

 * *Files 24% similar despite different names*

```diff
@@ -8,50 +8,27 @@
 
 namespace grapher {
 
 	template<typename T> using it_pair = std::pair< typename std::vector<sp::timecode<T>>::iterator, typename std::vector<sp::timecode<T>>::iterator >;
 
 	template<class InputIterator, class OutputIterator,
 		typename = typename std::enable_if_t<std::is_base_of<std::random_access_iterator_tag, typename std::iterator_traits<InputIterator>::iterator_category>::value && std::is_arithmetic<typename std::iterator_traits<InputIterator>::value_type>::value>
-	> void __differences(InputIterator begin, InputIterator end, OutputIterator begin2);
-
-	//OVERLOAD: multiple functions for class hierarchy (btw. SPECIALISATION is only for class-templates)
-	template<class InputIterator, class OutputIterator,
-		typename = typename std::enable_if_t<std::is_base_of<std::input_iterator_tag, typename std::iterator_traits<InputIterator>::iterator_category>::value && std::is_arithmetic<typename std::iterator_traits<InputIterator>::value_type>::value>
-	> void __calculate_rotations(InputIterator begin, InputIterator end, OutputIterator begin2, sp::sharing_functor<double,double>& angleFunction);
-	//readonly functor and input_iterator_tag combination is nonsense
-	template<class InputIterator, class OutputIterator,
-		typename = typename std::enable_if_t<std::is_base_of<std::input_iterator_tag, typename std::iterator_traits<InputIterator>::iterator_category>::value && std::is_arithmetic<typename std::iterator_traits<InputIterator>::value_type>::value>
-	> void __calculate_rotations(InputIterator begin, InputIterator end, OutputIterator begin2, sp::readonly_functor<double,double>& angleFunction);
-
-
-	template<class InputIterator, class OutputIterator,
-		typename = typename std::enable_if_t<std::is_base_of<std::random_access_iterator_tag, typename std::iterator_traits<InputIterator>::iterator_category>::value && std::is_arithmetic<typename std::iterator_traits<InputIterator>::value_type>::value>
 	> void __apply_rotation_matrix(InputIterator begin, InputIterator end, OutputIterator begin2);
 
 	class _fixpoints {
 	public:
 		_fixpoints(std::vector<size_t>& points);
 		~_fixpoints();
 		template <class InputIterator, class OutputIterator,
 		typename = typename sp::random_access<InputIterator>
 		>void operator()(InputIterator begin, InputIterator end, OutputIterator begin2);
 	private:
 		std::vector<size_t>& _fixPoint_indices;
 	};
 
-	class _blocks {
-	public:
-		_blocks(size_t samplesPerVector);
-		~_blocks();
-		template <class InputIterator, class OutputIterator>void operator()(InputIterator begin, InputIterator end, OutputIterator begin2);
-	private:
-		size_t _samplesPerVector;
-	};
-
 	template <class InputIterator, class OutputIterator>void _sum_blocks(InputIterator begin, InputIterator end, OutputIterator begin2);//freedom vector or deque//type in or out?
 
 	template <class InputIterator, class OutputIterator,
 		typename = typename sp::input_iterator<InputIterator>
 	>void _append(InputIterator begin, InputIterator end, OutputIterator begin2);
 
 	template<class T> class __differences_To_VG {
@@ -68,14 +45,15 @@
 
 	private:
 		size_t _samplesPerVector;
 		double _vectorLength;
 		std::vector<size_t> _fixPoint_indices;
 	};
 
+	//HACK These need to be samples_To_VG members, Generic out_to_in, in_to_out
 	int samples_To_VG_vectorSize(int inputSize, int samplesPerVector=1);
 	double samples_To_VG_vectorLength(int showSamples, double unitaryLength = 1);
 
 	template<class T> class samples_To_VG {
 	public:
 		//experimental value from notation2.wav => sin(1.0f/300.0f)
 		samples_To_VG(size_t samplesPerVector, double vectorLength, std::vector<size_t> fixPoints_indices = std::vector<size_t>(1, 0));
```

### Comparing `stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/analyzer.h` & `stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/analyzer.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/angle_functions.h` & `stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/angle_functions.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/grapher.h` & `stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/grapher.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/mean.h` & `stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/mean.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/preloaderif.h` & `stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/preloaderif.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/include/stopeight-clibs/shared_types.h` & `stopeight-0.3.22/stopeight-clibs/include/stopeight-clibs/shared_types.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/analyzer.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/analyzer.h`

 * *Files 25% similar despite different names*

```diff
@@ -1,27 +1,34 @@
 // Copyright (C) 2009-2015 Specific Purpose Software GmbH
 // GNU Lesser General Public License, version 2.1
 
 #ifndef ANALYZER_H
 #define ANALYZER_H
 
-#include "calculator.h"
 #include "listswitchable.h"
-#include "listcopyable.h"
+#include "calculator.h"
 #include "cornernormalizer.h"
 
-template<typename T> class Analyzer : public Calculator<T>
+namespace Analyzer {
+// careful: this is changing order
+    // does not change index-numbering variable
+    template<typename T>  void reverseOrder(ListSwitchable<T>& This);
+    // make const?
+    ListSwitchable<dpoint> populateTurns(const ListBase<dpoint> originalData, const QList<ListSwitchable<dpoint> > slices);
+
+}
+
+/*template<typename T> class Analyzer : public Calculator<T>
 {
 public:
-    Analyzer<T>();
-    template<typename F> Analyzer<T>(F& list);
+    using Calculator<T>::Calculator;
 
     // careful: this is changing order
     // does not change index-numbering variable
     void reverseOrder();
 
     // make const?
-    static Calculator<dpoint> populateTurns(ListBase<dpoint>& originalData, const QList<QList<dpoint> > slices);
+    static Calculator<dpoint> populateTurns(const ListBase<dpoint>& originalData, const QList<ListSwitchable<dpoint> > slices);
 
-};
+};*/
 
 #endif // ANALYZER_H
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/areaanalyzer.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/areaanalyzer.h`

 * *Files 26% similar despite different names*

```diff
@@ -1,29 +1,38 @@
 // Copyright (C) 2009-2015 Specific Purpose Software GmbH
 // GNU Lesser General Public License, version 2.1
 
 #ifndef AREAANALYZER_H
 #define AREAANALYZER_H
 
-#include "areanormalizer.h"
+#include "listswitchable.h"
+#include "areacalculator.h"
 #include "cliffsanalyzer.h"
-#include "listcopyable.h"
+#include "areanormalizer.h"
+
+namespace AreaAnalyzer {
+    template<typename T>  ListSwitchable<T> getFirstArea(ListSwitchable<T>& This,qreal limit);
+    // new Area function
+    template<typename T>  ListSwitchable<T> getArea(ListSwitchable<T>& This,qreal limit,T START,qreal preceding=0);
+    // protected
+    // Segment-Radius-Area; should be non-static with diameter=lengthStartToEnd from instance
+     qreal area(qreal diameter, qreal base);
+}
 
-template<typename T> class AreaAnalyzer : public AreaNormalizer<T>
+/*template<typename T> class AreaAnalyzer : public AreaNormalizer<T>
 {
 public:
-    AreaAnalyzer<T>();
-    template<typename F> AreaAnalyzer<T>(F& list);
+    using AreaNormalizer<T>::AreaNormalizer;
 
-    ListBase<dpoint> getFirstArea(qreal limit);
+    ListSwitchable<dpoint> getFirstArea(qreal limit);
 
     // new Area function
-    ListCopyable<dpoint> getArea(qreal limit,QPointF START,qreal preceding=0);
+    ListSwitchable<dpoint> getArea(qreal limit,QPointF START,qreal preceding=0);
 protected:
 
     // Segment-Radius-Area; should be non-static with diameter=lengthStartToEnd from instance
     static qreal area(qreal diameter, qreal base);
 
 
-};
+};*/
 
 #endif // AREAANALYZER_H
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/cliffsanalyzer.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/turnanalyzer.h`

 * *Files 27% similar despite different names*

```diff
@@ -1,29 +1,22 @@
 // Copyright (C) 2009-2015 Specific Purpose Software GmbH
 // GNU Lesser General Public License, version 2.1
 
-#ifndef CLIFFSANALYZER_H
-#define CLIFFSANALYZER_H
+#ifndef TURNANALYZER_H
+#define TURNANALYZER_H
 
-#include "listbase.h"
-#include "cliffsnormalizer.h"
-#include "listcopyable.h"
-
-template<typename T> class CliffsAnalyzer : public CliffsNormalizer<T>
+#include "turnnormalizer.h"
+#include "straightsanalyzer.h"
+#include "listswitchable.h"
+#include "cornernormalizer.h"
+#include "corneranalyzer.h"
+template<typename T> class TurnAnalyzer : public TurnNormalizer<T>
 {
 public:
-    CliffsAnalyzer<T>();
-    template<typename F> CliffsAnalyzer<T>(F& list);
-
-    // This is the replacement for getFirstCliff
-    ListCopyable<dpoint> getFirstLegalSegment();
-
-    ListCopyable<dpoint> getFirstCliff(qreal limit=M_PIl);
-    //ListCopyable<dpoint> getFirstCliffTCT(qreal limit=M_PIl);
-
-
-    // used by filters and analyzer
-    int hasIllegalSegment();
+    using TurnNormalizer<T>::TurnNormalizer;
 
+    ListCopyable<dpoint> getFirstTurnByTriplets();
+    // This is replacement for old_code scalar/crest approach
+    ListCopyable<dpoint> getFirstTriplet();
 };
 
-#endif // CLIFFSANALYZER_H
+#endif // TURNANALYZER_H
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/cliffsnormalizer.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/cliffsnormalizer.h`

 * *Files 21% similar despite different names*

```diff
@@ -1,21 +1,23 @@
 // Copyright (C) 2009-2015 Specific Purpose Software GmbH
 // GNU Lesser General Public License, version 2.1
 
 #ifndef CLIFFSNORMALIZER_H
 #define CLIFFSNORMALIZER_H
 
-#include "areacalculator.h"
-#include "turnnormalizer.h"
+#include "listswitchable.h"
 #include "cornernormalizer.h"
+namespace CliffsNormalizer {
+    // these methods are being used for cleaning up the segments before the corner detection
+    template<typename T> void cliffFilters(ListSwitchable<T>& This);
+}
 
-template<typename T> class CliffsNormalizer : public AreaCalculator<T>
+/*template<typename T> class CliffsNormalizer : public AreaCalculator<T>
 {
 public:
-    CliffsNormalizer<T>();
-    template<typename F> CliffsNormalizer<T>(F& list);
+    using AreaCalculator<T>::AreaCalculator;
 
     // these methods are being used for cleaning up the segments before the corner detection
     void cliffFilters();
-};
+};*/
 
 #endif // CLIFFSNORMALIZER_H
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/corners.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/corners.h`

 * *Files 18% similar despite different names*

```diff
@@ -1,22 +1,25 @@
 // Copyright (C) 2009-2015 Specific Purpose Software GmbH
 // GNU Lesser General Public License, version 2.1
 
-//#ifndef CORNERS_H
-//#define CORNERS_H
+#ifndef CORNERS_H
+#define CORNERS_H
 
 #include "listswitchable.h"
-#include "listcopyable.h"
+#include "cornernormalizer.h"
 #include "corneranalyzer.h"
+namespace Corners {
+    // Note: These only work as expected, if crests have been sliced. Otherwise: Only 1st result reliable
+    template<typename T> QList<T> findCorners(ListSwitchable<T> toBeProcessed);
+}
 
-template<typename T> class Corners : public ListSwitchable<T>
+/*template<typename T> class Corners : public ListSwitchable<T>
 {
 public:
-    Corners<T>();
-    template<typename F> Corners<T>(F& list);
+    using ListSwitchable<T>::ListSwitchable;
 
     // Note: These only work as expected, if crests have been sliced. Otherwise: Only 1st result reliable
-    static QList<dpoint> findCorners(ListCopyable<dpoint> toBeProcessed);
+    static QList<dpoint> findCorners(ListSwitchable<dpoint> toBeProcessed);
 
-};
+};*/
 
-//#endif // CORNERS_H
+#endif // CORNERS_H
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/dpoint.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/dpoint.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/editorbase.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/editorbase.h`

 * *Files 14% similar despite different names*

```diff
@@ -7,16 +7,14 @@
 // Will move into implementations when all are completed, or make interface configuration call?
 #define MAX_POINTS 5
 //#define LIMIT_TEST M_El
 //#define LIMIT_TEST M_PIl
 #define LIMIT_ITERATION_STEP 0.1
 
 #include "editorinterface.h"
-#include "listbase.h"
-#include "listcopyable.h"
 //#include "myreal.h"
 
 template<typename T> struct ListStorage{
     ListStorage<T>() : input(T()), output(T()){}
 
     // input is always the raw data either from file or pen/mouse stroke
     T input;
@@ -31,25 +29,25 @@
     EditorBase<T>();
     //~EditorBase();
 
     void resetLists();
     void addPoint(QPointF p);
     //dont make getOutput const, see reversal in spiral process
     T& getOutput();
-	QList<QPointF> getConvertedOutput();
+	//ListSwitchable<dpoint> getConvertedOutput();
     void flushOutput();
 
     void automatic();
-	void automatic(QList<QPointF> list);
+	void automatic(ListSwitchable<dpoint> list);
 
 protected:
 
     void setOutput(T list);
 
-    void mainIterator(const QList<dpoint>& constCliffs,QList<QList<dpoint> >& slicesRef);
+    void mainIterator(const ListSwitchable<dpoint> constCliffs,QList<ListSwitchable<dpoint> >& slicesRef);
 
 private:
     //should ONLY be accessed for implementation instantiation
     ListStorage<T > data;
 
 
 };
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/editorinterface.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/editorinterface.h`

 * *Files 25% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 // Copyright (C) 2009-2015 Specific Purpose Software GmbH
 // GNU Lesser General Public License, version 2.1
 
 #ifndef EDITORINTERFACE_H
 #define EDITORINTERFACE_H
 
-#include "listbase.h"
+#include "listswitchable.h"
 
 template<typename T> class EditorInterface
 {
 public:
     //int maxPoints;
      virtual T& getOutput() =0;
      virtual void flushOutput() =0;
@@ -18,14 +18,14 @@
     // gets called from TileDrawingEvent in inputPress
      virtual void resetLists() =0;
     // gets called on tablet/mouse release
      virtual void automatic() =0;
 
 protected:
     //only these two have to be provided by implementations
-    virtual QList<dpoint> processSegment(QList<dpoint>::iterator start,QList<dpoint>::iterator end) =0;
-    virtual void process(ListBase<dpoint>& toBeProcessed) =0;
+    virtual ListSwitchable<dpoint> processSegment(ListSwitchable<dpoint>::iterator start,ListSwitchable<dpoint>::iterator end) =0;
+    virtual void process(ListSwitchable<dpoint>& toBeProcessed) =0;
 
 };
 
 
 #endif // EDITORINTERFACE_H
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/editorspirals.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/editorspirals.h`

 * *Files 12% similar despite different names*

```diff
@@ -3,25 +3,24 @@
 
 #ifndef EDITORSPIRALS_H
 #define EDITORSPIRALS_H
 
 #include "editorcliffs.h"
 #include "spirals.h"
 #include "spiralsanalyzer.h"
-
 class EditorSpirals : public EditorCliffs
 {
 public:
     EditorSpirals();
     //~EditorSpirals();
 
 
 protected:
     // automatic detection of "spirals" that don't include any illegal segments, which would make derivations invalid. See throw jitter detected
-    void process(ListBase<dpoint>& toBeProcessed);
+    void process(ListSwitchable<dpoint>& toBeProcessed);
 
 private:
-    QList<dpoint> processSegment(QList<dpoint>::iterator start,QList<dpoint>::iterator end);
+    ListSwitchable<dpoint> processSegment(ListSwitchable<dpoint>::iterator start,ListSwitchable<dpoint>::iterator end);
 
 };
 
 #endif // EDITORSPIRALS_H
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/error.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/error.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/legacy_global.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/legacy_global.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/listbase.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/listbase.h`

 * *Files 20% similar despite different names*

```diff
@@ -4,47 +4,51 @@
 #ifndef LISTBASE_H
 #define LISTBASE_H
 
 #include "legacy_global.h"
 
 #include <QtCore/QString>
 #include <QtCore/QFile>
+#include <QtCore/QFileInfo>
 #include <QtCore/QDataStream>
 
 #include "dpoint.h"
 #include "myreal.h"
 
 #include "error.h"
 
+#include <array>
+#include <QtCore/QList>
+struct ArrayOfTwoQListDpointIterators : std::array<QList<dpoint>::iterator, 2>{};
+
 /* This is being used by both the qt-based editor AND python legacy-wrappers! */
 template<typename T> class ListBase : public QList<T>
 {
 public:
-    //has to be templated because of QList
-    ListBase<T>();
-    //virtual ~ListBase()=0;
-
-    //this should be C++11 move F&& constructor
-    //is there a copy created when using F& instead of F?
-    template<typename F> ListBase<T>(F& list);
-    template<typename F> ListBase<T>(const F& list);
-
+    using QList<T>::QList;
 
     // method for access from python
     static QList<QPointF> open(const char* fileName);
     // method for access from legacy editor
     static QList<QPointF> loadSPFile(const QString &fileName);
 	// for old files
 //	static ListBase<dpoint> loadSPFile(const QString &fileName);
 	// method for access from both
 	static QList<QPointF> convert(ListBase<dpoint> list);
 
+    //from ListCopyAble
+    ArrayOfTwoQListDpointIterators position_to_iterator(int startPosition, int endPosition);
+    qreal lengthAt(int i);
+    static qreal lengthOf(QPointF difference);
+    //from Straights
+    // length of curve between "all"! points / curvature not included
+    qreal sumLength();
 
 
-protected:
+//protected:
 	bool checkPrecision();
 
 };
 
 //GCC bug?
 //extern template class ListBase<dpoint>;
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/listrotator.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/listrotator.h`

 * *Files 22% similar despite different names*

```diff
@@ -19,17 +19,15 @@
 #include <QtGui/QTransform>
 
 #include "listbase.h"
 
 template<typename T> class ListRotator : public ListBase<T>
 {
 public:
-    ListRotator<T>();
-    template<typename F> ListRotator<T>(F& list);
-    template<typename F> void operator=(F& list);
+    using ListBase<T>::ListBase;
 
     void rotateSegmentToXAxis();
     //void rotateLastVectorToYAxis();
     //void rotateSegmentToSteepest(QPointF lastVector, QPointF startToEndVector);
 private:
     void moveRotToZero();
     void rotate(double deg);
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/myreal.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/myreal.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/include/render.h` & `stopeight-0.3.22/stopeight-clibs/legacy/include/render.h`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/src/analyzer.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/src/analyzer.cpp`

 * *Files 20% similar despite different names*

```diff
@@ -1,60 +1,45 @@
 // Copyright (C) 2009-2015 Specific Purpose Software GmbH
 // GNU Lesser General Public License, version 2.1
 
 #include "analyzer.h"
 
 #define debug() QNoDebug()
 
-template<> Analyzer<dpoint>::Analyzer() : Calculator(){}
-
-// Note: ALL datamembers of target class destroyed
-template<>template<typename F> Analyzer<dpoint>::Analyzer(F& list) : Calculator(list) {
-    ListBase<dpoint> c = static_cast<ListBase<dpoint>& >(list);
-    // ListCopyable to Analyzer NOT ok
-    *this= static_cast<Analyzer<dpoint>& >(c);
-    //*this = static_cast<Analyzer<dpoint>& >(list);
-}
-
-template Analyzer<dpoint>::Analyzer(Analyzer<dpoint>& list);
-template Analyzer<dpoint>::Analyzer(ListBase<dpoint>& list);
-template Analyzer<dpoint>::Analyzer(ListCopyable<dpoint>& list);
-template Analyzer<dpoint>::Analyzer(QList<dpoint>& list);
-
 // Sould only be allowed in ListCopyable
 // only call ONCE
-template<> void Analyzer<dpoint>::reverseOrder(){
-    ListSwitchable<dpoint> reversed= ListSwitchable<dpoint>();
+template<typename T> void Analyzer::reverseOrder(ListSwitchable<T>& This){
+    auto reversed= ListSwitchable<dpoint>();
     int pointer = 0;
-    for (int i=this->size()-1;i>=0;i--){
-        dpoint point = this->at(i);
+    for (int i=This.size()-size_t(1);i>=size_t(0);i--){
+        dpoint point = This.at(i);
         point.position=pointer;
         reversed << point;
         pointer++;
     }
-    this->clear();
-    this->append(reversed);
+    This.clear();
+    This.append(reversed);
 }
+template void Analyzer::reverseOrder(ListSwitchable<dpoint>& This);
 
-template<> Calculator<dpoint> Analyzer<dpoint>::populateTurns(ListBase<dpoint> &originalData, const QList<QList<dpoint> > slices){
-    Calculator<dpoint> result;
-    for (int k=0;k<slices.size();k++){
-        for (int l=0;l<slices[k].size()-1;l++){
+ListSwitchable<dpoint> Analyzer::populateTurns(const ListBase<dpoint> originalData, const QList<ListSwitchable<dpoint> > slices){
+    auto result = ListSwitchable<dpoint>();
+    for (int k=size_t(0);k<slices.size();k++){
+        for (int l=size_t(0);l<slices[k].size()-size_t(1);l++){
             result << slices[k][l];
             // this is for debugging turn detection
-            ListCopyable<dpoint> iter = ListCopyable<dpoint>(originalData);
             //ListBase<dpoint> lst = iter.chopCopy(slices[k][l].position,slices[k][l+1].position);
-            auto it = iter.position_to_iterator(slices[k][l].position,slices[k][l+1].position);
-            auto lst = ListBase<dpoint>();
-            std::copy(it[0],it[1],std::back_inserter(lst));
-            CornerNormalizer<dpoint> mid = CornerNormalizer<dpoint>(lst);
-            auto middle = mid.getPointInTheMiddle();
+            ListBase<dpoint>& temp = const_cast<ListBase<dpoint>&>(originalData);
+            auto it = temp.position_to_iterator(slices[k][l].position,slices[k][l+1].position);
+            auto mid = ListSwitchable<dpoint>();
+            std::copy(it[0],it[1],std::back_inserter(mid));
+            auto middle = CornerNormalizer::getPointInTheMiddle(mid);
             middle.position = -1;
             result << middle;
             //result << mid.getPointInTheMiddle();
         }
-        if ((k==slices.size()-1) && (slices[k].size()>0)){
+        if ((k==slices.size()-size_t(1)) && (slices[k].size()>size_t(0))){
             result << slices[k].last();
         }
     }
     return result;
-}
+}
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/src/areaanalyzer.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/src/areaanalyzer.cpp`

 * *Files 19% similar despite different names*

```diff
@@ -1,70 +1,54 @@
 // Copyright (C) 2009-2015 Specific Purpose Software GmbH
 // GNU Lesser General Public License, version 2.1
 
 #include "areaanalyzer.h"
 
 #define debug() QNoDebug()
-
-
-template<> AreaAnalyzer<dpoint>::AreaAnalyzer() : AreaNormalizer<dpoint>() {}
-
-// Note: ALL datamembers of target class destroyed
-template<>template<typename F> AreaAnalyzer<dpoint>::AreaAnalyzer(F& list) : AreaNormalizer<dpoint>(list) {
-    ListBase<dpoint> c = static_cast<ListBase<dpoint>& >(list);
-    // ListBase to AreaAnalyzer NOT ok
-    *this= static_cast<AreaAnalyzer<dpoint>& >(c);
-}
-
-template AreaAnalyzer<dpoint>::AreaAnalyzer(AreaAnalyzer<dpoint>& list);
-// listbase to AreaAnalyzer NOT ok
-template AreaAnalyzer<dpoint>::AreaAnalyzer(ListBase<dpoint>& list);
-template AreaAnalyzer<dpoint>::AreaAnalyzer(ListCopyable<dpoint>& list);
-
 // Segment-Radius-Area
-template<> qreal AreaAnalyzer<dpoint>::area(qreal diameter, qreal base){
+qreal AreaAnalyzer::area(qreal diameter, qreal base){
     qreal squareOfRadius = pow(diameter/2,2);
     //qreal criteria = (squareOfRadius*(base))/2;
     // accounting for integration error; dangerous when iterating limit
     qreal criteria = (squareOfRadius*(base-M_LOG10El))/2;
 
     if (criteria<0){throw "AreaCalculator.h::area criteria below zero";}
     return criteria;
 }
 
-template<> ListCopyable<dpoint> AreaAnalyzer<dpoint>::getArea(qreal limit,QPointF start,qreal preceding){
-    AreaCalculator<dpoint> result = AreaCalculator<dpoint>();
+template<typename T> ListSwitchable<T> AreaAnalyzer::getArea(ListSwitchable<T>& This,qreal limit,T start,qreal preceding){
+    auto result = ListSwitchable<T>();
 
     bool foundOne=false;
 
-    if (this->size()>1){
-        result<<this->first();
-        for (int i=1;i<this->size();i++){
-            result<<this->at(i);
+    if (This.size()>size_t(1)){
+        result<<This.first();
+        for (int i=size_t(1);i<This.size();i++){
+            result<<This.at(i);
 
             result.rotateSegmentToXAxis();
 
             qreal currentArea = 0;
             if (preceding>0){
                 // calculate current triangle based on iteration
                 // we need area starting point for this!
                 // currentArea += triangle
-                currentArea += triangleArea(start,result.first(),result.last());
+                currentArea += AreaCalculator::triangleArea(start,result.first(),result.last());
             }
             // instead of this we could be using an implementation that sums up doubleTriangles
-            currentArea += result.sumOfDxAreasRotY();
+            currentArea += AreaCalculator::sumOfDxAreasRotY(result);
 
             if (preceding<0){throw "ListAnalyzer::getArea: preceding is below zero";}
             if (currentArea<0){throw "ListAnalyzer::getArea: currentArea is below zero";}
 
             // IF preceding + currentArea >= norm: norm is area(fullDIAMETER from start, pi or e, 0)
 
-            AreaCalculator<dpoint> StartEnd = AreaCalculator<dpoint>();
+            auto StartEnd = ListSwitchable<T>();
             StartEnd << start << result.last();
-            qreal diameter = StartEnd.lengthFromStartToEnd();
+            qreal diameter = AreaCalculator::lengthFromStartToEnd(StartEnd);
             // using sumOfDx would require having all preceding legalSegments from start and adding up sums
 
             qreal norm = area(diameter,limit);//,0);
             if (norm<0){throw "ListAnalyzer::getArea: norm is below zero";}
 
             //if (currentArea>=criteria){
             if ((preceding+currentArea)>=norm){
@@ -77,92 +61,92 @@
             result.removeLast();
         }
     }
     else {
 		throw legacy::alg_logic_error("Before area search segment size is below 2",__FILE__,"");
 		//C++11
         //throw legacy::alg_logic_error("Before area search segment size is below 2",__FILE__,__func__);
-        for (int i=0;i<this->size();i++){
-            result<<this->at(i);
+        for (auto i=size_t(0);i<This.size();i++){
+            result<<This.at(i);
         }
     }
     // removing
-    for (int i=0;i<result.size();i++){
-        this->removeFirst();
+    for (int i=size_t(0);i<result.size();i++){
+        This.removeFirst();
     }
 
     return result;
 }
+template ListSwitchable<dpoint> AreaAnalyzer::getArea(ListSwitchable<dpoint>& This,qreal limit,dpoint start,qreal preceding);
 
-template<> ListBase<dpoint> AreaAnalyzer<dpoint>::getFirstArea(qreal limit){
-    dpoint result = dpoint();
+template<typename T> ListSwitchable<T> AreaAnalyzer::getFirstArea(ListSwitchable<T>& This,qreal limit){
+    auto result = T();
     // needs to be and is a COPY
-    ListCopyable<dpoint> copy = ListCopyable<dpoint>(*this);
-    CliffsAnalyzer<dpoint> calculator = CliffsAnalyzer<dpoint>(copy);
+    auto calculator = ListSwitchable<T>(This);
 
     bool foundOne = false;
     int illegalSegmentCounter=0;
 
-    if (calculator.size()>1){
-        ListCopyable<dpoint> tmp =ListCopyable<dpoint>(calculator.getFirstLegalSegment());
-        AreaAnalyzer<dpoint> legalSegment = AreaAnalyzer<dpoint>(tmp);
+    if (calculator.size()>size_t(1)){
+        //ListSwitchable<dpoint> tmp = ListSwitchable<dpoint>(calculator.getFirstLegalSegment());
+        auto legalSegment = ListSwitchable<T>{ std::move(CliffsAnalyzer::getFirstLegalSegment(calculator)) };
         illegalSegmentCounter++;
-        legalSegment.areaFilters();
-        tmp = legalSegment.getArea(limit,legalSegment.first());
-        AreaAnalyzer<dpoint> preceding = AreaAnalyzer<dpoint>(tmp);
-        if (legalSegment.size()>0){
+        AreaNormalizer::areaFilters(legalSegment);
+        //tmp = legalSegment.getArea(limit,legalSegment.first());
+        auto preceding = ListSwitchable<T>{std::move(AreaAnalyzer::getArea(legalSegment,limit, legalSegment.first()))};
+        if (legalSegment.size()>size_t(0)){
             foundOne = true;
             result = preceding.last();
         } else {
             qreal sumOfAllPreceding = 0;
-            if (calculator.size()>1){
+            if (calculator.size()>size_t(1)){
                 calculator.prepend(preceding.last());
-                tmp = calculator.getFirstLegalSegment();
-                legalSegment = AreaAnalyzer<dpoint>(tmp);
+                //tmp = calculator.getFirstLegalSegment();
+                legalSegment = ListSwitchable<T>{ std::move(CliffsAnalyzer::getFirstLegalSegment(calculator)) };
                 illegalSegmentCounter++;
-                legalSegment.areaFilters();
-                preceding.areaFilters();
-                tmp = legalSegment.getArea(limit,this->first(),preceding.sumOfDxAreasRotY());
-                preceding = AreaAnalyzer<dpoint>(tmp);
-                if (legalSegment.size()>0){
+                AreaNormalizer::areaFilters(legalSegment);
+                AreaNormalizer::areaFilters(preceding);
+                //tmp = legalSegment.getArea(limit,this->first(),preceding.sumOfDxAreasRotY());
+                preceding = ListSwitchable<T>{ std::move(AreaAnalyzer::getArea(legalSegment,limit, This.first(), AreaCalculator::sumOfDxAreasRotY(preceding))) };
+                if (legalSegment.size()>size_t(0)){
                     foundOne = true;
                     result = preceding.last();
                 } else {
-                    while (calculator.size()>1){
+                    while (calculator.size()>size_t(1)){
                         calculator.prepend(preceding.last());
-                        tmp = calculator.getFirstLegalSegment();
-                        legalSegment = AreaAnalyzer<dpoint>(tmp);
+                        //tmp = calculator.getFirstLegalSegment();
+                        legalSegment = ListSwitchable<T>{ std::move(CliffsAnalyzer::getFirstLegalSegment(calculator)) };
                         illegalSegmentCounter++;
-                        legalSegment.areaFilters();
-                        preceding.areaFilters();
+                        AreaNormalizer::areaFilters(legalSegment);
+                        AreaNormalizer::areaFilters(preceding);
                         // sumOfDx over illegal segments is too agressive -> jitter/illegal separation
-                        sumOfAllPreceding += preceding.sumOfDxAreasRotY() + preceding.area(preceding.lengthFromStartToEnd(),limit);
-                        tmp = legalSegment.getArea(limit,this->first(),sumOfAllPreceding);
-                        preceding = AreaAnalyzer<dpoint>(tmp);
-                        if (legalSegment.size()>0){
+                        sumOfAllPreceding += AreaCalculator::sumOfDxAreasRotY(preceding) + AreaAnalyzer::area(AreaCalculator::lengthFromStartToEnd(preceding),limit);
+                        //tmp = legalSegment.getArea(limit,this->first(),sumOfAllPreceding);
+                        preceding = ListSwitchable<T>{ std::move(AreaAnalyzer::getArea(legalSegment,limit, This.first(), sumOfAllPreceding)) };
+                        if (legalSegment.size()>size_t(0)){
                             foundOne = true;
                             result = preceding.last();
                             break;
                         }
                     }
                 }
             }
         }
     }
-    ListCopyable<dpoint> area = ListCopyable<dpoint>();
+    auto area = ListSwitchable<T>();
     if (foundOne){
-        ListCopyable<dpoint> util = ListCopyable<dpoint>(*this);
         //area = util.chopCopy(util.first().position,result.position);
         area.clear();
-        auto it = util.position_to_iterator(util.first().position,result.position);
+        auto it = This.position_to_iterator(This.first().position,result.position);
         std::copy(it[0],it[1],std::back_inserter(area));
         //debug()<<"Area has "<<illegalSegmentCounter<<" legal segments.";
     } else {
-        area = *this;
+        area = This;
     }
     // removing
-    for (int i=0;i<area.size();i++){
-        this->removeFirst();
+    for (int i=size_t(0);i<area.size();i++){
+        This.removeFirst();
     }
     return area;
 }
+template ListSwitchable<dpoint> AreaAnalyzer::getFirstArea(ListSwitchable<dpoint>& This,qreal limit);
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/src/cliffs.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/src/cliffs.cpp`

 * *Files 20% similar despite different names*

```diff
@@ -2,34 +2,30 @@
 // GNU Lesser General Public License, version 2.1
 
 #include "cliffs.h"
 
 //#define debug() QDebug(QtDebugMsg)//::QDebug(QtDebugMsg)
 #define debug() QNoDebug()
 
-template<> Cliffs<dpoint>::Cliffs() : ListSwitchable<dpoint>() {}
-
-// Note: typename F can be any implementation of ListBase WITHOUT data members
-template<>template<typename F> Cliffs<dpoint>::Cliffs(F& list) : ListSwitchable<dpoint>(){
-    ListSwitchable<dpoint>& c = static_cast<ListSwitchable<dpoint>& >(list);
-    *this= static_cast<Cliffs<dpoint>& >(c);
-}
-
-template Cliffs<dpoint>::Cliffs(ListBase<dpoint>& list);
-
 //ShapeMatcher::findCliffs
-template<> QList<dpoint> Cliffs<dpoint>::findCliffs(ListCopyable<dpoint> toBeProcessed){
+template<typename T> ListSwitchable<T> Cliffs::findCliffs(const ListSwitchable<T> toBeProcessed){
     //test for illegalPointRemoval
-    QList<dpoint> result=QList<dpoint>();
-    CliffsAnalyzer<dpoint> calculator = CliffsAnalyzer<dpoint>(toBeProcessed);
-    while (calculator.size()>2) {
-        calculator.cliffFilters();
+    auto result=ListSwitchable<T>();
+    auto calculator = ListSwitchable<T>(toBeProcessed);
+    while (calculator.size()>size_t(2)) {
+        CliffsNormalizer::cliffFilters(calculator);
         //older
-        ListCopyable<dpoint> cliff = calculator.getFirstLegalSegment();
+        auto firstLegal = CliffsAnalyzer::getFirstLegalSegment(calculator);
+        //if (!(firstLegal.size() > size_t(1)))
+        //    throw std::logic_error("getFirstLegalSegment has returned illegal length");
+        auto cliff = ListSwitchable<dpoint>(std::move(firstLegal));
         //or newer impl?
         //ListCopyable<dpoint> cliff = calculator.getFirstCliff();
+        //if (!(cliff.size() > size_t(1)))
+        //    throw std::logic_error("ListSwitchable upcast not working");
         result << cliff.last();
     }
     // The last one is the end of the stroke
     result.removeLast();
     return result;
 }
+template ListSwitchable<dpoint> Cliffs::findCliffs(const ListSwitchable<dpoint> toBeProcessed);
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/src/cliffsanalyzer.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/src/cliffsanalyzer.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -1,78 +1,46 @@
 // Copyright (C) 2009-2015 Specific Purpose Software GmbH
 // GNU Lesser General Public License, version 2.1
 
 #include "cliffsanalyzer.h"
+#include "listswitchable.h"
 
-template<> CliffsAnalyzer<dpoint>::CliffsAnalyzer() : CliffsNormalizer<dpoint>() {}
-
-// Note: ALL datamembers of target class destroyed
-template<>template<typename F> CliffsAnalyzer<dpoint>::CliffsAnalyzer(F& list) : CliffsNormalizer<dpoint>(list){
-    // should be listswitchable
-    ListBase<dpoint> c = static_cast<ListBase<dpoint>& >(list);
-    *this= static_cast<CliffsAnalyzer<dpoint>& >(c);
-}
-
-#include "areaanalyzer.h"
-//area to cliff ok
-template CliffsAnalyzer<dpoint>::CliffsAnalyzer(AreaAnalyzer<dpoint>& list);
-template CliffsAnalyzer<dpoint>::CliffsAnalyzer(ListCopyable<dpoint>& list);
-
-template <> int CliffsAnalyzer<dpoint>::hasIllegalSegment(){
-    ListRotator<dpoint> rotator = ListRotator<dpoint>(*this);
-    // has to change to steepest possible?
-    rotator.rotateSegmentToXAxis();
-    //rotateLastVectorToYAxis();
-
-    for (int i=0;i<rotator.size()-1;i++){
-        if ((rotator.at(i+1).rot.x()<=rotator.at(i).rot.x())
-                //&&(rotator.at(i+1).rot.y()<HIGHPASS_LOW_LIMIT)
-                )
-        {
-            //debug() << "Illegal Segment found at " << rotator.at(i+1);
-            return rotator.at(i+1).position;
-        }
-    }
-    return -1;
-}
-
-template<> ListCopyable<dpoint> CliffsAnalyzer<dpoint>::getFirstLegalSegment(){
-    CliffsAnalyzer<dpoint> result = CliffsAnalyzer<dpoint>();
-    if (this->size()>1){
-
+template<typename T> ListSwitchable<T> CliffsAnalyzer::getFirstLegalSegment(ListSwitchable<T>& This){
+    auto result = ListSwitchable<T>();
+    if (This.size()>size_t(1)){
         bool foundOne=false;
-        for (int i=0;i<this->size();i++){
-            result<<this->at(i);
+        for (int i=size_t(0);i<This.size();i++){
+            result<<This.at(i);
             if (result.hasIllegalSegment()!=-1){
                 foundOne=true;
                 break;
             }
         }
         if (foundOne){
             result.removeLast();
         }
     } else {
         //throw "ListAnalyzer::getFirstLegalSegment: segment size is below 2";
-        for (int i=0;i<this->size();i++){
-            result<<this->at(i);
+        for (int i=size_t(0);i<This.size();i++){
+            result<<This.at(i);
         }
     }
-    for (int i=0;i<result.size();i++){
-        this->removeFirst();
+    for (int i=size_t(0);i<result.size();i++){
+        This.removeFirst();
     }
 
     result.rotateSegmentToXAxis();
 
     return result;
 }
-
+template ListSwitchable<dpoint> CliffsAnalyzer::getFirstLegalSegment(ListSwitchable<dpoint>& This);
 //NEVER USED
 //editorcliffs implementation is using getFirstLegalSegment
 //FOR REFERENCE
-template<> ListCopyable<dpoint> CliffsAnalyzer<dpoint>::getFirstCliff(qreal limit){
+/*template<> ListCopyable<dpoint> CliffsAnalyzer<dpoint>::getFirstCliff(qreal limit){
     //specialised internally!
     dpoint result = dpoint();
 
     // from AreaAnalyzer::getFirstArea
     // needs to be and is a COPY
     ListCopyable<dpoint> copy = ListCopyable<dpoint>(*this);
     CliffsAnalyzer<dpoint> calculator = CliffsAnalyzer<dpoint>(copy);
@@ -136,22 +104,22 @@
     for (int i=0;i<area.size();i++){
         this->removeFirst();
     }
     return area;
 
     // TCT implementation was here, now getFirstCliffTCT
 
-}
+}*/
 
 //NEVER USED
 //editorcliffs implementation is using getFirstLegalSegment
 //FOR REFERENCE
 /*template<> ListCopyable<dpoint> CliffsAnalyzer<dpoint>::getFirstCliffTCT(qreal limit){
     ListCopyable<dpoint> copy = ListCopyable<dpoint>(*this);
-    ListCopyable<dpoint> calculator = ListCopyable(*this);
+    ListCopyable<dpoint> calculator = ListCopyable<dpoint(*this);
     // TCT implementation?
 
     // first Operation without preceding triangles and areas
     while (calculator.size()>1){
         ListCopyable<dpoint> legalSegment = calculator.getFirstLegalSegment();
         //if (count!=0 && legalSegment.size()>0){
         //    legalSegment.removeFirst();
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/src/cliffscalculator.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/src/cliffscalculator.cpp`

 * *Files 16% similar despite different names*

```diff
@@ -2,85 +2,73 @@
 // GNU Lesser General Public License, version 2.1
 
 #include "cliffscalculator.h"
 
 #define ZERO_INCLIN1 0
 #define ZERO_INCLIN2 0
 
-template<> CliffsCalculator<dpoint>::CliffsCalculator() : ListSwitchable<dpoint>() {}
-
-// Note: ALL datamembers of target class destroyed
-template<>template<typename F> CliffsCalculator<dpoint>::CliffsCalculator(F& list) : ListSwitchable<dpoint>(list){
-    // should be listswitchable
-    ListBase<dpoint> c = static_cast<ListBase<dpoint>& >(list);
-    *this= static_cast<CliffsCalculator<dpoint>& >(c);
-}
-
-#include "areaanalyzer.h"
-template CliffsCalculator<dpoint>::CliffsCalculator(AreaAnalyzer<dpoint>& list);
-template CliffsCalculator<dpoint>::CliffsCalculator(ListCopyable<dpoint>& list);
-#include "corneranalyzer.h"
-template CliffsCalculator<dpoint>::CliffsCalculator(CornerAnalyzer<dpoint>& list);
-
 // inline specialisation
-template <> QPointF CliffsCalculator<dpoint>::delta1At(int position){
+template<typename T> T CliffsCalculator::delta1At(ListSwitchable<T>& This,size_t position){
 
-    if (position<this->size()){
+    if (position<This.size()){
 
         // this has to change to steepest possible
         //this->rotateSegmentToXAxis();
-        dpoint point1,point2;
-        QPointF delta1;
+        T point1,point2;
+        T delta1;
 
-        QListIterator<dpoint> i(*this);
-        if (i.findNext(this->at(position))) {
+        auto i = QListIterator<T>(This);
+        if (i.findNext(This.at(position))) {
             if (i.hasPrevious()){
                 point1 = i.previous();
                 if (i.hasNext()){
                     i.next();
                     if (i.hasNext()){
                         point2 = i.next();
                         delta1 = point2.rot-point1.rot;
                         return delta1;
                     } else {
-                        return QPointF(0,0);
+                        return T(0,0);
                     }
                 }
             } else {
-                return QPointF(0,0);
+                return T(0,0);
             }
         } else {
-            return QPointF(0,0);
+            return T(0,0);
         }
     } else {
         throw "ListCalculator<dpoint>::delta1At: index out of range";
         // never happens
-        return QPointF(0,0);
+        return T(0,0);
     }
     throw "ListCalculator<dpoint>::delta1At";
     // never happens
-    return QPointF(0,0);
+    return T(0,0);
 }
+template dpoint CliffsCalculator::delta1At(ListSwitchable<dpoint>& This,size_t position);
 
-template <> qreal CliffsCalculator<dpoint>::inclin1At(int i){
-    QPointF d1 = this->delta1At(i);
+template <typename T> qreal CliffsCalculator::inclin1At(ListSwitchable<T>& This,size_t i){
+    T d1 = CliffsCalculator::delta1At(This,i);
     //if (d1.x()==0) {
     //    return 0;
     //} else {
     return d1.y()/d1.x();
     //}
 }
+template qreal CliffsCalculator::inclin1At(ListSwitchable<dpoint>& This,size_t i);
 
 // Warning: this is looking back
-template <> bool CliffsCalculator<dpoint>::deriv1Crossed(int pos){
-    if(pos < 1)
+template <typename T> bool CliffsCalculator::deriv1Crossed(ListSwitchable<T>& This,size_t pos){
+    if(pos < size_t(1))
         return false;
 
-    qreal d1 = this->inclin1At(pos-1);
-    qreal d2 = this->inclin1At(pos);
+    qreal d1 = CliffsCalculator::inclin1At(This,pos-size_t(1));
+    qreal d2 = CliffsCalculator::inclin1At(This,pos);
 
     // This will get the first corner but might be catching too early: d1=0,d2=0
     if ( (d2>=ZERO_INCLIN1&&d1<=-ZERO_INCLIN1) || (d2<=-ZERO_INCLIN1&&d1>=ZERO_INCLIN1)){
         return true;
     }
     return false;
 }
+template bool CliffsCalculator::deriv1Crossed(ListSwitchable<dpoint>& This,size_t pos);
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/src/corners.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/src/corners.cpp`

 * *Files 25% similar despite different names*

```diff
@@ -1,34 +1,25 @@
 // Copyright (C) 2009-2015 Specific Purpose Software GmbH
 // GNU Lesser General Public License, version 2.1
 
 #include "corners.h"
 
 #define debug() QNoDebug()
 
-template<> Corners<dpoint>::Corners() : ListSwitchable<dpoint>() {}
-
-// Note: typename F can be any implementation of ListBase WITHOUT data members
-template<>template<typename F> Corners<dpoint>::Corners(F& list) : ListSwitchable<dpoint>(){
-    ListSwitchable<dpoint>& c = static_cast<ListSwitchable<dpoint>& >(list);
-    *this= static_cast<Corners<dpoint>& >(c);
-}
-
-template Corners<dpoint>::Corners(ListBase<dpoint>& list);
-
 //ShapeMatcher::findCorners
-template<> QList<dpoint> Corners<dpoint>::findCorners(ListCopyable<dpoint> toBeProcessed){
-    QList<dpoint> result = QList<dpoint>();
+template<typename T> QList<T> Corners::findCorners(ListSwitchable<T> toBeProcessed){
+    auto result = QList<T>();
 
-    CornerAnalyzer<dpoint> crest = CornerAnalyzer<dpoint>(toBeProcessed);
+    auto crest = ListSwitchable<dpoint>(toBeProcessed);
     // do this once and don't do it anymore for the rest of the journey: rotation inside
-    crest.cornerFilters();
+    CornerNormalizer::cornerFilters(crest);
 
-    while (crest.size()>0){
-        ListCopyable<dpoint> corner = crest.getFirstCorner();
+    while (crest.size()>size_t(0)){
+        auto corner = CornerAnalyzer::getFirstCorner(crest);
         result<<corner.last();
     }
     // The last one is the end of the crest
     result.removeLast();
     //debug()<<"ShapeMatcher::findCorners: detected "<<result.size()<<" corners in algorithm.";
     return result;
 }
+template QList<dpoint> Corners::findCorners(ListSwitchable<dpoint> toBeProcessed);
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/src/dpoint.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/src/dpoint.cpp`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/src/editorbase.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/src/editorbase.cpp`

 * *Files 22% similar despite different names*

```diff
@@ -8,87 +8,86 @@
 
 template<typename T> EditorBase<T>::EditorBase() : EditorInterface<T>(), data(ListStorage<T>())
 {
     //Note: data has to be allocated in subclass!
     //debug()<<"EditorBase<T>::EditorBase() constructor called and data initialized";
 }
 
-template EditorBase<ListBase<dpoint> >::EditorBase();
+template EditorBase<ListSwitchable<dpoint> >::EditorBase();
 
 //EditorBase::~EditorBase(){
-//    data.input.~ListBase();
-//    data.output.~ListBase();
+//    data.input.~ListSwitchable();
+//    data.output.~ListSwitchable();
 //}
 
 template<typename T> T& EditorBase<T>::getOutput(){
     return data.output;
 }
 
-template ListBase<dpoint>& EditorBase<ListBase<dpoint> >::getOutput();
+template ListSwitchable<dpoint>& EditorBase<ListSwitchable<dpoint> >::getOutput();
 
 
-template<typename T> QList<QPointF> EditorBase<T>::getConvertedOutput() {
-	QList<QPointF> newlist = QList<QPointF>();
+/*template<typename T> ListSwitchable<dpoint> EditorBase<T>::getConvertedOutput() {
+	auto newlist = ListSwitchable<dpoint>();
 	for (int i = 0; i < data.output.size(); i++) {
 		newlist.append(QPointF(data.output[i].x(),data.output[i].y()));
 	}
 	return newlist;
 }
-
-template QList<QPointF> EditorBase<ListBase<dpoint> >::getConvertedOutput();
+template ListSwitchable<dpoint> EditorBase<ListSwitchable<dpoint> >::getConvertedOutput();*/
 
 template<typename T> void EditorBase<T>::setOutput(T list){
     data.output=list;
 }
 
-template void EditorBase<ListBase<dpoint> >::setOutput(ListBase<dpoint> list);
+template void EditorBase<ListSwitchable<dpoint> >::setOutput(ListSwitchable<dpoint> list);
 
-template<> void EditorBase<ListBase<dpoint> >::resetLists(){
+template<> void EditorBase<ListSwitchable<dpoint> >::resetLists(){
     data.input.clear();
     data.output.clear();
 }
 
-template<> void EditorBase<ListBase<dpoint> >::addPoint(QPointF p){
+template<> void EditorBase<ListSwitchable<dpoint> >::addPoint(QPointF p){
      if (p.x()>=0 && p.y()>=0){
          dpoint newpoint(p);
          newpoint.position = data.input.size();
          data.input.push_back(newpoint);
     }else {
          throw std::runtime_error("Invalid point. Only positive point coordinates accepted.");
      }
 }
 
-template<> void EditorBase<ListBase<dpoint> >::flushOutput(){
+template<> void EditorBase<ListSwitchable<dpoint> >::flushOutput(){
     data.output.clear();
     setOutput(data.input);
 }
 
-template<> void EditorBase<ListBase<dpoint> >::automatic(){
+template<> void EditorBase<ListSwitchable<dpoint> >::automatic(){
     this->flushOutput();
     //debug()<<"Computation started with data size "<<this->getOutput().size();
     this->process(this->getOutput());
 }
 
-template<> void EditorBase<ListBase<dpoint> >::automatic(QList<QPointF> list) {
+template<> void EditorBase<ListSwitchable<dpoint> >::automatic(ListSwitchable<dpoint> list) {
 	if (list.size() > 2) {
 		for (int i = 0; i < list.size(); i++) {
 			this->addPoint(list.at(i));
 		}
 		automatic();
 	}
 	else {
         throw std::runtime_error("List can not be valid. At least TCT required.");
 	}
 }
 
-template<> void EditorBase<ListBase<dpoint> >::mainIterator(const QList<dpoint>& constCliffs,QList<QList<dpoint> >& slicesRef){
-    ListCopyable<dpoint> out = ListCopyable<dpoint>(this->getOutput());
+template<> void EditorBase<ListSwitchable<dpoint> >::mainIterator(const ListSwitchable<dpoint> constCliffs,QList<ListSwitchable<dpoint> >& slicesRef){
+    ListSwitchable<dpoint> out = this->getOutput();
     int currentSegment = 0;
     //maemo works: check cliff size
-    std::array<QList<dpoint>::iterator,2> it;
+    std::array<ListSwitchable<dpoint>::iterator,2> it;
     if (constCliffs.size()==0){
         currentSegment += 1;
         it = out.position_to_iterator(out.first().position,out.last().position);
         slicesRef << this->processSegment(it[0],it[1]);
     } else {
         for (int i=0;i<constCliffs.size();i++){
             currentSegment += 1;
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/src/editorcliffs.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/src/editorcliffs.cpp`

 * *Files 15% similar despite different names*

```diff
@@ -1,60 +1,51 @@
 // Copyright (C) 2009-2015 Specific Purpose Software GmbH
 // GNU Lesser General Public License, version 2.1
 
 #include "editorcliffs.h"
-
 #define debug() QNoDebug()
 
-EditorCliffs::EditorCliffs() : EditorBase<ListBase<dpoint> >()
+EditorCliffs::EditorCliffs() : EditorBase<ListSwitchable<dpoint> >()
 {
 }
 
 //EditorCliffs::~EditorCliffs(){
 //    EditorBase::~EditorBase();
 //}
 
 //toBeProcessed is modifying data.output
-void EditorCliffs::process(ListBase<dpoint> &toBeProcessed){
+void EditorCliffs::process(ListSwitchable<dpoint> &toBeProcessed){
     if (this->getOutput().size()>0) {
         /* SHARED CLIFFS&SPIRALS */
-        Cliffs<dpoint> data = Cliffs<dpoint>(toBeProcessed);
-
-        QList<dpoint> cliffs= Cliffs<dpoint>::findCliffs(data);
-
-        /* SHARED After this cliffs is const */
-        const QList<dpoint> constCliffs = cliffs;
+        const ListSwitchable<dpoint> cliffs= Cliffs::findCliffs(toBeProcessed);
 
         /* SHARED CLIFFS&SPIRALS, But replace cornerMeasuring?? */
-        QList<QList<dpoint> > slices= QList<QList<dpoint> >();
-        QList<QList<dpoint> >& slicesRef(slices);
+        QList<ListSwitchable<dpoint> > slices= QList<ListSwitchable<dpoint> >();
 
-        mainIterator(constCliffs,slicesRef);
-        const QList<QList<dpoint> > constSlices= slices;
+        mainIterator(cliffs,slices);
 
-        ListBase<dpoint> result = ListBase<dpoint>();
+        auto result = ListSwitchable<dpoint>();
 
         /* SPIRALS&CLIFFS check */
-        SpiralsAnalyzer<dpoint>::consistencyCheck(constCliffs);
+        SpiralsAnalyzer::consistencyCheck(cliffs);
 
         /* SHARED */
-        result = Analyzer<dpoint>::populateTurns(this->getOutput(),constSlices);
+        result = Analyzer::populateTurns(this->getOutput(),slices);
 
         this->setOutput(result);
     } else {
         throw "EditorCliffs::process called without any data";
     }
 }
 
 // this is a drop-in replacement for processSegment used for clarifying math
-QList<dpoint> EditorCliffs::processSegment(QList<dpoint>::iterator start,QList<dpoint>::iterator end){
-    auto list = QList<dpoint>();
-    std::copy(start,end,std::back_inserter(list));
-    ListRotator<dpoint> cliff = ListRotator<dpoint>(list);
-    QList<dpoint> path_section = QList<dpoint>();
+ListSwitchable<dpoint> EditorCliffs::processSegment(ListSwitchable<dpoint>::iterator start,ListSwitchable<dpoint>::iterator end){
+    auto cliff = ListRotator<dpoint>();
+    std::copy(start,end,std::back_inserter(cliff));
+    ListSwitchable<dpoint> path_section = ListSwitchable<dpoint>();
     if (cliff.size()>1){
         cliff.rotateSegmentToXAxis();
         //debug()<<"removing illegal points because of illegal segments for debug calc.";
         //cliff.removeIllegalPoints();
         //debug()<<"Points "<<cliff.first().position<<" - "<<cliff.last().position;
         //debug()<<"Number of points in Segment: "<<cliff.length();
         //debug()<<"Length of Curve is: "<<cliff.sumLength();
@@ -69,25 +60,25 @@
         ////debug()<<"Diameter is: "<<d<<"; Segment-Diameter-Circumference is: "<<(d*(double)M_PIl);
         //debug()<<"Diameter is: "<<d<<"; Segment-Diameter-Circumference is: "<<ListAnalyzer<dpoint>::circumference(d,MyLimit);
 
         path_section << cliff.first();
         path_section << cliff.last();
         return path_section;
     } else {
-        //throw "EditorCliffs::cornerMeasuring: this is a humongously small cliff.";
+        throw std::logic_error("EditorCliffs::cornerMeasuring: this is a humongously small cliff.");
         return path_section;
     }
 }
 
 // This would be original but it never worked after switching from TCT implementation
-/*QList<dpoint> EditorCliffs::processSegment(QList<dpoint> cliff){
+/*ListSwitchable<dpoint> EditorCliffs::processSegment(ListSwitchable<dpoint> cliff){
     if (cliff.size()>2){
-        QList<dpoint> path_section = QList<dpoint>();
+        ListSwitchable<dpoint> path_section = ListSwitchable<dpoint>();
         path_section << cliff.first();
-        QList<dpoint> turns = Turns<dpoint>::findTurns(cliff);
+        ListSwitchable<dpoint> turns = Turns<dpoint>::findTurns(cliff);
         //debug()<< "Found "<<turns.size()<<" turns in cliff";
         //for (int i=0;i<turns.size();i++){
         //    debug()<< turns[i];
         //}
         path_section << turns;
         path_section << cliff.last();
         return path_section;
@@ -95,28 +86,28 @@
         throw "EditorCliffs::processSegment: segment size is below 3.";
     }
 }*/
 
 // Not USED
 // TCT Implementation
 // FOR REFERENCE ONLY
-/*const void ShapeMatcher::cliffIterator(const QList<dpoint> constCliffs,ListCalculator<dpoint>& resultRef){
+/*const void ShapeMatcher::cliffIterator(const ListSwitchable<dpoint> constCliffs,ListCalculator<dpoint>& resultRef){
     //for (int i=0;i<constCliffs.size()+1;i++){
     // section commented old_implementation
 
     // WHEREFROM:
     ListAnalyzer<dpoint> cliff;
 
         //maemo works: check cliff size
         if (cliff.size()>1){
             //only needed for debugging; crest works with scalar
             ListAnalyzer<dpoint> bugger = cliff;
             bugger.rotateSegmentToXAxis();
             //debug()<<bugger;
-            QList<dpoint> crests = ListAnalyzer<dpoint>();
+            ListSwitchable<dpoint> crests = ListAnalyzer<dpoint>();
             crests << cliff.first() << cliff.last();
 
             if (crests.size()>1){
                 for (int k=0;k<crests.size()-1;k++){
                     ListAnalyzer<dpoint> crest;
                     //if (k != (crests.size()-2) ) {
                     //    crest = output.chopCopy(crests[k].position,crests[k+1].position-1);
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/src/editorspirals.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/src/editorspirals.cpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,55 +1,45 @@
 // Copyright (C) 2009-2015 Specific Purpose Software GmbH
 // GNU Lesser General Public License, version 2.1
 
 #include "editorspirals.h"
-
 //#define debug() QDebug(QtDebugMsg)//::QDebug(QtDebugMsg)
 //#define debug() QNoDebug()
 
 EditorSpirals::EditorSpirals() : EditorCliffs()
 {
 }
 
 //EditorSpirals::~EditorSpirals(){
 //    EditorBase::~EditorBase();
 //}
 
 //toBeProcessed is modifying data.output
-void EditorSpirals::process(ListBase<dpoint> &toBeProcessed){
+void EditorSpirals::process(ListSwitchable<dpoint> &toBeProcessed){
     // use of output is a hack
-    if (this->getOutput().size()>0) {
-        /* SHARED CLIFFS&SPIRALS */
-        QList<dpoint> cliffs;
-
-        /* SPIRALS */
-        Spirals<dpoint> spirals = Spirals<dpoint>(toBeProcessed);
-        cliffs= Spirals<dpoint>::findSpiralCliffs(spirals);
-
-        /* SHARED After this cliffs is const */
-        const QList<dpoint> constCliffs = cliffs;
+    if (this->getOutput().size()>size_t(0)) {
+        /* SHARED CLIFFS&SPIRALS */        
+        const ListSwitchable<dpoint> cliffs= Spirals::findSpiralCliffs(toBeProcessed);
 
         /* SHARED CLIFFS&SPIRALS, But replace cornerMeasuring?? */
-        QList<QList<dpoint> > slices= QList<QList<dpoint> >();
-        QList<QList<dpoint> >& slicesRef(slices);
+        QList<ListSwitchable<dpoint> > slices= QList<ListSwitchable<dpoint> >();
 
-        mainIterator(constCliffs,slicesRef);
-        const QList<QList<dpoint> > constSlices= slices;
+        mainIterator(cliffs,slices);
 
-        ListBase<dpoint> result = ListBase<dpoint>();
+        auto result = ListSwitchable<dpoint>();
 
         /* SPIRALS&CLIFFS check */
-        SpiralsAnalyzer<dpoint>::consistencyCheck(constCliffs);
+        SpiralsAnalyzer::consistencyCheck(cliffs);
 
         /* SHARED */
-        result = Analyzer<dpoint>::populateTurns(this->getOutput(),constSlices);
+        result = Analyzer::populateTurns(this->getOutput(),slices);
 
         //hack
         this->setOutput(result);
     } else {
         throw "EditorSpirals::process called without any data";
     }
 }
 
-QList<dpoint> EditorSpirals::processSegment(QList<dpoint>::iterator start, QList<dpoint>::iterator end){
+ListSwitchable<dpoint> EditorSpirals::processSegment(ListSwitchable<dpoint>::iterator start, ListSwitchable<dpoint>::iterator end){
     return EditorCliffs::processSegment(start,end);
 }
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/src/render.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/src/render.cpp`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/src/spirals.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/src/spirals.cpp`

 * *Files 14% similar despite different names*

```diff
@@ -1,56 +1,43 @@
 // Copyright (C) 2009-2015 Specific Purpose Software GmbH
 // GNU Lesser General Public License, version 2.1
 
 #include "spirals.h"
-
 //#define debug() QNoDebug()
 
 #define MAX_POINTS 5
 //#define LIMIT_TEST M_El
 //#define LIMIT_TEST M_PIl
 #define LIMIT_ITERATION_STEP 0.1
 
-template<> Spirals<dpoint>::Spirals() : ListSwitchable<dpoint>() {}
-
-// Note: typename F can be any implementation of ListBase WITHOUT data members
-template<>template<typename F> Spirals<dpoint>::Spirals(F& list) : ListSwitchable<dpoint>(){
-    ListSwitchable<dpoint>& c = static_cast<ListSwitchable<dpoint>& >(list);
-    *this= static_cast<Spirals<dpoint>& >(c);
-}
-
-template Spirals<dpoint>::Spirals(Spirals<dpoint>& list);
-template Spirals<dpoint>::Spirals(ListBase<dpoint>& list);
+template<typename T> ListSwitchable<T> Spirals::findAreas(const ListSwitchable<T> stroke, qreal limit){
+    auto spiral = ListSwitchable<T>(stroke);
 
+    auto result=ListSwitchable<T>();
 
-template<> QList<dpoint> Spirals<dpoint>::findAreas(ListCopyable<dpoint> &stroke, qreal limit){
-    AreaAnalyzer<dpoint> spiral = AreaAnalyzer<dpoint>(stroke);
-
-    QList<dpoint> result=QList<dpoint>();
-
-    while (spiral.size()>2){
+    while (spiral.size()>size_t(2)){
         //if (stroke.size()>2){
-        ListBase<dpoint> area = spiral.getFirstArea(limit);
-        if (area.size()>0){
+        auto area = AreaAnalyzer::getFirstArea(spiral,limit);
+        if (area.size()>size_t(0)){
             //result << areas;
             result << area.last();
         }
     }
     //result<<stroke.last();
 
     // The very last one is the end of the stroke
-    if (result.size()>0){
+    if (result.size()>size_t(0)){
         result.removeLast();
     }
     return result;
 }
+template ListSwitchable<dpoint> Spirals::findAreas(const ListSwitchable<dpoint> stroke, qreal limit);
 
 // TODO use listcopyables
-template<> qreal Spirals<dpoint>::findLimit(ListCopyable<dpoint> toBeProcessed){
-    QList<dpoint> cliffs;
+template<typename T> qreal Spirals::findLimit(const ListSwitchable<T> toBeProcessed){
     qreal MyLimit;
     //Old working:
     //MyLimit = M_El;
     MyLimit = M_PIl;
     //MyLimit = (M_El+M_PIl)/2;
     //MyLimit = 3.135;
     //MyLimit=2*M_PIl/M_El;
@@ -59,21 +46,19 @@
     // other block:
     //MyLimit=M_PIl/2;
     //MyLimit=0.66666666666666666666666666666666666666666666666666666666666666666666666666 * M_PIl;
     //MyLimit=2*M_PIl/M_El;
     //MyLimit = M_El;
 
     //throw "ShapeMatcher::process: invalid MyLimit";
-
-    cliffs=findAreas(toBeProcessed,MyLimit);
-    cliffs.size();
-    if (cliffs.size()>0){
+    auto cliffs = findAreas(toBeProcessed,MyLimit);
+    if (cliffs.size()>size_t(0)){
             //debug()<<"Found "<<cliffs.size()<<"cliffs, adjusting limit to current minimum";
-            int selector=cliffs.size();
-            QList<dpoint> backup;
+            size_t selector=cliffs.size();
+            auto backup = ListSwitchable<dpoint>();
             qreal backupLimit;
             while (cliffs.size()==(selector)){
                 backupLimit = MyLimit;
                 backup=cliffs;
                 MyLimit -= LIMIT_ITERATION_STEP;
                 cliffs=findAreas(toBeProcessed,MyLimit);
             }
@@ -82,51 +67,49 @@
 
     }
     //if ( (cliffs.size()!=0) && (fmod(cliffs.size(),2) == 0)){
     //    throw "ShapeMatcher::verify: Inconsistency: even number of cliffs not allowed";
     //}
     return MyLimit;
 }
+template qreal Spirals::findLimit(const ListSwitchable<dpoint> toBeProcessed);
 
-template<> QList<dpoint> Spirals<dpoint>::findSpiralCliffs(ListCopyable<dpoint> toBeProcessed){
-    ListCopyable<dpoint> forward = ListCopyable<dpoint>(toBeProcessed);
+template<typename T> ListSwitchable<T> Spirals::findSpiralCliffs(const ListSwitchable<T> toBeProcessed){
 
     //qreal frontSpiral= toBeProcessed.measureSpiral();
     //debug()<<"Forward Spiral Size is: "<<frontSpiral;
     qreal limit = findLimit(toBeProcessed);
     //debug()<<"Limit from forward analysis is: "<<limit;
 
-    // TODO
-    //this should be a copy!
-    Analyzer<dpoint> reversed = Analyzer<dpoint>(toBeProcessed);
+    auto reversed = ListSwitchable<T>(toBeProcessed);
     //reversed.tripletFilters();
-    reversed.reverseOrder();
+    Analyzer::reverseOrder(reversed);
     //qreal backSpiral= reversed.measureSpiral();
     //debug()<<"Backward Spiral Size is: "<<backSpiral;
-    ListCopyable<dpoint> backward = ListCopyable<dpoint>(reversed);
+    const ListSwitchable<dpoint> backward = ListSwitchable<dpoint>(std::move(reversed));
     qreal backLimit = findLimit(backward);
     //debug()<<"Limit from backward analysis is: "<<backLimit;
     //if (static_cast<int>(frontSpiral)!=static_cast<int>(backSpiral)){
         //throw "ShapeMatcher::process: spiral-size front/back not equal";
     //}
 
     // change: use reference?
-    QList<dpoint>* cliffs = new QList<dpoint>;
+    auto cliffs = ListSwitchable<dpoint>();
     if (limit!=backLimit){
         //debug()<< "ShapeMatcher::process: different limits found, using larger";
         if (backLimit>limit){
-            *cliffs = findAreas(backward,backLimit);
+            cliffs = findAreas(backward,backLimit);
             //if (cliffs->size()>0){
-            Calculator<dpoint> calc = Calculator<dpoint>(*cliffs);
+            auto calc = ListSwitchable<dpoint>(cliffs);
             calc.reverse();
-            *cliffs = calc;
+            cliffs = calc;
             //}
         } else {
-            *cliffs = findAreas(forward,limit);
+            cliffs = findAreas(toBeProcessed,limit);
         }
     } else {
         //debug()<<"******************* findAreas::Main **********************";
-        *cliffs = findAreas(forward,limit);
+        cliffs = findAreas(toBeProcessed,limit);
     }
-    return *cliffs;
+    return cliffs;
 }
-
+template ListSwitchable<dpoint> Spirals::findSpiralCliffs(const ListSwitchable<dpoint> toBeProcessed);
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy/src/turnanalyzer.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/src/turnanalyzer.cpp`

 * *Files 15% similar despite different names*

```diff
@@ -1,31 +1,15 @@
 // Copyright (C) 2009-2015 Specific Purpose Software GmbH
 // GNU Lesser General Public License, version 2.1
 
-#include "turnanalyzer.h"
-
 #define SUMLENGTH_FACTOR_SUBDIVISION 1
 
+#include "turnanalyzer.h"
 //#define debug() QNoDebug()
 
-template<> TurnAnalyzer<dpoint>::TurnAnalyzer() : TurnNormalizer<dpoint>() {}
-
-// Note: ALL datamembers of target class destroyed
-template<>template<typename F> TurnAnalyzer<dpoint>::TurnAnalyzer(F& list) : TurnNormalizer<dpoint>(list){
-    ListBase<dpoint> c = static_cast<ListBase<dpoint>& >(list);
-    *this= static_cast<TurnAnalyzer<dpoint>& >(c);
-}
-
-#include "areanormalizer.h"
-template TurnAnalyzer<dpoint>::TurnAnalyzer(AreaNormalizer<dpoint>& list);
-template TurnAnalyzer<dpoint>::TurnAnalyzer(CornerNormalizer<dpoint>& list);
-template TurnAnalyzer<dpoint>::TurnAnalyzer(ListCopyable<dpoint>& list);
-#include "listswitchable.h"
-template TurnAnalyzer<dpoint>::TurnAnalyzer(ListSwitchable<dpoint>& list);
-
 template <> ListCopyable<dpoint> TurnAnalyzer<dpoint>::getFirstTriplet(){
     StraightsAnalyzer<dpoint> result = StraightsAnalyzer<dpoint>();
     if (this->size()>1){
         bool foundOne=false;
         qreal sum=0;
         int j = 0;
         for (int i=0;i<this->size();i++){
@@ -77,103 +61,101 @@
  integrate segment of secondCorner and firstCorner to get 1st turn'
  get point in the middle of first triplet and 1st turn'
 */
 template <> ListCopyable<dpoint> TurnAnalyzer<dpoint>::getFirstTurnByTriplets(){
 
     TurnAnalyzer<dpoint> result = TurnAnalyzer<dpoint>();
     ListCopyable<dpoint> origin = ListCopyable<dpoint>(*this);
-    ListCopyable<dpoint> copy1 = ListCopyable<dpoint>(*this);
-    ListCopyable<dpoint> copy2 = ListCopyable<dpoint>(*this);
 
-    CornerAnalyzer<dpoint> cornerCalculator = CornerAnalyzer<dpoint>(copy1);
+    auto cornerCalculator = ListSwitchable<dpoint>();
+    std::copy(std::begin(*this),std::end(*this),std::back_inserter(cornerCalculator));//BUG ListCopyable to ListSwitchable
     //findTurn: doCorner, findTriplet
     // this has never been rotated, first time in cornerFilters
-    cornerCalculator.cornerFilters();
-    ListCopyable<dpoint> firstCorner = cornerCalculator.getFirstCorner();
+    CornerNormalizer::cornerFilters(cornerCalculator);
+    auto firstCorner = CornerAnalyzer::getFirstCorner(cornerCalculator);
     // we might lose 1 point here: the corner. Prepend 1 point?
     //debug()<<"fresh 1";
 
     //calculator.freshDataSetFrom(origin);
-    TurnAnalyzer<dpoint> calculator = TurnAnalyzer<dpoint>(copy2);
+    TurnAnalyzer<dpoint> calculator = TurnAnalyzer<dpoint>(*this);
 
 
     //debug()<<"Size after: "<<calculator.size();
-    if (calculator.size()>4){
+    if (calculator.size()>size_t(4)){
         calculator.tripletFilters();
         ListCopyable<dpoint> firstTriplet = calculator.getFirstTriplet();
 
-        if (calculator.size()>2){
+        if (calculator.size()>size_t(2)){
             ListCopyable<dpoint> secondTriplet = calculator.getFirstTriplet();
-            if (secondTriplet.size()>2) {
+            if (secondTriplet.size()>size_t(2)) {
                 auto it = origin.position_to_iterator(firstCorner.last().position,secondTriplet.last().position);
-                auto reverse = ListCopyable<dpoint>();
+                auto reverse = ListSwitchable<dpoint>();
                 std::copy(it[0],it[1],std::front_inserter(reverse));
                 // this has to be in triplet detection!
                 //if (reverse.checkIfSectionIsStraightLine()){
                 // start over!
                 //} else {
                 //reverse.reverse();
                 // get First Corner
-                CornerAnalyzer<dpoint> twoTriplets = CornerAnalyzer<dpoint>(reverse);
-                twoTriplets.cornerFilters();
-                ListCopyable<dpoint> secondCorner = twoTriplets.getFirstCorner();
+                auto twoTriplets = ListSwitchable<dpoint>(reverse);
+                CornerNormalizer::cornerFilters(twoTriplets);
+                auto secondCorner = CornerAnalyzer::getFirstCorner(twoTriplets);
                 it = origin.position_to_iterator(firstCorner.last().position,secondCorner.last().position);
-                auto cornerToCorner = ListCopyable<dpoint>();
-                std::copy(it[0],it[1],std::front_inserter(cornerToCorner));
-                //cornerToCorner.reverse();
+                auto normalized_cornerToCorner = TurnAnalyzer<dpoint>();
+                std::copy(it[0],it[1],std::front_inserter(normalized_cornerToCorner));
+                //normalized_cornerToCorner.reverse();
                 // this check is asymetric, improve!
-                if (cornerToCorner.size()>0 && firstTriplet.size()>0){
-                    TurnAnalyzer<dpoint> normalized = TurnAnalyzer<dpoint>(cornerToCorner);
-                    normalized.tripletFilters();
+                if (normalized_cornerToCorner.size()>size_t(0) && firstTriplet.size()>size_t(0)){
+                    normalized_cornerToCorner.tripletFilters();
                     // triplet lost! inline specialization!
-                    dpoint turnTwo = normalized.getFirstTriplet().last();
+                    dpoint turnTwo = normalized_cornerToCorner.getFirstTriplet().last();
                     dpoint turnOne = firstTriplet.last();
-                    ListCopyable<dpoint> container = ListCopyable<dpoint>();
+                    ListSwitchable<dpoint> container = ListSwitchable<dpoint>();
                     // eventually turnLine will have length 1
                     // this belongs into chopcopy
                     //if (turnTwo.position>=turnOne.position){
                     //    container = origin.chopCopy(turnOne.position,turnTwo.position);
                     //inversion
                     //} else if (turnTwo.position<turnOne.position) {
                     //    container = origin.chopCopy(turnTwo.position,turnOne.position);
                     //} else {
                     it = origin.position_to_iterator(turnOne.position,turnTwo.position);
                     container.clear();
                     std::copy(it[0],it[1],std::begin(container));
                     //}
-                    CornerNormalizer<dpoint> turnLine = CornerNormalizer<dpoint>(container);
-                    for (int i=0;this->at(i).position<=turnLine.getPointInTheMiddle().position;i++){
+                    auto turnLine = ListSwitchable<dpoint>(container);
+                    for (int i=0;this->at(i).position<=CornerNormalizer::getPointInTheMiddle(turnLine).position;i++){
                         result<<this->at(i);
                     }
                 } else {
                     throw "ListAnalyzer::getFirstTurnByTriplets: Reverse triplet too short.";
-                    for (int i=0;i<this->size();i++){
+                    for (auto i=size_t(0);i<this->size();i++){
                         result<<this->at(i);
                     }
                 }
                 //}
             } else {
                 throw "ListAnalyzer::getFirstTurnByTriplets: Second triplet too short.";
-                for (int i=0;i<this->size();i++){
+                for (auto i=size_t(0);i<this->size();i++){
                     result<<this->at(i);
                 }
             }
         } else {
             //throw "ListAnalyzer::getFirstTurnByTriplets: Could not find more than 1 triplet.";
-            for (int i=0;i<this->size();i++){
+            for (auto i=size_t(0);i<this->size();i++){
                 result<<this->at(i);
             }
         }
     } else {
         //throw "ListAnalyzer::getFirstTurnByTriplets: Segment is below 5. too short for detection";
-        for (int i=0;i<this->size();i++){
+        for (auto i=size_t(0);i<this->size();i++){
             result<<this->at(i);
         }
     }
 
     // removing
-    for (int i=0;i<result.size();i++){
+    for (auto i=size_t(0);i<result.size();i++){
         this->removeFirst();
     }
 
     return result;
 }
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy-wrappers/IFPyFinders.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/python/IFPyFinders.cpp`

 * *Files 19% similar despite different names*

```diff
@@ -1,41 +1,39 @@
 #include "git.h"
 #include <IFPyShared.h>
 #undef NDEBUG
 #include <pybind11/stl.h>
-//cant remove opaque; no custom caster vector -> array?
+//dont remove opaque; custom caster return type std::vector<int> -> py_list
 PYBIND11_MAKE_OPAQUE(std::vector<sp::timecode<double>>);
 
-#include "turns.h"
 #include "spirals.h"
 #include "cliffs.h"
+#include "editorbase.h"
+#include "analyzer.h"
 
-std::vector<size_t> transform_indices(QList<dpoint> result_qt){
+std::vector<size_t> transform_indices(ListSwitchable<dpoint> result_qt){
     auto result = std::vector<size_t>();
     //gcc: auto or  windows: decltype
     std::transform(std::begin(result_qt),std::end(result_qt),std::back_inserter(result),[](dpoint& it_in){
         return size_t(it_in.position);
     });
     return result;
 }
 
 PYBIND11_MODULE(finders, f){
 	if(GitMetadata::Populated()) {
-		object sha;
+		py::object sha;
 	        if(GitMetadata::AnyUncommittedChanges()) {
-			sha = cast(GitMetadata::CommitSHA1()+"+dirty");
+			    sha = py::cast(GitMetadata::CommitSHA1()+"+dirty");
 	        } else {
-			sha = cast(GitMetadata::CommitSHA1());
+			    sha = py::cast(GitMetadata::CommitSHA1());
 		}
 		f.attr("version") = sha;
 	}
-        //static QList<dpoint> findTurns(ListCopyable<dpoint> toBeProcessed);
-        f.def("Turns",[](QList<dpoint>& in)->std::vector<size_t>{
-            return transform_indices(Turns<dpoint>::findTurns(in));
-        });
-        f.def("Spirals",[](QList<dpoint>& in)->std::vector<size_t>{
-            return transform_indices(Spirals<dpoint>::findSpiralCliffs(in));
-        });
-        f.def("Cliffs",[](QList<dpoint>& in)->std::vector<size_t>{
-            return transform_indices(Cliffs<dpoint>::findCliffs(in));
-        });
+	py::object getters_module = py::module::import("stopeight.getters");
+    f.def("findSpiralCliffs",[](ListSwitchableWrapper& in)->std::vector<size_t>{
+        return transform_indices(Spirals::findSpiralCliffs(in));
+    });
+    f.def("findCliffs",[](ListSwitchableWrapper& in)->std::vector<size_t>{
+        return transform_indices(Cliffs::findCliffs(in));
+    });
 }
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy-wrappers/IFPyShared.h` & `stopeight-0.3.22/stopeight-clibs/legacy/python/IFPyShared.h`

 * *Files 27% similar despite different names*

```diff
@@ -1,25 +1,27 @@
 #undef NDEBUG
 #include <pybind11/pybind11.h>
 #include <pybind11/numpy.h>
 namespace py = pybind11;
 
 #include "turnanalyzer.h"
+#include "corneranalyzer.h"
 #include <stopeight-clibs/shared_types.h>
 #include <stopeight-clibs/Matrix.h>
 
-class QListWrapper : public ListSwitchable<dpoint>
+template<typename F> class ListCopyableWrapper : public F
 {
   public:
-    QListWrapper(py::array_t<sp::timecode<double>, py::array::c_style> other);
-    template<class inType> QListWrapper(inType& other);
-    using ListSwitchable<dpoint>::ListSwitchable;
+    using F::F;
+    ListCopyableWrapper(py::array_t<sp::timecode<double>, py::array::c_style> other);
+    ListCopyableWrapper(const F& other);
 
     py::array_t<sp::timecode<double>, py::array::c_style> toPyArray();
 };
 
-//template TurnAnalyzer<dpoint>::TurnAnalyzer(QListWrapper& list);
-class TurnAnalyzerWrapper : public TurnAnalyzer<dpoint>
-{
+class ListSwitchableWrapper : public ListSwitchable<dpoint>{
   public:
-    template<class inType> TurnAnalyzerWrapper(inType &other);
+    ListSwitchableWrapper(py::array_t<sp::timecode<double>, py::array::c_style> other);
+    ListSwitchableWrapper(ListSwitchable<dpoint>&& other);
+
+    py::array_t<sp::timecode<double>, py::array::c_style> toPyArray();
 };
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy-wrappers/interfacepython.cpp` & `stopeight-0.3.22/stopeight-clibs/legacy/python/interfacepython.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -31,15 +31,15 @@
 }
 
 PyObject* legacy_wrappers::parse_file(PyObject *self, PyObject *args) {
 	const char *pythonpath;
 	if (!PyArg_ParseTuple(args, "s", &pythonpath)) {
 		return legacy_wrappers::error("Filename is not a list");
 	}
-	QList<QPointF> myList = QList<QPointF>();
+	auto myList = QList<QPointF>();
 	try {
 		myList = ListBase<dpoint>::open(pythonpath);
 	}
 	catch (legacy::alg_logic_error exc) {
 		return legacy_wrappers::error(exc);
 	}
 	catch (const char* text) {
@@ -47,104 +47,102 @@
 	}
 	catch (...) {
 		return legacy_wrappers::error("Undefined C-Style Wrapper Error");
 	}
 	return legacy_wrappers::convert(myList);
 }
 
-QList<QPointF> legacy_wrappers::parse_list(PyObject *self, PyObject *args) {
+template<typename F> F legacy_wrappers::parse_list(PyObject *self, PyObject *args) {
 	PyObject* obj;
-	QList<QPointF> list = QList<QPointF>();
+	F list = F();
 	if (!PyArg_ParseTuple(args, "O", &obj)) {
         throw std::runtime_error("Argument is supposed to be a list of a pair of numbers");
 	}
 	PyObject* pyList = PySequence_Fast(obj, "Not a list");
 	int length = PySequence_Size(obj);
 	for (int i = 0; i < length; i++) {
 		PyObject* item = PySequence_Fast_GET_ITEM(pyList, i);
 		if (PySequence_Size(item) != 2) {
             throw std::runtime_error("Malformed point format");
 		}
 		float xValue;
 		float yValue;
 		if (PyArg_ParseTuple(item, "ff", &xValue, &yValue)) {
-			list << QPointF(xValue, yValue);
+			list << typename F::value_type(xValue, yValue);
 		}
 		else {
             throw std::runtime_error("Malformed number format");
 		}
 	}
 	return list;
 }
 
 PyObject * legacy_wrappers::TCT_to_bezier(PyObject* self, PyObject * args)
 {
-	QList<QList<QPointF> > result = QList<QList<QPointF> >();
+	auto result = QList<QList<QPointF> >();
 	try {
-		QList<QPointF> list = legacy_wrappers::parse_list(self, args);		
+		QList<QPointF> list = legacy_wrappers::parse_list<QList<QPointF>>(self, args);
 		result = render::TCTPath(list);
 	}
 	catch (legacy::alg_logic_error exc) {
 		return legacy_wrappers::error(exc);
 	}
 	catch (const char* text) {
 		return legacy_wrappers::error(text);
 	}
 	catch (...) {
 		return legacy_wrappers::error("undefined");
 	}
-	QList<QPointF> unpacked = QList<QPointF>();
+	auto unpacked = QList<QPointF>();
 	for (int i = 0; i < result.size(); i++) {
 		if (i > 0) {
 			result[i].removeFirst();
 		}
 		unpacked.append(result[i]);
 	}
 	return legacy_wrappers::convert(unpacked);
 }
 
 PyObject* legacy_wrappers::stroke_parallel(PyObject *self, PyObject *args) {
 	EditorSpirals editor = EditorSpirals();
 
 	try {
-		editor.automatic(legacy_wrappers::parse_list(self, args));
+		editor.automatic(legacy_wrappers::parse_list<ListSwitchable<dpoint>>(self, args));
 	}
 	catch (legacy::alg_logic_error exc) {
 		return legacy_wrappers::error(exc);
 	}
 	catch (const char* text) {
 		return legacy_wrappers::error(text);
 	}
 	catch (...) {
 		return legacy_wrappers::error("undefined");
 	}
 
-	ListCopyable<dpoint> result = ListCopyable<dpoint>();
-	result = editor.getOutput();
+	ListSwitchable<dpoint> result = editor.getOutput();
 	return legacy_wrappers::convert(ListBase<dpoint>::convert(result));
 }
 
 PyObject* legacy_wrappers::stroke_sequential(PyObject *self, PyObject *args) {
 	EditorCliffs editor = EditorCliffs();
 
 	try {
-		editor.automatic(legacy_wrappers::parse_list(self, args));
+		editor.automatic(legacy_wrappers::parse_list<ListSwitchable<dpoint>>(self, args));
 	}
 	catch (legacy::alg_logic_error exc) {
 		return legacy_wrappers::error(exc);
 	}
 	catch (const char* text) {
 		return legacy_wrappers::error(text);
 	}
 	catch (...) {
 		return legacy_wrappers::error("undefined");
 	}
 
-	ListCopyable<dpoint> result = ListCopyable<dpoint>();
-	result = editor.getOutput();
+	ListSwitchable<dpoint> result = editor.getOutput();
 	return legacy_wrappers::convert(ListBase<dpoint>::convert(result));
 }
 
 #ifdef PY_MAJOR_VERSION
 #if PY_MAJOR_VERSION >= 3
 
 PyMODINIT_FUNC PyInit_legacy(void)
```

### Comparing `stopeight-0.3.14/stopeight-clibs/legacy-wrappers/interfacepython.h` & `stopeight-0.3.22/stopeight-clibs/legacy/python/interfacepython.h`

 * *Files 2% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 
 namespace legacy_wrappers{
 //private
 static PyObject* LegacyError;
 static PyObject* error(const char* message);
 static PyObject* error(legacy::alg_logic_error err);
 static PyObject* convert(QList<QPointF> list);
-static QList<QPointF> parse_list(PyObject *self, PyObject *args);
+template<typename F> static F parse_list(PyObject *self, PyObject *args);
 //public
 static PyObject* parse_file(PyObject* self, PyObject* args);
 static PyObject* TCT_to_bezier(PyObject* self, PyObject* args);
 static PyObject* stroke_parallel(PyObject* self, PyObject* args);
 static PyObject* stroke_sequential(PyObject* self, PyObject* args);
 }
```

### Comparing `stopeight-0.3.14/stopeight-clibs/matrix/Matrix.cpp` & `stopeight-0.3.22/stopeight-clibs/matrix/Matrix.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 // Copyright (C) 2017 Fassio Blatter
 // GNU Lesser General Public License, version 2.1
 
 #include "stopeight-clibs/Matrix.h"
 #include "stopeight-clibs/shared_types.h"
 #include <cmath>
 #include <algorithm>
+#include <stdexcept>
 //#include "GLPlatform.h"
 
 // not available on windows:
 #ifndef M_PI
 #define M_PI        3.14159265358979323846264338327950288
 #endif
 
@@ -21,14 +22,18 @@
 template Vector<float>& Vector<float>::__init(std::initializer_list<float>);
 
 template<typename Container, typename tf> Vectors<Container,tf>::Vectors() : Container() {
 }
 //todo span
 template Vectors<std::vector<sp::timecode<float>>>::Vectors();
 template Vectors<std::vector<sp::timecode<double>>>::Vectors();
+//Hack: external dependency
+template Vectors<std::vector<Vector<float>>>::Vectors();
+template Vectors<std::vector<Vector<double>>>::Vectors();
+
 template<typename Container, typename tf> Vectors<Container,tf>::Vectors(const Container& other) : Container(other) {
 //	int test = 5/0;
 //	*this = Vectors<Container,tf>();//other;
 }
 //todo span
 template Vectors<std::vector<sp::timecode<float>>>::Vectors(const std::vector<sp::timecode<float>>& other);
 template Vectors<std::vector<sp::timecode<double>>>::Vectors(const std::vector<sp::timecode<double>>& other);
```

### Comparing `stopeight-0.3.14/stopeight-clibs/matrix-wrappers/IFPyMatrix.cpp` & `stopeight-0.3.22/stopeight-clibs/matrix/python/IFPyMatrix.cpp`

 * *Files identical despite different names*

### Comparing `stopeight-0.3.14/stopeight.egg-info/PKG-INFO` & `stopeight-0.3.22/stopeight.egg-info/PKG-INFO`

 * *Files 10% similar despite different names*

```diff
@@ -1,24 +1,25 @@
-Metadata-Version: 1.2
+Metadata-Version: 2.1
 Name: stopeight
-Version: 0.3.14
+Version: 0.3.22
 Summary: stopeight: Comparing sequences of points in 2 dimensions
 Home-page: https://github.com/specpose/stopeight
 Author: Fassio Blatter
 Author-email: fassio@specpose.com
 License: GNU General Public License, version 2
 Project-URL: Documentation, https://specpose.github.io/stopeight
-Description: stopeight: Comparing sequences of points in 2 dimensions by visually overlapping them using matrix transformations (translation, scaling and rotation) and getting a boolean result.
 Keywords: signal-analysis time-series pen-stroke
-Platform: UNKNOWN
 Classifier: Development Status :: 3 - Alpha
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Science/Research
 Classifier: Topic :: Scientific/Engineering
 Classifier: Topic :: Scientific/Engineering :: Visualization
 Classifier: Topic :: Scientific/Engineering :: Information Analysis
 Classifier: License :: OSI Approved :: GNU General Public License v2 (GPLv2)
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3 :: Only
-Classifier: Programming Language :: Python :: 3.8
-Requires-Python: >=3.5
+Classifier: Programming Language :: Python :: 3.10
+Requires-Python: >=3.7
+License-File: LICENSE.txt
+
+stopeight: Comparing sequences of points in 2 dimensions by visually overlapping them using matrix transformations (translation, scaling and rotation) and getting a boolean result.
```

